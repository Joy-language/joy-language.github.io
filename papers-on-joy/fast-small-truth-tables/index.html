<!DOCTYPE html>
<html data-n-head="" data-n-head-ssr>
  <head>
    <meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Joy Programming Language" name="description" data-hid="description"><title data-n-head="true">Joy language</title><link href="https://fonts.googleapis.com/css?family=Fira+Sans:200,500|Roboto:400|Roboto+Mono:400" rel="stylesheet" data-n-head="true"><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/favicon.ico?" rel="shortcut icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.10669f42b2e188f55eb1.js" rel="preload" as="script"><link href="/_nuxt/vendor.230cb916d1973aa790f3.js" rel="preload" as="script"><link href="/_nuxt/app.0a856c7cf6fb3e349fa2.js" rel="preload" as="script"><link href="/_nuxt/layouts/default.29c0e08e13310e3682fc.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/fast-small-truth-tables.9b1b75741215fa7afac3.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/survey-of-reproducing-programs.ed8409adcfb2bdec6eeb.js" rel="prefetch"><link href="/_nuxt/pages/libraries-and-c-sources.d2ffa370ff989df9d359.js" rel="prefetch"><link href="/_nuxt/pages/index.73b5e04f9a3fcda5b5fe.js" rel="prefetch"><link href="/_nuxt/pages/about.a3431c5910b96e7d0298.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-algebra-of-joy.7f385b55e84045676f24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-annoying-quadratic-formula.a3d9ef30d4f74df89dfd.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/church-arithmetic-and-church-logic-with-brent-kirby.e11588a1a251690d41af.js" rel="prefetch"><link href="/_nuxt/pages/rationale-for-joy.3e067852511f512169f0.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/tutorial-on-joy.9a4df70c3d63708c2b23.js" rel="prefetch"><link href="/_nuxt/pages/overview-of-joy.8733ad0cbce5d065d604.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/miscellaneous-miniature-implementations-of-joy.417498df53623dd27f3a.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/programming-in-joy.d4bc3bc57b9855085dc1.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-matrix-multiplication-programs.8e00ebe2e6e430523681.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/imperative-thinking-for-joy-programs.223ec58c271bc7112421.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-a-joy-interpreter-written-in-joy.eaa748fa0ea2130e1164.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/joy-compared-with-other-functional-languages.e9b1e34a3b81758a64f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/recursion-theory-and-joy.7d268252a6e6c71fa9f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/nested-recursion-and-a-new-recursion-combinator.d40eac9bf6ad0e5cac92.js" rel="prefetch"><link href="/_nuxt/pages/faq.9ffdbd52d27b2df75f94.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/mathematical-foundations-of-joy.4f0b584e560cf803bb24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/floy-a-flat-concatenative-subset-of-joy.9162d7b51e29e1b5b1b9.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/html-manual.e3473b0453170639a088.js" rel="prefetch"><link href="/_nuxt/pages/faq-part-2.9630745e3aaebc47633f.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/lazy-lists-as-reproducing-programs.9516d2d5134cfed90ce3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-current-implementation.e033c23017443bc35c24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/a-rewriting-system-for-joy.4157d6f1ef190fb675ea.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/atomic-programs-of-joy.f2cb1414ae2b6ed9401e.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/prospectus-for-john-cowans-joy1.cb4661329c1ed2df6752.js" rel="prefetch"><style data-vue-ssr-id="d505b096:0">html{font-family:Roboto,Arial,sans-serif;margin:0;font-weight:400;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box}body{margin:0;height:100%}:after,:before,:not(pre){-webkit-box-sizing:border-box;box-sizing:border-box;margin:0}.wrapper{min-height:calc(100vh - 102px)}a{color:#3273dc;text-decoration:none}a:hover{text-decoration:underline}</style><style data-vue-ssr-id="6cc65792:0">nav[data-v-251e63b6]{background-color:#000}ul[data-v-251e63b6]{list-style-type:none;padding:0;margin:0}li[data-v-251e63b6]{-webkit-transition:all .2s ease-out;transition:all .2s ease-out;display:inline-block;padding:0;cursor:pointer}li[data-v-251e63b6]:hover{-webkit-transform:scale(1.04);transform:scale(1.04);background-color:#fff;color:#000}li a[data-v-251e63b6]{display:block;padding:15px 25px;text-decoration:none;color:#fff;text-align:center}li:hover a[data-v-251e63b6]{color:#000}.nuxt-link-exact-active[data-v-251e63b6]{text-decoration:overline}</style><style data-vue-ssr-id="23d2604d:0">h1[data-v-7e83a563]{font-size:26px}.lists[data-v-7e83a563]{margin-top:37px;padding-left:12vw;padding-right:12vw}.top-list-item[data-v-7e83a563]{margin-top:11px}li[data-v-7e83a563]{line-height:39px}.no-style-litem[data-v-7e83a563]{list-style-type:none}ul[data-v-7e83a563]{list-style-type:circle}h6[data-v-7e83a563]{font-size:17px}p[data-v-7e83a563]{margin-top:8px;line-height:24px;font-size:16px}</style><style data-vue-ssr-id="070b65ba:0">p[data-v-86a4601c]{margin-top:16px;margin-bottom:16px}hr[data-v-86a4601c]{margin-bottom:16px}pre[data-v-86a4601c]{margin-bottom:auto}code[data-v-86a4601c],kbd[data-v-86a4601c],pre[data-v-86a4601c]{font-family:Roboto Mono,monospace}</style><style data-vue-ssr-id="ca9343dc:0">footer[data-v-c785faa8]{padding:11px 20px 0;height:52px}p[data-v-c785faa8]{-webkit-transition:all .1s ease-in;transition:all .1s ease-in;font-size:15px;float:right;margin:0 16px}a[data-v-c785faa8]{color:#000;text-decoration:none}p[data-v-c785faa8]:hover{-webkit-transform:scale(.94);transform:scale(.94);color:#000;-webkit-text-decoration:#3273dc overline;text-decoration:#3273dc overline}</style>
  </head>
  <body data-n-head="">
    <div id="__nuxt" data-server-rendered="true"><div id="__layout"><div class="container" lang="en"><nav data-v-251e63b6 role="navigation"><ul data-v-251e63b6><li data-v-251e63b6><a href="/" data-v-251e63b6 class="nuxt-link-active">Home</a><li data-v-251e63b6><a href="/papers-on-joy" data-v-251e63b6 class="nuxt-link-active">Papers</a><li data-v-251e63b6><a href="/libraries-and-c-sources" data-v-251e63b6>Libraries/C sources</a><li data-v-251e63b6><a href="/about" data-v-251e63b6>About</a></ul></nav><main class="lists" data-v-7e83a563><div data-v-7e83a563><article data-v-86a4601c data-v-7e83a563 data-v-7e83a563><p data-v-86a4601c><em data-v-86a4601c>Abstract</em>: This note describes how small Joy sets (of up to 32 members)
    can be used to encode the lines in a truth table for up to five propositions. This
    results in a surprisingly simple method of providing truth table tests for the
    modal status of formulas (or other modal predicates).
  <p data-v-86a4601c>
    Contents:
  <ul data-v-86a4601c><li data-v-86a4601c><a href="#TOC-1" data-v-86a4601c>Truthfunctional and set-theoretic operations</a><li data-v-86a4601c><a href="#TOC-2" data-v-86a4601c>Set operations in Joy</a><li data-v-86a4601c><a href="#TOC-3" data-v-86a4601c>Truth tables for Joy postfix formulas</a><li data-v-86a4601c><a href="#TOC-4" data-v-86a4601c>Using minimally parenthesised infix notation</a><li data-v-86a4601c><a href="#TOC-5" data-v-86a4601c>Using Cambridge notation</a><li data-v-86a4601c><a href="#TOC-6" data-v-86a4601c>Other applications</a></ul><a name="TOC-1" data-v-86a4601c><h2 data-v-86a4601c>Truthfunctional and set-theoretic operations</h2></a><p data-v-86a4601c>
    Truth tables are the simplest way to determine the modal status of a formula: if
    it is true in all lines then it is a tautology, if it is false in all lines then
    it is a contradiction, and if it is true in some lines and false in others then
    it is contingent. The truthfunctional connectives are normally taken to operate
    on the two truth values, true and false. There is an obvious relationship between
    the connectives in a formula and the set of lines in the truth table in which the
    formula is true: The set of lines in which the negation of a formula is true is
    just the set-theoretic complement of the lines in which the formula itself is true,
    the set of lines in which the conjunction of two formulas is true is just the set-theoretic
    intersection of the lines in which both component formulas are true, and so on.
  <p data-v-86a4601c>
    Hence, instead of evaluating a formula line by line in the truth table, one could
    just use the set-theoretic operations to determine the set of lines in which the
    formula is true. Whether this is efficient depends on the relative speed of the
    truthfunctional (one-bit) operations and the set-theoretic (many-bit) operations.
    Most computers now have word-wide Boolean operations and 32 or even more bits per
    word. and So, set-theoretic operations on sets of up to 32 or even more members
    are as efficient as are the truthfunctional operations. This can be exploited for
    truth tables, and it has the potential of improving performance of small truth
    tables by a factor of up to 32, and even higher for larger size words. With 32
    bits per word, a single word can codify the set of lines of a truth table generated
    by five propositions (2^5 = 32).
  <p data-v-86a4601c>
    Of course nothing can escape the eventual exponential explosion. For six propositions
    the truth table has 2^6 = 64 lines, and, as always, any additional proposition
    doubles the size. So, a six proposition truth table would need to be encoded in
    two words, and then it doubles. However, the 32-fold increase in speed will hold
    no matter how many words are needed for the truth table. Moreover, computers with
    64-bit words are already becoming more common, and 128-bit words are not far off.
    Indeed, some machines alredy have 128-bit registers, and a few can operate on several
    such registers in one cycle.
  <p data-v-86a4601c>
    The rest of this note illustrates the general principle, using just one 32-bit word
    per truth table, and hence is restricted to a maximum of 5 propositions per table.
    <a name="TOC-2" data-v-86a4601c></a><h2 data-v-86a4601c><a name="TOC-2" data-v-86a4601c>Set operations in Joy</a></h2><p data-v-86a4601c>
    The language Joy has as small sets of (generallly 32) integers from 0 onwards (generally
    up to 31). These integers can be taken to be the line numbers of a truth table,
    starting with line number 0.
  <p data-v-86a4601c>
    What is needed, for each atomic proposition, is the set of line numbers of the lines
    in which that proposition is true. In the usual way of writing truth tables, these
    are the five guide columns. In setlib.joy, the standard Joy libray for (small and
    large) sets, there is a module ss for small (32-bit) sets which contains, among
    others, just the right definitions for the current purpose. These definitions are
    here reproduced for convenience:
  <pre data-v-86a4601c>    s1  == { 0  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30 };
      s2  == { 0  1  4  5  8  9 12 13 16 17 20 21 24 25 28 29 };
      s4  == { 0  1  2  3  8  9 10 11 16 17 18 19 24 25 26 27 };
      s8  == { 0  1  2  3  4  5  6  7  8 17 18 19 20 21 22 23 };
      s16 == { 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 };
  </pre><p data-v-86a4601c>
    The names for these sets have been chosen because they are descriptive for general
    use, but they are not customary in logic. Moreover, since these sets are defined
    inside a module, they would have to be referenced as ss.s1, ss.s2, ss.s4 and so
    on. But this is easily overcome by some definitions, chosing p, q, r and so on.
    Also, it is necessary to load the setlib.joy library:
  <pre data-v-86a4601c>"setlib" libload.

  DEFINE
    p == ss.s1; q == ss.s2; r == ss.s4; s == ss.s8; t == ss.s16.
  </pre><p data-v-86a4601c>
    Joy has the Boolean operators 'and', 'or' and 'not', and they are defined for the
    two Boolean types of truth values and (small) sets. So these three can already
    be used for the operations on sets of lines.
  <p data-v-86a4601c>
    But in logic one frequently uses material implication and material equivalence, and
    these operations will be needed. In the definition below they have been chosen
    as say, 'imp' and 'iff'. Also, a set of lines represents a tautology if and only
    if it comprises all lines if and only if it is the universal set. In the definition
    below the predicate 'tautology' is defined to be true if the complement of the
    set is empty.
  <pre data-v-86a4601c>DEFINE
    imp == [not] dip or;
    iff == [imp] [swap imp] cleave and popd;
    tautology == not null
  END
  </pre><a name="TOC-3" data-v-86a4601c><h2 data-v-86a4601c>Truth tables for Joy postfix formulas</h2></a><p data-v-86a4601c>
    No further definitions are needed. The Joy interpreter can now read formulas in Joy
    postfix notation and determine whether they are tautologies. It does so simply
    by executing them and then use tre 'tautology' predicate to determine whether what
    is on top of the stack is the unversal set.
  <pre data-v-86a4601c>p q imp p and  q  imp tautology.
  true
  p q imp q and  p  imp tautology.
  false
  p q or  p r imp  q s imp  and and   r s or   imp  tautology.
  true
  p q or  p r imp  q s imp  and and   r s and  imp  tautology.
  false
  </pre><p data-v-86a4601c>
    A formula that is not a tautology is either contingent or it is a contradiction.
    It might be useful to have two more predicates for this. But simpler still is to
    have a function 'modality' which simply determines which of the three possibilities
    obtains.
  <pre data-v-86a4601c>DEFINE
    modality == 
    [ [ [null] "contradiction" ]
      [ [not null] "tautology" ]
      [ "contingent" ] ]
    cond
    popd
  END
  </pre>
  The use of this predicate is illustrated by the following three similar looking
  stock examples.
  <pre data-v-86a4601c>p p not and   modality.
  "contradiction"
  p q not and   modality.
  "contingent"
  p p not  or   modality.
  "tautology"
  </pre>
  Here are some more examples:
  <br data-v-86a4601c><pre data-v-86a4601c>p q imp p and  q  imp modality.
  "tautology"
  p q imp p and  q  imp not  modality.
  "contradiction"
  p q imp q and  p  imp modality.
  "contingent"
  p q imp q and  p  imp not  modality.
  "contingent"
  p q imp  p not q imp  iff  modality.
  "contingent"
  p q imp  q not p not imp  iff  modality.
  "tautology"
  p q or  p r imp  q s imp  and and   r s or   imp  modality.
  "tautology"
  p q or  p r imp  q s imp  and and   r s or   imp  not  modality.
  "contradiction"
  p q or  p r imp  q s imp  and and   r s and  imp  modality.
  "contingent"
  p q or  p r imp  q s imp  and and   r s and  imp  not  modality.
  "contingent"
  </pre><a name="TOC-4" data-v-86a4601c><h2 data-v-86a4601c>Using minimally parenthesised infix notation</h2></a><p data-v-86a4601c>
    Reverse Polish notation may be second nature to Joy programmers, but it is not to
    logicians who would prefer a more familiar notation. The Joy system has a library
    symlib.joy for symbolic manipulation. It includes many translators from various
    notations to others. One familiar notation is infix, with precedences for the binary
    operators to minimise the need for parentheses. The translating function to reverse
    Polish is called Min2Rev. But the library has to loaded, and it needs to be told
    which operators are to be used, and what their precedences are:
  <pre data-v-86a4601c>"symlib"  libload.

  DEFINE
    unops == [not];
    bin3ops == [and];
    bin2ops == [or];
    bin1ops == [imp iff];
  END
  </pre>
  In the following the first item is a Joy tree representing a formula in minimally
  parenthesised infix notation. This is then translated into a quotation of the same
  formula in Joy notation. The i combinator then executes the quotation, with the result
  that the top of the stack is now the set of lines in the truth table in which that
  formula is true. The tautology predicate then determines whether that set is the
  set of all lines, just as before.
  <pre data-v-86a4601c>[ [p imp q] and p  imp  q ] Min2Rev i tautology.
  true
  [ [p imp q] and q  imp  p ] Min2Rev i tautology.
  false
  </pre>
  But it is more convenient not to have to specify the translation operator
  and the i combinator every time:
  <br data-v-86a4601c><pre data-v-86a4601c>DEFINE
    Mtautology == Min2Rev i tautology;
    Mmodality  == Min2Rev i modality
  END
  </pre><pre data-v-86a4601c>[ [p imp q] iff [not p or q] ]  Mtautology.
  true
  [ [p imp q] iff [not q or p] ]  Mtautology.
  false
  [ [p or q] and [p imp r] and [q imp s]  imp  [r or s] ]  Mmodality.
  "tautology"
  [ [p imp q] iff [q imp p] ]  Mmodality.
  "contingent"

  [ [ [p imp q] and [q imp r] and [r imp s] and [s imp t] ]
    imp [p imp t] ]
  Mmodality.
  "tautology"

  [ [[p imp q] and [q imp r] and [s imp r] and [s imp t]]
    imp  [p imp t] ]
  Mmodality.
  "contingent"
  </pre><a name="TOC-5" data-v-86a4601c><h2 data-v-86a4601c>Using Cambridge notation</h2></a><p data-v-86a4601c>
    In the symlib.joy library there is also a translator from Cambridge (or Lisp) style
    notation to Joy notation. The translator is called Cam2Rev, and it is useful to
    define the following operators straight away:
  <pre data-v-86a4601c>DEFINE
    Ctautology == Cam2Rev i tautology;
    Cmodality  == Cam2Rev i modality
  END
  </pre>
  Here are a few tests:
  <br data-v-86a4601c><pre data-v-86a4601c>[ iff [not [or p q]]  [and [not p] [not q]] ]  Ctautology.
  true
  [ imp [and [imp p q] [imp q r]]  [imp p r] ]  Cmodality.
  "tautology"
  [ imp [and [imp p q] [imp r q]]  [imp p r] ]  Cmodality.
  "contingent"
  </pre><a name="TOC-6" data-v-86a4601c><h2 data-v-86a4601c>Other applications</h2></a><p data-v-86a4601c>
    Testing whether the modal status of a single formula is not the only thing one might
    do. Another obvious application would be a fixed database as a premise, and then
    several queries as conclusions to determine whether certain facts can be deduced
    from the database. Not so obvious would be a reverse example, which tests, for
    several inputs, whether a fixed conclusion follows - and even gives advice accordingly.
  <p data-v-86a4601c>
    For the advice to be at all meaningful, the usual single letter atomic formulas are
    not so intuitive. It is preferable to use multi-letter formulas, and their lines
    in the truth table now have to be defined as before:
  <pre data-v-86a4601c>DEFINE 

    raining == ss.s1; windy == ss.s2; cold == ss.s4; 
    hot == ss.s8; humid == ss.s16; 

    badweather == 
      [ raining and windy  or  cold and windy  or 
        raining and cold  or  hot and  humid ] 
  END
  </pre>
  Since from inconsistent data anything follows, no advice should be given at
  all and an appropriate warning should be supplied. Also, a warning should be given
  if the information was not sufficient to give any kind of advice.
  <pre data-v-86a4601c>DEFINE
    takeadvice == 
      Min2Rev i 
      [ null ] 
      [ "inconsistent data" ] 
      [ badweather Min2Rev i 
        [ [ [and null] "go out" ] 
          [ [imp not null] "stay home" ] 
          [ "insufficient data" ] ] 
        cond ] 
      ifte 
      popd 
  END 
  </pre>
  Finally then, here is the glorious application:
  <br data-v-86a4601c><pre data-v-86a4601c>[ raining and not cold and not [humid or raining] ]    takeadvice. 
  "inconsistent data"
  [ windy and hot and not [hot and not windy] and not raining ] takeadvice. 
  "insufficient data"
  [ cold and windy ]            takeadvice. 
  "stay home"
  [ not [windy or raining or humid] ]       takeadvice. 
  "go out"
  </pre></article></div></main><footer data-v-c785faa8><p data-v-c785faa8><a href="https://github.com/joy-language/joy-lang.org" data-v-c785faa8>GitHub</a></footer></div></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{},{}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.10669f42b2e188f55eb1.js"></script><script defer src="/_nuxt/layouts/default.29c0e08e13310e3682fc.js"></script><script defer src="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js"></script><script defer src="/_nuxt/pages/papers-on-joy/fast-small-truth-tables.9b1b75741215fa7afac3.js"></script><script defer src="/_nuxt/vendor.230cb916d1973aa790f3.js"></script><script defer src="/_nuxt/app.0a856c7cf6fb3e349fa2.js"></script>
  

