<!DOCTYPE html>
<html data-n-head="" data-n-head-ssr>
  <head>
    <meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Joy Programming Language" name="description" data-hid="description"><title data-n-head="true">Joy language</title><link href="https://fonts.googleapis.com/css?family=Fira+Sans:200,500|Roboto:400|Roboto+Mono:400" rel="stylesheet" data-n-head="true"><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/favicon.ico?" rel="shortcut icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.10669f42b2e188f55eb1.js" rel="preload" as="script"><link href="/_nuxt/vendor.230cb916d1973aa790f3.js" rel="preload" as="script"><link href="/_nuxt/app.0a856c7cf6fb3e349fa2.js" rel="preload" as="script"><link href="/_nuxt/layouts/default.29c0e08e13310e3682fc.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/the-current-implementation.e033c23017443bc35c24.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/survey-of-reproducing-programs.ed8409adcfb2bdec6eeb.js" rel="prefetch"><link href="/_nuxt/pages/libraries-and-c-sources.d2ffa370ff989df9d359.js" rel="prefetch"><link href="/_nuxt/pages/index.73b5e04f9a3fcda5b5fe.js" rel="prefetch"><link href="/_nuxt/pages/about.a3431c5910b96e7d0298.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-algebra-of-joy.7f385b55e84045676f24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-annoying-quadratic-formula.a3d9ef30d4f74df89dfd.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/church-arithmetic-and-church-logic-with-brent-kirby.e11588a1a251690d41af.js" rel="prefetch"><link href="/_nuxt/pages/rationale-for-joy.3e067852511f512169f0.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/tutorial-on-joy.9a4df70c3d63708c2b23.js" rel="prefetch"><link href="/_nuxt/pages/overview-of-joy.8733ad0cbce5d065d604.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/miscellaneous-miniature-implementations-of-joy.417498df53623dd27f3a.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/fast-small-truth-tables.9b1b75741215fa7afac3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/programming-in-joy.d4bc3bc57b9855085dc1.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-matrix-multiplication-programs.8e00ebe2e6e430523681.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/imperative-thinking-for-joy-programs.223ec58c271bc7112421.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-a-joy-interpreter-written-in-joy.eaa748fa0ea2130e1164.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/joy-compared-with-other-functional-languages.e9b1e34a3b81758a64f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/recursion-theory-and-joy.7d268252a6e6c71fa9f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/nested-recursion-and-a-new-recursion-combinator.d40eac9bf6ad0e5cac92.js" rel="prefetch"><link href="/_nuxt/pages/faq.9ffdbd52d27b2df75f94.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/mathematical-foundations-of-joy.4f0b584e560cf803bb24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/floy-a-flat-concatenative-subset-of-joy.9162d7b51e29e1b5b1b9.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/html-manual.e3473b0453170639a088.js" rel="prefetch"><link href="/_nuxt/pages/faq-part-2.9630745e3aaebc47633f.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/lazy-lists-as-reproducing-programs.9516d2d5134cfed90ce3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/a-rewriting-system-for-joy.4157d6f1ef190fb675ea.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/atomic-programs-of-joy.f2cb1414ae2b6ed9401e.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/prospectus-for-john-cowans-joy1.cb4661329c1ed2df6752.js" rel="prefetch"><style data-vue-ssr-id="d505b096:0">html{font-family:Roboto,Arial,sans-serif;margin:0;font-weight:400;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box}body{margin:0;height:100%}:after,:before,:not(pre){-webkit-box-sizing:border-box;box-sizing:border-box;margin:0}.wrapper{min-height:calc(100vh - 102px)}a{color:#3273dc;text-decoration:none}a:hover{text-decoration:underline}</style><style data-vue-ssr-id="6cc65792:0">nav[data-v-251e63b6]{background-color:#000}ul[data-v-251e63b6]{list-style-type:none;padding:0;margin:0}li[data-v-251e63b6]{-webkit-transition:all .2s ease-out;transition:all .2s ease-out;display:inline-block;padding:0;cursor:pointer}li[data-v-251e63b6]:hover{-webkit-transform:scale(1.04);transform:scale(1.04);background-color:#fff;color:#000}li a[data-v-251e63b6]{display:block;padding:15px 25px;text-decoration:none;color:#fff;text-align:center}li:hover a[data-v-251e63b6]{color:#000}.nuxt-link-exact-active[data-v-251e63b6]{text-decoration:overline}</style><style data-vue-ssr-id="23d2604d:0">h1[data-v-7e83a563]{font-size:26px}.lists[data-v-7e83a563]{margin-top:37px;padding-left:12vw;padding-right:12vw}.top-list-item[data-v-7e83a563]{margin-top:11px}li[data-v-7e83a563]{line-height:39px}.no-style-litem[data-v-7e83a563]{list-style-type:none}ul[data-v-7e83a563]{list-style-type:circle}h6[data-v-7e83a563]{font-size:17px}p[data-v-7e83a563]{margin-top:8px;line-height:24px;font-size:16px}</style><style data-vue-ssr-id="1275df66:0">p[data-v-1209b73e]{margin-top:16px;margin-bottom:16px}hr[data-v-1209b73e]{margin-bottom:16px}pre[data-v-1209b73e]{margin-bottom:auto}code[data-v-1209b73e],kbd[data-v-1209b73e],pre[data-v-1209b73e]{font-family:Roboto Mono,monospace}</style><style data-vue-ssr-id="ca9343dc:0">footer[data-v-c785faa8]{padding:11px 20px 0;height:52px}p[data-v-c785faa8]{-webkit-transition:all .1s ease-in;transition:all .1s ease-in;font-size:15px;float:right;margin:0 16px}a[data-v-c785faa8]{color:#000;text-decoration:none}p[data-v-c785faa8]:hover{-webkit-transform:scale(.94);transform:scale(.94);color:#000;-webkit-text-decoration:#3273dc overline;text-decoration:#3273dc overline}</style>
  </head>
  <body data-n-head="">
    <div id="__nuxt" data-server-rendered="true"><div id="__layout"><div class="container" lang="en"><nav data-v-251e63b6 role="navigation"><ul data-v-251e63b6><li data-v-251e63b6><a href="/" data-v-251e63b6 class="nuxt-link-active">Home</a><li data-v-251e63b6><a href="/papers-on-joy" data-v-251e63b6 class="nuxt-link-active">Papers</a><li data-v-251e63b6><a href="/libraries-and-c-sources" data-v-251e63b6>Libraries/C sources</a><li data-v-251e63b6><a href="/about" data-v-251e63b6>About</a></ul></nav><main class="lists" data-v-7e83a563><div data-v-7e83a563><article data-v-1209b73e data-v-7e83a563 data-v-7e83a563><p data-v-1209b73e></p><title data-v-1209b73e> The prototype implementation of Joy </title>
    The prototype implementation of Joy
  <p data-v-1209b73e><p data-v-1209b73e><i data-v-1209b73e> by Manfred von Thun </i><p data-v-1209b73e><p data-v-1209b73e>
    Revised March 2003
  <p data-v-1209b73e>Contents
  <ol data-v-1209b73e><li data-v-1209b73e><a href="#TOC_1" data-v-1209b73e>Introduction</a><li data-v-1209b73e><a href="#TOC_2" data-v-1209b73e>Tokens</a><li data-v-1209b73e><a href="#TOC_3" data-v-1209b73e>Factors and terms</a><li data-v-1209b73e><a href="#TOC_4" data-v-1209b73e>Definitions and the main cycle</a><li data-v-1209b73e><a href="#TOC_5" data-v-1209b73e>Initiating a Joy session</a><li data-v-1209b73e><a href="#TOC_6" data-v-1209b73e>Input and output</a><li data-v-1209b73e><a href="#TOC_7" data-v-1209b73e>Error messages</a><li data-v-1209b73e><a href="#TOC_8" data-v-1209b73e>The libraries</a><li data-v-1209b73e><a href="#TOC_9" data-v-1209b73e>Miscellaneous features</a></ol><p data-v-1209b73e><em data-v-1209b73e> Abstract </em> Joy is a functional programming language which is not based on the application of functions
    to arguments but on the composition of functions. This paper serves as a manual for the current prototype implementation.
    Other implementations might differ in some details.
    <a name="TOC_1" data-v-1209b73e></a><h2 data-v-1209b73e><a name="TOC_1" data-v-1209b73e><strong data-v-1209b73e>Introduction</strong></a></h2><p data-v-1209b73e>
    The prototype implementation of Joy is written in unadorned C. It is not the first implementation, earlier ones
    have been written in Pascal, Prolog and Lisp. A small version in C was written by a group of students. The current
    prototype bears almost no resemblance to these earlier versions.
  <p data-v-1209b73e>
    This manual includes references to John Cowan's (2001) major extension to the earlier version of the prototype,
    and also to some additions by Nick Forde. Their help has been invaluable, and it is a pleasure to acknowledge
    their support. I am also grateful to many other members of the "concatenative" mailing group for finding and
    fixing numerous bugs.
  <p data-v-1209b73e>
    The source files for the current implementation are freely available, and can be downloaded in various formats
    by following links from the main page.
  <p data-v-1209b73e>
    In the next three sections the following (extended) <em data-v-1209b73e> BNF notation</em> is used for the grammar: A <em data-v-1209b73e> BNF production</em>  consists of a <em data-v-1209b73e> BNF nonterminal</em> followed by <kbd data-v-1209b73e>::=</kbd> (pronounced "can be"), followed by a BNF expression.
    A <em data-v-1209b73e> BNF expression</em> consists of one or more BNF terms separated by the alternation symbol
    <kbd data-v-1209b73e>|</kbd> pronounced "or". A <em data-v-1209b73e> BNF term</em> consists of one or more BNF factors concatenated. A <em data-v-1209b73e> BNF factor</em>  can be a non-terminal, or a <em data-v-1209b73e> BNF terminal</em> enclosed in double quotes. It can also be an English phrase.
    A BNF factor can also be a BNF expression enclosed in parentheses <kbd data-v-1209b73e>()</kbd> to override precedences, or in
    curly braces <kbd data-v-1209b73e>{}</kbd> to indicate zero or more repetitions, or in square brackets <kbd data-v-1209b73e>[]</kbd> to indicate
    options.
  <p data-v-1209b73e>
    The remainder of this paper gives a provisional manual for the prototype implementation. The focus of this manual
    is on general structure, and it leaves out many details that have been described elsewhere. Also, the manual
    should be understood to be provisional; other implementations of Joy might differ considerably. The first few
    sections to follow describe the syntax and the general semantics of this implementation of Joy. The later sections
    describe some very specific features that have not been covered elsewhere might not be present in other implementations.
    <a name="TOC_2" data-v-1209b73e></a><h2 data-v-1209b73e><a name="TOC_2" data-v-1209b73e><strong data-v-1209b73e>Tokens</strong></a></h2><p data-v-1209b73e>
    This section describes the <em data-v-1209b73e>lexicon</em> of Joy, the individual <em data-v-1209b73e>token</em>s which make up a program.
  <p data-v-1209b73e>
    A Joy program consists of an ASCII file, which consists of lines of characters. Lines beginning with the escape
    character <kbd data-v-1209b73e>$</kbd> are not processed by the Joy interpreter but are dispatched to the command shell. Under
    VMS typical uses are the following:
    <br data-v-1209b73e><pre data-v-1209b73e>        $  show  time
          $  directory
          $  edit  myfile.joy
  </pre>
  Under Unix the corresponding uses are:
  <br data-v-1209b73e><pre data-v-1209b73e>        $  date
          $  ls
          $  vi  myfile.joy
  </pre>
  When the request has been processed, control returns to the Joy system.
  <p data-v-1209b73e>
    Lines not beginning with the escape character are processed by the Joy system. There are two styles of comments:
    parenthesis style and end-of-line style. The first kind of comments are enclosed in starred parentheses,
    <kbd data-v-1209b73e>(*</kbd> and
    <kbdd data-v-1209b73e>*)<kbd data-v-1209b73e>,
      they may continue over several lines:
      <br data-v-1209b73e></kbd></kbdd><pre data-v-1209b73e>        (*  this is a comment
              continued on the second line *)
  </pre>
  The second kind of comments occur after the hash-symbol
  <kb data-v-1209b73e>
    # up to the end of line; no terminator is required:
    <br data-v-1209b73e><pre data-v-1209b73e>            # this comment terminates at the end of this line
           
              # and this comment terminates here
  </pre>
    Comments are not further processed but are treated just like blank space.
    <p data-v-1209b73e>
      An input line consists of a number of <em data-v-1209b73e>token</em>s. Some of these are single characters, the <em data-v-1209b73e>reserved character</em>s.
      They are the two (square) brackets <kbd data-v-1209b73e> [ </kbd> and <kbd data-v-1209b73e> ] </kbd>, the two (curly) braces <kbd data-v-1209b73e>{</kbd> and
      <kbd data-v-1209b73e>}</kbd>, the semicolon <kbd data-v-1209b73e> ; </kbd> and the period<kbd data-v-1209b73e> . </kbd>:
      <br data-v-1209b73e><pre data-v-1209b73e>    reserved-character  ::=
              "["  |  "]"  |  "{"  |  "}"  |  ";"  |  "."
  </pre><p data-v-1209b73e>
      Another kind of token is that of <em data-v-1209b73e>integer constant</em>, a string of one or more decimal digits <kbd data-v-1209b73e>"0"</kbd>    .. <kbd data-v-1209b73e>"9"</kbd> possibly immediately preceded by a unary minus <kbd data-v-1209b73e>"-"</kbd>.
      <br data-v-1209b73e><pre data-v-1209b73e>    integer-constant  ::=
              [ "-" ]  ( "0" | "1" .. | "9" )  { "0" | "1" .. | "9" }
  </pre>
    An integer constant can contain up to 10 digits but must not exceed the platform dependent maximum integer
    (generally $2^{32}-1$).
    <p data-v-1209b73e>
      Apart from integers, the current implementation of Joy also has real numbers or "floats". In the simplest form
      a <em data-v-1209b73e>float constant</em> consists of a string of one or more decimal digits, then a <em data-v-1209b73e>decimal point . </em>    and then at least one more decimal digit or possibly more. As for integer constants, a float constant can optionally
      be preceded by a unary minus. For scientific notation, a float constant can be followed by a scale factor,
      either of the letters "e" or "E" followed by one or more digits.
    <p data-v-1209b73e>
      Instead of writing integers or floats in decimal notation, they can be preceded by "0" to signify octal notation
      (using digits "0" .. "7"), or preceded by "0x" pr "0X" to signify hexadecimal notation (using digits "0" ..
      "9" "A" .. "F").
    <p data-v-1209b73e>
      Others tokens are <em data-v-1209b73e>string constant</em>s and <em data-v-1209b73e>character constant</em>s. Some character sequences beginning
      with the backslash <kbd data-v-1209b73e>"\"</kbd> character inside string constants or character constants are treated as
      <em data-v-1209b73e>escaped character</em>s. A character other than the backslash character is an ordinary character.
      <br data-v-1209b73e><pre data-v-1209b73e>    escaped-character  ::=
                 "\n"                     newline
              |  "\t"                     tab
              |  "\b"                     backspace
              |  "\r"                     carriage return
              |  "\f"                     formfeed
              |  "\'"                     single quote
              |  "\""                     double quote
              |  "\ddd"                   ASCII whose value is ddd
                                          where ddd are three decimal digits
      ordinary-character  ::=
              any character except "\"
  </pre>
    A <em data-v-1209b73e>string constant</em> begins and ends with the double quote character <kbd data-v-1209b73e>"</kbd>, enclosing any sequence
    of zero or more special characters or ordinary characters. A <em data-v-1209b73e>character constant</em> begins with the single
    quote character <kbd data-v-1209b73e>'</kbd> followed by a special character or an ordinary character; there is no closing single
    quote.
    <br data-v-1209b73e><pre data-v-1209b73e>    string-constant  ::=
              '"'  { escaped-character | ordinary-character } '"'
      character-constant  ::=
              "'"  ( escaped-character | ordinary-character )
  </pre><p data-v-1209b73e>
      Of the remaining tokens some are the <em data-v-1209b73e>reserved symbol</em>s:
      <br data-v-1209b73e><pre data-v-1209b73e>    reserved-word  ::=
        "=="  |  "MODULE"  |  "PRIVATE"  |  "PUBLIC"  |  "END"
                                 |  "HIDE"     |  "IN"
                                               |  "DEFINE"
                                               |  "LIBRA"   
  </pre>
    The reserved words "HIDE", "IN", "DEFINE" and "LIBRA" are currently synonyms for "PRIVATE" and "PUBLIC",
    and they may eventually declared obsolescent.
    <p data-v-1209b73e>
      Any other token beginning with a printing character and possibly continuing with upper or lower case letters, digits
      or the three characters <kbd data-v-1209b73e>"="</kbd>, <kbd data-v-1209b73e>"_"</kbd> or <kbd data-v-1209b73e>"-"</kbd> is an <em data-v-1209b73e>atomic symbol</em>.
      <br data-v-1209b73e><pre data-v-1209b73e>    atomic-symbol  ::=
          any printing character which is not a reserved character
              or a digit or the single or double quote character
          { letter  |  digit  |  "="  |  "_"  |  "-" }
  </pre><p data-v-1209b73e>
      To summarise, here is the definition of <em data-v-1209b73e>token</em>s:
      <br data-v-1209b73e><pre data-v-1209b73e>    token  ::=
            reserved-character | reserved-word
    | integer-constant | float-constant
    | character-constant |  string-constant
    | atomic-symbol
  </pre><a name="TOC_3" data-v-1209b73e><h2 data-v-1209b73e><strong data-v-1209b73e>Factors and terms</strong></h2></a><p data-v-1209b73e>
      Individual tokens are used to built up two kinds of syntactic entities called <em data-v-1209b73e>factor</em>s and <em data-v-1209b73e>term</em>s.
      Their definitions are mutually recursive.
    <p data-v-1209b73e>
      A <em data-v-1209b73e>factor</em> can be a single token such as an atom or one of the three constants: integer constant, character
      constant or string constant. A factor can also consists of a (possibly empty) sequence of integer or character
      constants enclosed in the curly brace tokens <kbd data-v-1209b73e>{</kbd> and <kbd data-v-1209b73e>}</kbd>. Finally, a factor can also be a
      (possibly empty) term enclosed in the square bracket tokens
      <kbd data-v-1209b73e>[</kbd> and <kbd data-v-1209b73e></kbd>}.
      <br data-v-1209b73e><pre data-v-1209b73e>    factor  ::=
             atomic-symbol
          |  integer-constant | float-constant
          |  character-constant | string-constant
          |  "{"  { character-constant | integer-constant } "}"
          |  "["  term  "]"
  </pre>
    A <em data-v-1209b73e>term</em> consists of zero or more factors.
    <br data-v-1209b73e><pre data-v-1209b73e>    term  ::=
          { factor }
  </pre><p data-v-1209b73e>
      For the <em data-v-1209b73e>semantics</em> another classification is essential. Factors are either <em data-v-1209b73e>literal</em>s or <em data-v-1209b73e>operator</em>s
      or <em data-v-1209b73e>combinator</em>s. A literal can be one of the two atomic symbols
      <kbd data-v-1209b73e>"true"</kbd> or <kbd data-v-1209b73e>"false"</kbd> -- these are the logical literals. A literal can also be one of the
      four constants and these are then called
      <em data-v-1209b73e>integer literal</em>,
      <em data-v-1209b73e>float literal</em>, <em data-v-1209b73e>character literal</em> or <em data-v-1209b73e>string literal</em>. A literal can also consist of
      the braces enclosing characters or integers - these are the <em data-v-1209b73e>set literals</em>. Finally a literal can consist
      of the brackets enclosing a term - these are the <em data-v-1209b73e>quotation literals</em> or simply <em data-v-1209b73e>quotations</em>.
      If the term consists just of literals, the factor is called a <em data-v-1209b73e>list list</em> or just a <em data-v-1209b73e>list</em>.
      <br data-v-1209b73e><pre data-v-1209b73e>    literal  ::=
             "true"  |  "false"
    |  integer-constant | float-constant
    |  character-constant | string-constant
          |  "{"  { character-constant | integer-constant } "}"
          |  "["  term  "]"
  </pre>
    The other atomic factors are either built in or defined. All built in atomic factors are either operators
    or combinators. Most defined atomic factors are likely also to be operators or combinators, but it is possible
    to define atomic symbols which are literals.
    <p data-v-1209b73e><em data-v-1209b73e>factor</em>s and <em data-v-1209b73e>term</em>s denote functions which take one argument and yield one value or result.
      The argument and the result consist principally of a <em data-v-1209b73e>stack of values</em>, but have as minor components
      several <em data-v-1209b73e>input file</em>s and one <em data-v-1209b73e>output file</em>. The stack is normally a sequence of values of the
      kind denoted by constants and thus it resembles a list. But in (rather rare) cases the stack can contain operators
      or combinators. So the stack is essentially the same thing as a term. Most of the functions affect only the
      stack component. An empty term denotes the identity function. A non-empty term, consisting of one or more factors
      concatenated, denotes the composition of the functions denoted by the factors. The functions denoted by the
      factors are applied in the order in which the factors are written.
    <p data-v-1209b73e>
      All literal factors denote functions yielding as result a stack component which is like the argument stack except
      that the value of the literal has been pushed on top of the stack. The operator factors expect as argument
      a stack which has to contain one or more values. They denote functions yielding as a result another stack which
      is like the argument stack except that the top few values have been replaced by others. The combinator factors
      are like the operator factors in that they expect a stack containing certain values. Specifically, the combinator
      factors expect a stack containing one or more quotations and possibly some other values. Combinators will execute
      the terms contained in the quotations.
    <p data-v-1209b73e>
      The file
      <a href="joy/plain-manual.html" data-v-1209b73e>
      Online manual (raw Joy1) </a> gives a very synoptic explanation of the inbuilt primitives of <em data-v-1209b73e>raw Joy1</em>    -- that is, excluding anything defined in one or the other library. The arrow <kbd data-v-1209b73e>-></kbd> indicates that
      the operator or combinator that is being described expects on top of the stack the items on the left of the
      arrow and returns a stack on top of which are the items on the right. The content of this file is identical
      in content with that obtained by the <kbd data-v-1209b73e>manual</kbd> command.
      <a name="TOC_4" data-v-1209b73e></a><h2 data-v-1209b73e><a name="TOC_4" data-v-1209b73e><strong data-v-1209b73e>Definitions and the main cycle</strong></a></h2>
    Joy programs can be written using only the inbuilt atomic symbols, but it also possible to define new symbols.
    There are several kinds of reason why one might want to define new symbols: because they are needed in various
    places in the program, because they involve recursion or because they make the program more intelligible. The
    first two reasons are less compelling in Joy than in most other languages.
    <p data-v-1209b73e>
      Often one needs not just one <em data-v-1209b73e>definition</em> but a <em data-v-1209b73e>sequence</em> of definitions, and these are then
      separated by semicolons "<kbd data-v-1209b73e>;</kbd>".
      <br data-v-1209b73e><pre data-v-1209b73e>    definition-sequence  ::=
          definition  { ";"  definition }
  </pre><p data-v-1209b73e>
      Definitions can be of two kinds: simple or compound. A <em data-v-1209b73e>simple definition </em>consists of a user-chosen
      atomic symbol followed by the <kbd data-v-1209b73e>==</kbd> token followed by a term:
      <br data-v-1209b73e><pre data-v-1209b73e>    simple-definition  ::=
            atomic-symbol  "=="  term
  </pre>
    A <em data-v-1209b73e>simple definition</em> introduces the new atomic symbol into the current working dictionary. The initial
    dictionary is empty. After the definition the new symbol can be used, and if executed its effect is that of executing
    the term.
    <p data-v-1209b73e>
      A <em data-v-1209b73e>compound definition</em> consists of 1) optionally the <kbd data-v-1209b73e>MODULE</kbd> token followed by an atomic
      symbol, then 2) optionally either the <kbd data-v-1209b73e>PRIVATE</kbd> token followed by a definition sequence, then 3) optionally
      the <kbd data-v-1209b73e>PUBLIC</kbd> token followed by a definition sequence, and finally either the "<kbd data-v-1209b73e>.</kbd>" (period)
      token or the <kbd data-v-1209b73e>END</kbd> token. At least one of the three options must be present:
      <br data-v-1209b73e><pre data-v-1209b73e>    compound-definition  ::=
    [ "MODULE"  atomic-symbol ]
    [ "PRIVATE"  definition-sequence ]
    [ "PUBLIC"  definition sequence ]
    ( "." | "END" )
  </pre>
    Instead of <kbd data-v-1209b73e>PRIVATE...PUBLIC...</kbd> the combination
    <kbd data-v-1209b73e>HIDE...IN...</kbd> can be used, and instead of <kbd data-v-1209b73e>PUBLIC...</kbd> the syntax <kbd data-v-1209b73e>LIBRA...</kbd> or
    <kbd data-v-1209b73e>DEFINE...</kbd> can be used. These alternative symbols may become obsolscent in the future, but will be
    supported for the time being.
    <p data-v-1209b73e>
      In the simplest case only the <kbd data-v-1209b73e>PUBLIC</kbd>-part is present. In that case all <em data-v-1209b73e>definition</em>s in the
      <em data-v-1209b73e>definition sequence</em> are entered into the symbol table. If there is a <kbd data-v-1209b73e>PRIVATE</kbd>-part, then
      any <em data-v-1209b73e>definition</em>s in its <em data-v-1209b73e>definition sequence</em> are entered into the symbol tableand are then
      available for use by the <kbd data-v-1209b73e>PUBLIC</kbd>-part. However, the <kbd data-v-1209b73e>PRIVATE<kbd data-v-1209b73e><em data-v-1209b73e>definition</em>s are
      then obscured at the end of the <kbd data-v-1209b73e>PUBLIC</kbd><em data-v-1209b73e>definition sequence</em> and are then not available any further. If there is a <kbd data-v-1209b73e>MODULE</kbd>-part,
      then all subsequent <kbd data-v-1209b73e>PRIVATE</kbd> and <kbd data-v-1209b73e>PUBLIC</kbd><em data-v-1209b73e>definition</em> are visible as before except that at the end of the <kbd data-v-1209b73e>PUBLIC</kbd><em data-v-1209b73e>definition sequence</em>    all <em data-v-1209b73e>definition</em>s are obscured except the name of the module. In that case the <em data-v-1209b73e>definition</em>s
      of the <kbd data-v-1209b73e>PUBLIC</kbd>-part can only be accessed as factors by what is called "qualified access", in the
      form
      <br data-v-1209b73e></kbd></kbd><pre data-v-1209b73e> m . f   or   m.f
  </pre>
    where <kbd data-v-1209b73e>m</kbd> and <kbd data-v-1209b73e>f</kbd> are respectively the name of the module and of a function from its <kbd data-v-1209b73e>PUBLIC</kbd>-part.
    <p data-v-1209b73e>
      In many uses of Joy the initial input will be from the terminal keyboard and the output will be to the terminal
      screen. Operating systems will generally allow the input and the output to be redirected, so that the input
      comes from a disk file or the output goes to a disk file, or both. Whatever the actual input file is, it will
      consist of a a number of requests to the Joy system. A request is either a compound <em data-v-1209b73e>definition</em>    or it is a term followed by either the <kbd data-v-1209b73e>END</kbd> token or just a period "<kbd data-v-1209b73e>.</kbd>".
      <br data-v-1209b73e><pre data-v-1209b73e>    cycle  ==
          {    compound-definition
      |  term  ( "END" | "." ) }
  </pre>
    In the first case the compound <em data-v-1209b73e>definition</em> is processed and control returns to the top level. In
    the second case the term is executed on the current stack. In the default mode the top value on the stack is
    then written the output file, normally the screen. If several terms are executed in succession, each term inherits
    from the preceding term the remainder of the stack. This can be useful when debugging larger programs. On the
    other hand, every library declaration clears the stack. The inbuilt factor <kbd data-v-1209b73e>abort</kbd> returns to the main
    cycle, but it leaves the stack intact.
    <a name="TOC_5" data-v-1209b73e><h2 data-v-1209b73e><strong data-v-1209b73e>Initiating a Joy session</strong></h2></a>
    A session with Joy is initiated by running
    the Joy interpreter in whatever ways the installation allows or requires. In most cases this will be done from
    the top level of the command language. In Unix it might simply be
    <br data-v-1209b73e><pre data-v-1209b73e> $  joy
  </pre>
    and under VMS it might be
    <br data-v-1209b73e><pre data-v-1209b73e> $  RUN JOY
  </pre>
    or, if "JOY" has been appropriately defined as a symbol,
    <br data-v-1209b73e><pre data-v-1209b73e> $  JOY
  </pre>
    The Joy interpreter will then announce itself with a brief banner. In the simplest case the Joy interpreter
    will then use the keyboard as the first input device and start the main cycle by taking input from there. Output
    will be to the screen.
    <p data-v-1209b73e>
      However, although this is the simplest case, it is not the most common. If the current directory contains a file
      by the name "<kbd data-v-1209b73e>usrlib.joy</kbd>", this will become the first input file, and the main cycle will start
      reading requests from there. Typically this file will contain some <em data-v-1209b73e>definition</em>s specific to the particular
      user, or to the particular installation, or to the particular operating system. Typically this file will also
      contain a directive to continue by reading some of the standard libraries, or to continue with some other files.
      When these requests have been serviced, the main cycle will continue by reading inputs from the keyboard, unless
      the main cycle has been terminated before that happens.
    <p data-v-1209b73e>
      Most operating systems allow input to and output from a program to be "redirected" to come not from the keyboard
      or go to the screen, but to come from and go to a file. In Unix the Joy interpreter can be run with the input
      redirected from a file, say "<kbd data-v-1209b73e>my-input.joy</kbd>", like this:
      <br data-v-1209b73e><pre data-v-1209b73e> $  joy  &lt;my-input.joy
  </pre>
    It is also possible to redirect the output to go to, say "<kbd data-v-1209b73e>my-output.txt</kbd>", like this:
    <br data-v-1209b73e><pre data-v-1209b73e> $  joy  &lt;my-input.joy  >my-output.txt
  </pre>
    The same can also be done in VMS, but here it is necessary that both redirections occur:
    <br data-v-1209b73e><pre data-v-1209b73e> $  JOY /INPUT=MY-INPUT.JOY  /OUTPUT=MY-OUTPUT.TXt
  </pre>
    With redirection of the input the behaviour of the Joy interpreter again depends on whether the current
    directory contains a file "
    <kbd data-v-1209b73e>usrlib.joy</kbd>". If there is such file, then that is read first, and only then the main cycle reads not
    from the keyboard but from the redirected file. If there is no file "<kbd data-v-1209b73e>usrlib.joy</kbd>", the main cycle will
    immediately read from the redirected file.
    <p data-v-1209b73e>
      Under some operating systems it is possible to give what are called command line arguments to a program that is
      to run. This is very familiar under Unix, where the Joy interpreter might be run like this:
      <br data-v-1209b73e><pre data-v-1209b73e> $  joy  P1  P2  P3
  </pre>
    with in this case three arguments P1 P2 P3. Under VMS it is also possible to define programs as "foreign
    commands" by a <em data-v-1209b73e>definition</em> (possibly in <kbd data-v-1209b73e>login.com</kbd>):
    <br data-v-1209b73e><pre data-v-1209b73e> $  JOY == "$DSK-XYZ[MYNAME.JOYDIR]JOY.EXE"
  </pre>
    where <kbd data-v-1209b73e>DSK-XYZ</kbd>, <kbd data-v-1209b73e>MYNAME</kbd> and <kbd data-v-1209b73e>JOYDIR</kbd> are respectively the user's disk, the
    user's name and the directory on which the executable interpreter is located. The joy interpreter is then run
    with parameters P1 P2 P3 by
    <br data-v-1209b73e><pre data-v-1209b73e> $  JOY  P1  P2  P3
  </pre><p data-v-1209b73e>
      When the Joy interpreter is run with command line arguments, the first parameter P1 must be a valid file name.
      The interpreter then attempts to open that file for reading, and if that attempt fails it exits. If the attempt
      succeeds, all further commands are taken not from standard input (possibly redirected) but from that file.
      This means that any explicit input from the "get" command can still come from standard input.
    <p data-v-1209b73e>
      When Joy is run with command line parameters, say by
      <br data-v-1209b73e><pre data-v-1209b73e> $  joy  test.joy  mary  42
  </pre>
    the number of parameters is available by the operator
    <kbd data-v-1209b73e>argc</kbd> which pushes an "argument count", in this case 3. Also, a list of the parameters is available
    by the operator
    <kbd data-v-1209b73e>argv</kbd> which pushes the "argument vector", in this case the list <kbd data-v-1209b73e>[ "test.joy"  "mary"  "42" ]</kbd>.
    <p data-v-1209b73e>
      Under Unix and under VMS one can write files that are to be executed by the command interpreter and whose first
      line calls Joy and uses the rest of the file s input to Joy. In Unix these are "here documents", for VMS they
      are ".com" files. With the command line arguments to Joy there is another, more elegant, possibility using
      the "#!" facility (interpreted by the Unix <em data-v-1209b73e>exec</em> system call). For Joy such a file would have to
      start with "#!joy" as the first line, and the rest of the file as input to Joy. The file
      <a href="joy/gcd" data-v-1209b73e>gcd</a> is an example which uses Joy to compute the greatest common divisor. After it has
      been created, it has to be made executable with 
    <pre data-v-1209b73e>$ chmod +x gcd</pre>
    and thereafter it can be run
    with command lines such as
    <pre data-v-1209b73e>$ gcd 45 100</pre>
    which will give the answer <kbd data-v-1209b73e>5</kbd>.
    <a name="TOC_6" data-v-1209b73e><h2 data-v-1209b73e><strong data-v-1209b73e>Input and output</strong></h2></a><p data-v-1209b73e>
      For many applications no explicit output operation is needed because in the default mode the main cycle will always
      write the value of the top of stack to the output stream. But sometimes explicit output is useful. There are
      two basic output operators: <kbd data-v-1209b73e>put</kbd> will remove a value of any type from the stack and write it
      to the output stream.
      <kbd data-v-1209b73e>putch</kbd> will remove a value of a numeric type (character or integer) and write it as a single ASCII
      character to the output stream. Other useful output operations are defined in the library.
    <p data-v-1209b73e>
      In the default mode the Joy system will write the value of the top of stack item to the output. The mode is under
      the control of a flag with value 0 and 1. If the value is 0, no automatic output occurs. If the value is 1,
      the default, output of the top value occurs after the evaluation of every term in the main cycle. If the value
      is 2, the entire stack is output after such an evaluation. The value of this flag can be changed by the <kbd data-v-1209b73e>setautoput</kbd>    operator, typical use is
      <br data-v-1209b73e><pre data-v-1209b73e>        0  setautoput.
  </pre><p data-v-1209b73e>
      Most Joy programs operate on a stack, several input files and one output file. The initial input comes either from
      the keyboard or it can be redirected to come from a diskfile, or it can be not from standard input but from
      a file specified as a command line argument. Often it is useful to include other files, typically diskfiles,
      in the input. Joy has an <kbd data-v-1209b73e>include</kbd> operator for this purpose. It takes a string on the stack as
      a parameter and opens a file with that name and henceforth accepts input from there. A typical use might be
      <br data-v-1209b73e><pre data-v-1209b73e>        "test.joy"  include.
  </pre>
    Included files can contain library <em data-v-1209b73e>definition</em>s or <em data-v-1209b73e>term</em>s to be executed. They can contain
    other <kbd data-v-1209b73e>include</kbd> operators, up to a level of 10. When the end of an included file is reached, input reverts
    to the previous file which contained the relevant <kbd data-v-1209b73e>include</kbd> operator. The include files therefore form
    a stack.
    <p data-v-1209b73e>
      Users will often want their own selection of systems or private libraries read in automatically when the system
      starts up. For this purpose the Joy system always starts by checking whether a file "<kbd data-v-1209b73e>usrlib.joy</kbd>"
      exists in the user's current directory. That file can be empty, but it can contain user specific <em data-v-1209b73e>definition</em>s
      and it can contain particular <em data-v-1209b73e>term</em>s to be executed. One such <em data-v-1209b73e>term</em> might be a directive to
      include yet another file, perhaps
      <br data-v-1209b73e><pre data-v-1209b73e>        "inilib.joy"  include.
  </pre>
    which transfers input to the <em data-v-1209b73e>initial library</em>, <kbd data-v-1209b73e>inilib.joy</kbd>, one of the systems libraries
    for Joy. These libraries are described in the next section.
    <p data-v-1209b73e>
      If input does not come from the keyboard but from an include file, it is often useful to see the current input
      on the screen. Normally the Joy system does not echo keyboard or other input on the screen or output file,
      but it can be made to do so. Joy has an internal <em data-v-1209b73e>echoflag</em> with values 0, 1, 2 or 3.. The initial
      default value is 0, and then no echo occurs. If the value is 1, then input lines are echoed to the output without
      change. If the value is 2, then each line is preceded by a tab (ASCII 9) -- this can help to distinguish echoed
      lines in the output from others. If the value is 3, then each tab is preceded by a line number specific to
      the current input file. When input reverts to an earlier file, the earlier line numbering is resumed. The value
      of the echo flag can be set by the operator <kbd data-v-1209b73e>setecho</kbd>. Typically the value will be set by something
      like
      <br data-v-1209b73e><pre data-v-1209b73e>        2  setecho.
  </pre><a name="TOC_7" data-v-1209b73e><h2 data-v-1209b73e><strong data-v-1209b73e>Error messages</strong></h2></a><p data-v-1209b73e>
      When a Joy program is processed, two kinds of programming errors can occur. The first kind can occur during reading
      of the input file. Because the syntax of Joy is so simple, there are only few possibilities for error. The
      second kind can occur at runtime when a term is being executed. These errors concern incorrect parameters for
      operators and combinators. Because there are many kinds of operators and combinators, the possibilities for
      runtime errors are great.
    <p data-v-1209b73e>
      Errors of the first kind occur during reading a program. Since the input line is still available at that time,
      it is possible for the error message to point to the exact place at which the error occurred. If input comes
      from the initial input file, most likely the terminal, it is not repeated. In other case it is repeated, including
      its line number. The next line then consists just of an up-arrow <kbd data-v-1209b73e>"^"</kbd> pointing to the error position.
      Following that is a line containing the specific error message.
    <p data-v-1209b73e>
      The following (rare) message can be reported when reading tokens, it occurs when the second or third digit in an
      escaped character is missing.
      <br data-v-1209b73e><pre data-v-1209b73e>        digit expected
  </pre>
    The following errors can occur when reading factors:
    <br data-v-1209b73e><pre data-v-1209b73e>        numeric expected in set
          ']' expected
          a factor cannot begin with this symbol
  </pre>
    The following errors can occur when reading <kbd data-v-1209b73e>HIDE</kbd> declarations:
    <br data-v-1209b73e><pre data-v-1209b73e>        IN expected in HIDE-definition
          END expected in HIDE-definition
  </pre>
    The following errors can occur when reading <em data-v-1209b73e>definition</em>s:
    <br data-v-1209b73e><pre data-v-1209b73e>        atom expected at start of <em data-v-1209b73e>definition</em>
          == expected in <em data-v-1209b73e>definition</em>
  </pre><p data-v-1209b73e>
      All other errors are <em data-v-1209b73e>runtime error</em>s. These are given in the form:
      <br data-v-1209b73e><pre data-v-1209b73e>    "run time error: "  MESSAGE  " needed for "  NAME
  </pre>
    Two examples are
    <br data-v-1209b73e><pre data-v-1209b73e>    run time error: fewer include files needed for include
      run time error: valid file name needed for include
  </pre>
    In general, the <kbd data-v-1209b73e>NAME</kbd> is the name of the operator or combinator whose execution was attempted
    but failed. The <kbd data-v-1209b73e>MESSAGE</kbd> is often the same for many operators or combinators. It can be one of the
    following:
    <br data-v-1209b73e><pre data-v-1209b73e>        one parameter
          two parameters
          three parameters
          four parameters
          four parameters
          quotation as top parameter
          quotation as second parameter
          quotation as third parameter
          quotation as fourth parameter
          two parameters of the same type
          integer
          two integers
          numeric
          numeric second parameter
          non-zero operand
          list
          list as second parameter
          user defined symbol
          internal list
          small numeric
          non-empty set
          non-empty string
          non-empty list
          smaller index
          aggregate parameter
          different type
  </pre><p data-v-1209b73e>
      Some apparently inexplicable runtime errors can occur when reading an included library file which is syntactically
      correct and hence does not produce an error message as it is read in. The program can still contain a logical
      error which causes something unintended to be executed that produces a run time error. In that case it is helpful
      to use <kbd data-v-1209b73e>setecho</kbd> to set the echoflag to <kbd data-v-1209b73e>3</kbd>, resulting in line numbers to be printed
      as the included file is read in. There have been two occasions where this trick helped clear up a problem.
      <a name="TOC_8" data-v-1209b73e></a><h2 data-v-1209b73e><a name="TOC_8" data-v-1209b73e><strong data-v-1209b73e>The libraries</strong></a></h2><p data-v-1209b73e>
      The Joy system has a growing number of library files containing definitions which extend the core Joy language.
      he following is a brief description of the various libraries in the current distribution. The actual content
      of all the libraries is still subject to minor change, so these descriptions should only be taken to be a rough
      guide.
    <p data-v-1209b73e>
      The first two libraries below are very atypical: the first because it does not even have to exist at all, the second
      because it is assumed by just about all other libraries and hence is quite non-specific.
    <p data-v-1209b73e><dl data-v-1209b73e><dt data-v-1209b73e><a href="joy/usrlib.joy" data-v-1209b73e>usrlib.joy</a><br data-v-1209b73e><dd data-v-1209b73e><p data-v-1209b73e>This <em data-v-1209b73e>user library</em> is intended to be just an example of what a personalised file <kbd data-v-1209b73e>usrlib.joy</kbd>        might look like. When Joy is run with input coming from the <em data-v-1209b73e>standard input stream</em>, on startup
          Joy will first determine whether there is a file
          <kbd data-v-1209b73e>usrlib.joy</kbd> in the current directory. If there is, it is opened for reading. When the end is
          reached, or when there is no such file, the terminal or the designated inpu file is used. For any particular
          user this file might look very different -- it might be empty, or it might might contain just a directive
          to include the library described next, or it might contain fewer or it might contain more definitions,
          or it might contain definitions of a very different kind.
        <dt data-v-1209b73e><a href="joy/inilib.joy" data-v-1209b73e>inilib.joy</a><br data-v-1209b73e><dd data-v-1209b73e><p data-v-1209b73e>This <em data-v-1209b73e>initial library</em> contains a disparate collection of operators and combinators that are widely
          useful. Most are not dependent on particular types. Some of them might eventually be incorporated as primitives
          into the Joy language. Currently there are a few simple operators to help with explicit input and output,
          some operators for dates and times, some operators on predicates, and some useful combinators. Finally
          there are some utilities to help loading and managing libraries. All other libraries wiil ensure either
          directly or indirectly that this library is also loaded.
        </dl><p data-v-1209b73e>The following <em data-v-1209b73e>basic libraries</em> contain definitions of still rather general operators and combinators
      but related to specific types or groups of types.
    <dl data-v-1209b73e><dt data-v-1209b73e><a href="joy/agglib.joy" data-v-1209b73e>agglib.joy</a><br data-v-1209b73e><dd data-v-1209b73e><p data-v-1209b73e>This <em data-v-1209b73e>aggregate library</em> contains definitions of operators and combinators most of which are applicable
          to all of the three <em data-v-1209b73e>aggregate</em> datatypes such as
          <em data-v-1209b73e>list</em>s, <em data-v-1209b73e>string</em>s and <em data-v-1209b73e>set</em>s. (Note that the next library seqlib.joy is specifically
          for sequence datatypes such as lists and strings.)
        <p data-v-1209b73e>The agglib.joy library contains definitions of several unary and binary operators for building special cases
          of these datatypes, and for accessing parts of these datatypes. There are also some ("dipped") variants
          which operate not on the top of the stack but one below. The combinators in this library are mainly for
          traversing these datatypes. (At the end there are a few definitions of statistical operators, but in the
          future these might be moved to a more extensive statistics library.)
        <dt data-v-1209b73e><a href="joy/seqlib.joy" data-v-1209b73e>seqlib.joy</a><br data-v-1209b73e><dd data-v-1209b73e>
        This <em data-v-1209b73e>sequence library></em> contains definitions of functions specific to the <em data-v-1209b73e>sequence datatypes</em>      such as lists and strings. When this library is loaded, it ensures that the <kbd data-v-1209b73e>agglib.joy</kbd> library
        will also be loaded.
        <p data-v-1209b73e>This library contains definitions of functions for reversing lists or strings, for flattening lists of sequences,
          for generating lists of various subsquences of sequences, sorting and merging of sequences and inserting
          into and deleting from sequences. (At the end there are a few definitions of functions applicable to <em data-v-1209b73e>tree</em>s
          or recursive lists, but in the future these might be moved to a more extensive tree library.)
        <dt data-v-1209b73e><a href="joy/numlib.joy" data-v-1209b73e>numlib.joy</a><br data-v-1209b73e><dd data-v-1209b73e>This <em data-v-1209b73e>numerical library</em> contains definitions of functions and combinators for numerical work on integers
        and floating numbers. some convenience predicates such as positive, negative, odd, even and prime, some standard
        functions such as factorial, fibonacchi, greatest common divisor and temperature conversion. Also included
        are methods for finding roots of quadratic equations and Newton's method for finding solutions of equations
        in one variable.
      <dt data-v-1209b73e><a href="joy/symlib.joy" data-v-1209b73e>symlib.joy</a><br data-v-1209b73e><dd data-v-1209b73e>This <em data-v-1209b73e>symbolic library</em> is for purely symbolic manipulation of various notations. Currently all the
        definitions are for non-specific translations from one notation to another.
        <br data-v-1209b73e>There is a
        <a href="joy/symtst.joy" data-v-1209b73e>symtst.joy</a> test file and its
        <a href="joy/symtst.out" data-v-1209b73e>symtst.out</a> output. This library is currently used by the special libraries
        <kbd data-v-1209b73e>grmlib.joy</kbd> and <kbd data-v-1209b73e>plglib.joy</kbd>, see below.
      </dl><p data-v-1209b73e>
      The followiing <em data-v-1209b73e>special libraries</em> contain definitions of operators and combinators that are very specific
      to a particular field or problem.
    <dl data-v-1209b73e><dt data-v-1209b73e><a href="joy/mtrlib.joy" data-v-1209b73e>mtrlib.joy</a><br data-v-1209b73e><dd data-v-1209b73e>A library for <em data-v-1209b73e>matrices</em> and <em data-v-1209b73e>vector</em> manipulation. The vectors are implemented as Joy lists,
        the matrices as lists of lists. Either may contain numeric or non-numeric elements.
        <br data-v-1209b73e>There is a
        <a href="joy/mtrtst.joy" data-v-1209b73e>mtrtst.joy</a> testfile and its
        <a href="joy/mtrtst.out" data-v-1209b73e>mtrtst.out</a> output.
      <dt data-v-1209b73e><a href="joy/tutlib.joy" data-v-1209b73e>tutlib.joy</a><br data-v-1209b73e><dd data-v-1209b73e>A library for writing <em data-v-1209b73e>interactive sessions</em> such as <em data-v-1209b73e>tutorials</em>.
        <br data-v-1209b73e>Currently there is only one such tutorial (for Joy):
        <a href="joy/joytut.joy" data-v-1209b73e>joytut.joy</a><br data-v-1209b73e> There is a
        <a href="joy/joytut.com" data-v-1209b73e>joytut.com</a> (pseudo) input and its
        <a href="joy/joytut.out" data-v-1209b73e>joytut.out</a> output.
      <dt data-v-1209b73e><a href="joy/lazlib.joy" data-v-1209b73e>lazlib.joy</a><br data-v-1209b73e><dd data-v-1209b73e>A <em data-v-1209b73e>"lazy list" library</em>, for unevaluated infinite or finite lists that will only be evaluated as needed.
        <br data-v-1209b73e> There is a
        <a href="joy/laztst.joy" data-v-1209b73e>laztst.joy</a> test file and its
        <a href="joy/laztst.out" data-v-1209b73e>laztst.out</a> output.
      <dt data-v-1209b73e><a href="joy/lsplib.joy" data-v-1209b73e>lsplib.joy</a> and
        <a href="joy/lsplib.lsp" data-v-1209b73e>lsplib.lsp</a><br data-v-1209b73e><dd data-v-1209b73e>A small (eval-apply) Lisp interpreter in Joy, and a small library for this version of Lisp.
        <br data-v-1209b73e> There is a
        <a href="joy/lsptst.joy" data-v-1209b73e>lsptst.joy</a> driver for the
        <a href="joy/lsptst.lsp" data-v-1209b73e>lsptst.lsp</a> lisp input and its
        <a href="joy/lsptst.out" data-v-1209b73e>lsptst.out</a> output.
      <dt data-v-1209b73e><a href="joy/plglib.joy" data-v-1209b73e>plglib.joy</a><br data-v-1209b73e><dd data-v-1209b73e>A library for <em data-v-1209b73e>propositional logic</em> using semantic tableaux for determining whether a formula is a tautology
        (or for determining satisfiability). This library depends on (and loads) the
        <em data-v-1209b73e>symbolic library</em><kbd data-v-1209b73e>symlib.joy<kbd data-v-1209b73e>.<br data-v-1209b73e>
        There is a
        <a href="joy/plgtst.joy" data-v-1209b73e>plgtst.joy</a>
        file of test input and its
        <a href="joy/plgtst.out" data-v-1209b73e>plgtst.out</a>
        output.
        </kbd></kbd><dt data-v-1209b73e><a href="joy/grmlib.joy" data-v-1209b73e>grmlib.joy</a><br data-v-1209b73e><dd data-v-1209b73e>A <em data-v-1209b73e>grammar library</em> for regular expressions and context free grammars. Both parsing and generating are
        supported. This library depends on (and loads) the
        <em data-v-1209b73e>symbolic library</em><kbd data-v-1209b73e>symlib.joy<kbd data-v-1209b73e>.<br data-v-1209b73e>
        There is a
        <a href="joy/grmtst.joy" data-v-1209b73e>grmtst.joy</a>
        test input and its
        <a href="joy/grmtst.out" data-v-1209b73e>grmtst.out</a>
        output.
        </kbd></kbd></dl><p data-v-1209b73e>
      The file
      <a href="joy/allhelp.html" data-v-1209b73e>allhelp.html</a> is the output of the <em data-v-1209b73e>help</em> command when all libraries have
      been loaded. It gives some impression of the size of the Joy implementation so far.
    <p data-v-1209b73e>
      The file
      <a href="joy/joylibs.tar.gz" data-v-1209b73e>joylibs.tar.gz</a> is a gzipped tar file of all *.joy libraries, input test files
      and output files. This file is automatically updated when there is any change to the Joy distribution.
    <p data-v-1209b73e><p data-v-1209b73e>
      The following libraries are external to the main Joy web pages. They are part of the "files" folder for the "concatenative"
      yahoo mailing group. To access them you need to join the group.
    <dl data-v-1209b73e><dt data-v-1209b73e><a href="http://www.groups.yahoo.com/group/concatenative/files/rabbit" data-v-1209b73e>
        rabbit</a><br data-v-1209b73e><dd data-v-1209b73e>A Joy to HTML translation library by Heiko Kuhrt, it contains an extensive Joy manual in HTML format.
      <dt data-v-1209b73e><a href="http://www.groups.yahoo.com/group/concatenative/files/mandel.html" data-v-1209b73e>
        mandel</a><br data-v-1209b73e><dd data-v-1209b73e>Several Mandelbrot programs in Joy by Nick Forde et. al. collected by Nick Forde.
      </dl><a name="TOC_9" data-v-1209b73e><h2 data-v-1209b73e><strong data-v-1209b73e>Miscellaneous features</strong></h2></a><p data-v-1209b73e>
      Joy has a <kbd data-v-1209b73e>help</kbd> command to remind users of the names of currently defined symbols. The command does
      not expect any parameters on the stack, and it does not affect the stack. The effect is to write all user defined
      symbols and all inbuilt symbols to the output which is normally the screen. The list begins with the most recently
      defined symbols, typically those specially defined just for the current run, then the library symbols and finally
      the inbuilt symbols. The <kbd data-v-1209b73e>help</kbd> command is just a factor:
      <br data-v-1209b73e><pre data-v-1209b73e>        help
  </pre><p data-v-1209b73e>
      More details about a particular symbol can be obtained by the <kbd data-v-1209b73e>helpdetail</kbd> operator. It expects a
      list of atoms on the stack and gives a short message for each symbol. If the symbol is defined, then the message
      consists of the <em data-v-1209b73e>definition</em> for the symbol. If the symbols is inbuilt, then the message consists of
      a brief description of its usage.
      <br data-v-1209b73e><pre data-v-1209b73e>        [ swap step product ]  helpdetail.
  </pre>
    asks for detailed help about the inbuilt operator <kbd data-v-1209b73e>swap</kbd>, the inbuilt combinator <kbd data-v-1209b73e>step</kbd>  and the defined operator <kbd data-v-1209b73e>product</kbd>. The message is
    <br data-v-1209b73e><pre data-v-1209b73e>swap   :   X Y  ->  Y X
    Interchanges X and Y on top of the stack.
  step   :   A [P]  ->  ...
    Pushing successive members of aggregate A onto stack, executes P for each.
  product  ==
    1  swap  [*]  step
  </pre>
    For the inbuilt primitives the <kbd data-v-1209b73e>-></kbd> arrow indicates the type of the symbol. To the left of the
    arrow are the required parameters in ascending order. To the right of the arrow are the results, where possible.
    If that cannot be specified in this simple notation, a dieresis <kbd data-v-1209b73e>...</kbd> is used.
    <p data-v-1209b73e>
      As described in section 2, Joy already allows escapes to the operating system at the level of input lines. Another
      such escape is at the level of Joy operators. The <kbd data-v-1209b73e>system</kbd> operator expects a string as a parameter
      and passes that to the operating system. A typical use might be:
      <br data-v-1209b73e><pre data-v-1209b73e>        "directory"  system
  </pre>
    The string parameter does not have to be pushed as a literal, it can equally well have been constructed.
    For example, the <kbd data-v-1209b73e>system</kbd> operator can be used as in the following. My personal <kbd data-v-1209b73e>USRLIB.JOY</kbd>  contains the <em data-v-1209b73e>definition</em><br data-v-1209b73e><pre data-v-1209b73e>        editor  ==  "EDIT/TECO "
  </pre>
    The general <kbd data-v-1209b73e>STDLIB.JOY</kbd> file contains
    <br data-v-1209b73e><pre data-v-1209b73e>        edit  ==  dup editor swoncat system include
  </pre>
    Then, to edit and immediately read in a file, say <kbd data-v-1209b73e>TEST.JOY</kbd>, I can use the Joy command
    <br data-v-1209b73e><pre data-v-1209b73e>        "TEST.JOY"  edit
  </pre>
    This calls the <kbd data-v-1209b73e>edit</kbd> operator to make a duplicate of the string <kbd data-v-1209b73e>"TEST.JOY"</kbd>. One copy
    is concatenated with the <kbd data-v-1209b73e>editor</kbd> string, and the result passed on to the system. That will call my
    favourite editor to edit the file. When the editing is finished, the original string <kbd data-v-1209b73e>"TEST.JOY"</kbd> is
    used to include the edited file. Note that other users might put a different name of their editor in their own
    <kbd data-v-1209b73e>USRLIB.JOY</kbd>. For example, Unix users would probably put
    <br data-v-1209b73e><pre data-v-1209b73e>        editor  ==  "vi "
  </pre>
    The <em data-v-1209b73e>definition</em> of <kbd data-v-1209b73e>edit</kbd> in <kbd data-v-1209b73e>STDLIB.JOY</kbd> remains unchanged.
  </kb></article></div></main><footer data-v-c785faa8><p data-v-c785faa8><a href="https://github.com/joy-language/joy-lang.org" data-v-c785faa8>GitHub</a></footer></div></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{},{}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.10669f42b2e188f55eb1.js"></script><script defer src="/_nuxt/layouts/default.29c0e08e13310e3682fc.js"></script><script defer src="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js"></script><script defer src="/_nuxt/pages/papers-on-joy/the-current-implementation.e033c23017443bc35c24.js"></script><script defer src="/_nuxt/vendor.230cb916d1973aa790f3.js"></script><script defer src="/_nuxt/app.0a856c7cf6fb3e349fa2.js"></script>
  

