<!DOCTYPE html>
<html data-n-head="" data-n-head-ssr>
  <head>
    <meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Joy Programming Language" name="description" data-hid="description"><title data-n-head="true">Joy language</title><link href="https://fonts.googleapis.com/css?family=Fira+Sans:200,500|Roboto:400|Roboto+Mono:400" rel="stylesheet" data-n-head="true"><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/favicon.ico?" rel="shortcut icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.10669f42b2e188f55eb1.js" rel="preload" as="script"><link href="/_nuxt/vendor.230cb916d1973aa790f3.js" rel="preload" as="script"><link href="/_nuxt/app.0a856c7cf6fb3e349fa2.js" rel="preload" as="script"><link href="/_nuxt/layouts/default.29c0e08e13310e3682fc.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/design-of-matrix-multiplication-programs.8e00ebe2e6e430523681.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/survey-of-reproducing-programs.ed8409adcfb2bdec6eeb.js" rel="prefetch"><link href="/_nuxt/pages/libraries-and-c-sources.d2ffa370ff989df9d359.js" rel="prefetch"><link href="/_nuxt/pages/index.73b5e04f9a3fcda5b5fe.js" rel="prefetch"><link href="/_nuxt/pages/about.a3431c5910b96e7d0298.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-algebra-of-joy.7f385b55e84045676f24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-annoying-quadratic-formula.a3d9ef30d4f74df89dfd.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/church-arithmetic-and-church-logic-with-brent-kirby.e11588a1a251690d41af.js" rel="prefetch"><link href="/_nuxt/pages/rationale-for-joy.3e067852511f512169f0.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/tutorial-on-joy.9a4df70c3d63708c2b23.js" rel="prefetch"><link href="/_nuxt/pages/overview-of-joy.8733ad0cbce5d065d604.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/miscellaneous-miniature-implementations-of-joy.417498df53623dd27f3a.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/fast-small-truth-tables.9b1b75741215fa7afac3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/programming-in-joy.d4bc3bc57b9855085dc1.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/imperative-thinking-for-joy-programs.223ec58c271bc7112421.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-a-joy-interpreter-written-in-joy.eaa748fa0ea2130e1164.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/joy-compared-with-other-functional-languages.e9b1e34a3b81758a64f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/recursion-theory-and-joy.7d268252a6e6c71fa9f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/nested-recursion-and-a-new-recursion-combinator.d40eac9bf6ad0e5cac92.js" rel="prefetch"><link href="/_nuxt/pages/faq.9ffdbd52d27b2df75f94.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/mathematical-foundations-of-joy.4f0b584e560cf803bb24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/floy-a-flat-concatenative-subset-of-joy.9162d7b51e29e1b5b1b9.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/html-manual.e3473b0453170639a088.js" rel="prefetch"><link href="/_nuxt/pages/faq-part-2.9630745e3aaebc47633f.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/lazy-lists-as-reproducing-programs.9516d2d5134cfed90ce3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-current-implementation.e033c23017443bc35c24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/a-rewriting-system-for-joy.4157d6f1ef190fb675ea.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/atomic-programs-of-joy.f2cb1414ae2b6ed9401e.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/prospectus-for-john-cowans-joy1.cb4661329c1ed2df6752.js" rel="prefetch"><style data-vue-ssr-id="d505b096:0">html{font-family:Roboto,Arial,sans-serif;margin:0;font-weight:400;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box}body{margin:0;height:100%}:after,:before,:not(pre){-webkit-box-sizing:border-box;box-sizing:border-box;margin:0}.wrapper{min-height:calc(100vh - 102px)}a{color:#3273dc;text-decoration:none}a:hover{text-decoration:underline}</style><style data-vue-ssr-id="6cc65792:0">nav[data-v-251e63b6]{background-color:#000}ul[data-v-251e63b6]{list-style-type:none;padding:0;margin:0}li[data-v-251e63b6]{-webkit-transition:all .2s ease-out;transition:all .2s ease-out;display:inline-block;padding:0;cursor:pointer}li[data-v-251e63b6]:hover{-webkit-transform:scale(1.04);transform:scale(1.04);background-color:#fff;color:#000}li a[data-v-251e63b6]{display:block;padding:15px 25px;text-decoration:none;color:#fff;text-align:center}li:hover a[data-v-251e63b6]{color:#000}.nuxt-link-exact-active[data-v-251e63b6]{text-decoration:overline}</style><style data-vue-ssr-id="23d2604d:0">h1[data-v-7e83a563]{font-size:26px}.lists[data-v-7e83a563]{margin-top:37px;padding-left:12vw;padding-right:12vw}.top-list-item[data-v-7e83a563]{margin-top:11px}li[data-v-7e83a563]{line-height:39px}.no-style-litem[data-v-7e83a563]{list-style-type:none}ul[data-v-7e83a563]{list-style-type:circle}h6[data-v-7e83a563]{font-size:17px}p[data-v-7e83a563]{margin-top:8px;line-height:24px;font-size:16px}</style><style data-vue-ssr-id="12094266:0">p[data-v-7837928d]{margin-top:16px;margin-bottom:16px}hr[data-v-7837928d]{margin-bottom:16px}pre[data-v-7837928d]{margin-bottom:auto}code[data-v-7837928d],kbd[data-v-7837928d],pre[data-v-7837928d]{font-family:Roboto Mono,monospace}</style><style data-vue-ssr-id="ca9343dc:0">footer[data-v-c785faa8]{padding:11px 20px 0;height:52px}p[data-v-c785faa8]{-webkit-transition:all .1s ease-in;transition:all .1s ease-in;font-size:15px;float:right;margin:0 16px}a[data-v-c785faa8]{color:#000;text-decoration:none}p[data-v-c785faa8]:hover{-webkit-transform:scale(.94);transform:scale(.94);color:#000;-webkit-text-decoration:#3273dc overline;text-decoration:#3273dc overline}</style>
  </head>
  <body data-n-head="">
    <div id="__nuxt" data-server-rendered="true"><div id="__layout"><div class="container" lang="en"><nav data-v-251e63b6 role="navigation"><ul data-v-251e63b6><li data-v-251e63b6><a href="/" data-v-251e63b6 class="nuxt-link-active">Home</a><li data-v-251e63b6><a href="/papers-on-joy" data-v-251e63b6 class="nuxt-link-active">Papers</a><li data-v-251e63b6><a href="/libraries-and-c-sources" data-v-251e63b6>Libraries/C sources</a><li data-v-251e63b6><a href="/about" data-v-251e63b6>About</a></ul></nav><main class="lists" data-v-7e83a563><div data-v-7e83a563><article data-v-7837928d data-v-7e83a563 data-v-7e83a563><p data-v-7837928d>
    NOTE: Some of the definitions in here have been included in the matrix/vector library,
    but under quite different systematic names.
  <h1 data-v-7837928d>1. A numerical matrix addition operator</h1><p data-v-7837928d>
    A matrix is a rectangular collection of items, most often numbers. Two matrices M1
    and M2 can be added just in case both have the same number of rows and both have
    the same number of columns. In that case their sum M3 has that same number of row
    and that same number of columns. Each element in the result matrix M3 is just the
    arithmetic sum of the corresponding elements of the other two matrices M1 and M2.
    Two matrices M1 and M2 can be multiplied just in case M1 has as many columns as
    M2 has rows. In that case their product M3 has as many rows as M1 and as many columns
    as M2. In detail, if M1 has I rows and J columns, and M2 has J rows and K columns,
    then the element in row i and column k of M3 is computed by multiplying the J pairs
    of corresponding elements of row i of M1 and column k of M2 and then adding the
    products.
  <p data-v-7837928d>
    In Joy a matrix of I rows and J columns can be represented as a list of I lists each
    of J elements. The remainder of this note deals with matrix addition and matrix
    multiplication in Joy. The first sections deal with such operators just for numerical
    matrices. In Joy0 this means just integer, in Joy1 this means integer or float.
    The sections which then follow deal with general addition and multiplication combinators
    suitable for matrices built from other datatypes.
  <p data-v-7837928d>
    How can we write a program <em data-v-7837928d>num-matadd</em> to add two matrices of numbers giving
    a third? We want
  <pre data-v-7837928d>M1  M2  num-matadd   ==>   M3
  </pre>
  As a first step consider element-wise addition of two vectors of the same
  length, represented in Joy just as a list. The result vector has that same length.
  Some languages have a zipwith combinator, but in Joy it is just called map2. Whereas
  map takes one list parameter, map2 takes two. Both combinators also take a quotation
  parameter which determines how the elements of the parameter list(s) are to be used
  to form the elements of the result list. For vector addition the elements have to
  be added, so the required program could be defined by
  <pre data-v-7837928d>num-vectadd   ==   [+]  map2
  </pre>
  Now to add two matrices of numbers we just have to use map2 again to add the
  rows as vectors:
  <pre data-v-7837928d>M1  M2  [num-vectadd]  map2   ==>   M3
  </pre>
  Hence the following definition:
  <br data-v-7837928d><pre data-v-7837928d>num-matadd   ==   [num-vectadd]  map2
  </pre>
  For later purposes it is useful to "inline" the definition of num-vectadd,
  giving
  <pre data-v-7837928d>num-matadd   ==   [[+] map2]  map2
  </pre><p data-v-7837928d><h1 data-v-7837928d>2. A numerical matrix multiplication operator</h1><p data-v-7837928d>
    How can we write a program <em data-v-7837928d>matmul</em> to multiply two matrices to give a third?
    This is a little harder. We want:
  <pre data-v-7837928d>M1  M2  num-matmull   ==>   M3
  </pre>
  Notice that M3 has exactly as many rows as M1, and hence the Joy lists M1
  and M3 are of the same length. Each of the I component lists of M1 is mapped to a
  corresponding list of M3. The details of the mapping of course also depend on M2.
  So the mapping function will make use of M2. As a first step we may write
  <pre data-v-7837928d>M1  [M2 P]  map   ==>   M3
  </pre>
  where P is to be determined later. Even then, M2 is not really supposed to
  be part of the program, because M2 will already be on the stack. But it is easy enough
  to take it off the stack and put it in front of P:
  <pre data-v-7837928d>M1  M2  [P]  cons  map   ==>   M3
  </pre>
  P must be program which encounters M2 on the stack and below that a list of
  J numbers left behind from the map. P must use the K columns of M2 to produce a list
  of K numbers for M3. This looks like another case of map, with Q to be determined
  later: P == [Q] map. By substitution we have
  <pre data-v-7837928d>M1  M2  [[Q] map]  cons  map   ==>  M3
  </pre>
  Two things are not quite right. Firstly, M2 is a list of J rows of K numbers,
  but the new map just introduced needs a list of K columns of J numbers. So it needs
  the transpose of M2:
  <pre data-v-7837928d>M1  M2  transpose  [[Q] map]  cons  map   ==>  M3
  </pre>
  Secondly, the new map will consume each of the K columns from the transposed
  M2 to produce a list of K numbers for M3, but it will also leave behind the list
  of J numbers from M1 which the earlier, outer map left behind. This list of J numbers
  needs to be removed after the new map has finished. But the list to be removed is
  not on top of the stack but just below. So it must be removed by popd, which could
  be defined by popd == [pop] dip.
  <pre data-v-7837928d>M1  M2  transpose  [[Q] map popd]  cons  map   ==>  M3
  </pre>
  Program Q will find two lists of length J on the stack: a row list from M1
  and a column list from M2. It must multiply corresponding numbers from the two lists
  and then add their products. This operattion is useful elsewhere, it is called scalar
  product. One way to compute it is to produce a list of products first, and then add
  the elements of that list. The list of products is similar to vector addition defined
  earlier, but it uses multiplication. So the list of products is produced by [*] map2.
  The resulting list can then be added with the sum operator. The sum operator works
  like this: starting with 0, add to that all the elements of the list. This is called
  "folding" the list, using the binary + operator. These are the definitions:
  <pre data-v-7837928d>sum   ==   0  [+]  fold
  scalar-product   ==   [*] map  sum
  </pre>
  So the entire matrix multiplication problem now is simply
  <br data-v-7837928d><pre data-v-7837928d>M1  M2  transpose  [[scalar-product] map popd]  cons  map   ==>   M3
  </pre>
  So we may define:
  <br data-v-7837928d><pre data-v-7837928d>num-matmul   ==   transpose  [[scalar-product] map popd]  cons  map
  </pre>
  For later purposes it is again useful to inline scalar-product and then sum.
  The new definition is here written over several lines for comparison with later variations:
  <pre data-v-7837928d>num-matmul   ==   transpose
                    [[[*] map2 0 [+] fold]  map  popd]  cons
                    map
  </pre><h1 data-v-7837928d>3. General matrix combinators</h1><p data-v-7837928d>
    The addition and multiplication operators of the preceding sections only work for
    numerical matrices. But the only four parts in the definitions that depend on that
    are [+] inside num-matadd, and [*], 0 and [+] inside num-matmul. However, matrices
    could have other kinds of things as elements. For example, one might have logical
    matrices in which the elements are the truth values true and false. In that case
    one would want two further definitions with just the four parts replaced by [or],
    [and], false and [or]. Or one might want two operators for different datatypes
    again. In fact, for matrix addition and multiplication the three matrices M1 M2
    M3 might have up to three different kinds of elements. It would be useful to have
    general matrix manipulation combinator that abstract from details.
  <p data-v-7837928d>
    How can we write a general matrix addition combinator? It should satisfy
    <br data-v-7837928d><pre data-v-7837928d>M1  M2  [+]  gen-matadd   ==>  M3
  </pre>
  which behaves just like the numerical addition operator, and with [or] instead
  of [+] behaves like a logical addition operator? In either case it has to transform
  the quotation [+] into [[+] map2] map2, or the quotation [or] into [[or] map2] map2.
  This is easy enough,in the numerical case it is
  <pre data-v-7837928d>M1  M2  [+]  [map2]  cons  map2   ==>   M3
  </pre>
  So we may define a general matrix addition combinator
  <em data-v-7837928d>gen-matadd</em> by
  <br data-v-7837928d><pre data-v-7837928d>gen-matadd   ==   [map2]  cons  map2
  </pre>
  Now matrix addition for numbers or for truth values can be defined as
  <br data-v-7837928d><pre data-v-7837928d>num-matadd   ==    [+]  gen-matadd
  log-matadd   ==   [or]  gen-matadd
  </pre>
  In Joy truth values and sets are treated in a very similar way, and collectively
  they are called Boolean values. For truth values the or-operator produces the disjunction,
  and for sets the or-operator produces the union. So the above logical matrix addition
  operator would work equally well for matrices in which the element are sets. Because
  of that it is better to call it a Boolean matrix addition operator, defined as:
  <pre data-v-7837928d>bool-matadd   ==   [or]  gen-matadd
  </pre>
  As always, instead of actually having the definition one could just as easily
  use the right hand side directly.
  <p data-v-7837928d>
    A general matrix multiplication combinator is a little harder. Let Q be any program
    for combining a row from M1 and a column from M2 to form an element for M3. In
    the nnumerical case the Q would have been the scalar product program. Then a combinator
    <b data-v-7837928d>gen-matmul</b> would be used like this:
  <pre data-v-7837928d>M1  M2  [Q]  gen-matmul   ==>   M3
  </pre>
  Now M2 needs to be transposed as before, but it is below the [Q], so gen-matmul
  must use dip:
  <pre data-v-7837928d>M1  M2  [Q]  [transpose]  dip  S   ==>   M3
  </pre>
  S must construct [[Q] map popd] and then use that with T:
  <br data-v-7837928d><pre data-v-7837928d>M1  M2  [Q]  [transpose]  dip  [map popd]  cons  T   ==>   M3
  </pre>
  But T is just as before, T == cons map:
  <br data-v-7837928d><pre data-v-7837928d>M1  M2  [Q]  [transpose]  dip  [map popd]  cons  cons map   ==>   M3
  </pre>
  So we can define the general combinator
  <br data-v-7837928d><pre data-v-7837928d>gen-matmul   ==   [transpose]  dip
                    [map popd]  cons  cons
                    map
  </pre>
  Now the multiplication of numerical and logical matrices can be defined just
  in terms of the corresponding scalar products:
  <pre data-v-7837928d>num-matmul   ==   [  [*] map2       0 [+]  fold]  gen-matmul
  log-matmul   ==   [[and] map2   false [or] fold]  gen-matmul
  </pre>
  Compared with the earlier, explicit version of num-matmull, this version must
  execute one extra dip and one extra cons in gen-matmul. But this is negligible compared
  with the amount of real work done later by either version, especially the I*J*K numerical
  multiplications (in [*]) and numerical additions (in [+]) required for any numerical
  matrix multiplication program. Exactly the same is true for the logical version.
  <h1 data-v-7837928d>4. A cleaner multiplication combinator</h1><p data-v-7837928d>
    There is really nothing one could do to improve the addition combinator gen-matadd.
    But as the two examples of applications of the gen-matmul combinator show, they
    will all have to use the map2 and the fold combinator. It would be cleaner to have
    the map2 and the fold as part of the general combinator, so that users only have
    to include what is specific to the datatype of the matrices. The specific parts
    are a binary operator [B1] (which is [*] or [and] in the examples), and also a
    zero element Z2 and a binary operator [B2] (which are 0 and [+] or false and [or]
    in the examples). The value Z2 has to be the zero element for the binary operation
    in [B2]. As gen-matmul stands, one has to provide one quotation parameter, in the
    form
  <pre data-v-7837928d>[ [B1] map2  Z2 [B2] fold ]  gen-matmul
  </pre>
  It would be cleaner if one could provide just what is really needed:
  <br data-v-7837928d><pre data-v-7837928d>[B1]  Z2 [B2]  gen-matmul
  </pre>
  The required change to gen-matmul is quite simple, all that is needed is a
  preliminary program P which changes the three simple parameters to the one complicated
  parameter:
  <pre data-v-7837928d>[B1]  Z2 [B2]   P   ==>   [ [B1] map2  Z2 [B2] fold ]
  </pre>
  The preliminary program can first use [fold] cons cons, and this will at least
  change Z2 [B2] into [Z2 [B2] fold]. Following that some other changes C are needed:
  <pre data-v-7837928d>[B1]  Z2 [B2]  [fold] cons cons  C   ==>   [ [B1] map2  Z2 [B2] fold ]
  </pre>
  The first parameter [B1] has to be changed to [[B1] map2], but this has to
  be done with dip just below the last constructed quotation. It is done by [[map2]
  cons] dip:
  <pre data-v-7837928d>[B1] Z2 [B2] [fold] cons cons [[map2] cons] dip F ==> [ [B1] map2 Z2 [B2] fold ]
  </pre>
  where the finalisation F simply has to concatenate the two previous constructions:
  <pre data-v-7837928d>[B1] Z2 [B2] [fold] cons cons [[map2] cons] dip concat
                        ==>    [B1] map2 Z2 [B2] fold ]
  </pre>
  The above program becomes a new first line in the otherwise unchanged program
  for the gen-matmul combinator:
  <pre data-v-7837928d>gen-matmul   ==   [fold] cons cons [[map2] cons] dip concat
                    [transpose] dip
                    [map popd] cons cons
                    map
  </pre>
  Now the multiplication operators for numerical and logical matrices can be
  given by the more perspicuous definitions
  <pre data-v-7837928d>num-matmul   ==   [*]  0 [+]  gen-matmul
  log-matmul   ==   [and]  false [or]  gen-matmul
  </pre><h1 data-v-7837928d>5. An even more general multiplication combinator</h1><p data-v-7837928d>
    The two definitions just above will be suitable for many purposes. Like all definitions
    so far, they even work for degenerate matrices with no rows and no columns. Such
    degenerate matrices are of course represented as [], and their arithmetic or logical
    product is again []. For other datatypes it is often easy to give the appropriate
    definition. For example one might need an operation for the multiplication of matrices
    in which the elements are sets. In Joy set intersection is just and, wheras set
    union is just or. The zero element for union is {}. So a suitable definition is
  <pre data-v-7837928d>set-matmul   ==   [and]  {} [or]  gen-matmul
  </pre>
  Comparing logical matrix multiplication and set matrix multiplication, the
  two are almost identical except for the different zero elements false and {}. This
  difference has the consequence that whereas the and-operator and the or-operator
  work equally for logical and set operands, we cannot define a single matrix multiplication
  operator that works equally for logical and set operations. That would be unfortunate,
  although one could first do a very simple test on the first element in the first
  row of M2 to determine whether it is a truth value or a set.
  <p data-v-7837928d>
    But there are other cases where there could not be such a simple device. Consider
    the problem of multiplying second order matrices in which the elements themselves
    are numerical matrices of compatible rows and columns but where the number of rows
    and columns are not known in advance. This means that the zero element for the
    addition of the submatrices is also not known in advance, and hence in the definition
    below the ??? is not known in advance.
  <pre data-v-7837928d>num-matmul2   ==   [num-matmul]  ???  [num-matadd]  gen-matmul
  </pre>
  What is particularly annoying is that ??? is the only part that needs to be
  known for the definition to work.
  <p data-v-7837928d>
    There would be other cases in which the same problem arises. They will all involve
    the datatype of the Z2 zero element for the binary [B2] operation, where that datatype
    is of indeterminate size, shape or structure. There are no such restrictions on
    [B1] and [B2]. It is true that a suitable Z2 can always be constructed from two
    sample elements from M1 and M2 by applying the [B1] operation, and then making
    a suitable Z2 from that. All this would have to be encoded in a very complex version
    of gen-matmul.
  <p data-v-7837928d>
    But there is a simpler solution. Consider again the versions of the numerical matrix
    multiplication operators of sections 1 and 2. They required, in some way or another,
    a program to compute a scalar product:
  <pre data-v-7837928d>[ [*] map2  0 [+] fold ]
  </pre>
  In all but the degenerate case the list produced by map2 will not be null.
  So in the normal case the list can be taken apart with unswons. That will leave the
  first element of that list, followed by the rest of the list. The rest can now be
  folded by using not 0 as the initial value of the accumulator, but the first element
  of the list. In other words, the above program fragment could be replaced by
  <pre data-v-7837928d>[ [*] map2  unswons [+] fold ]
  </pre>
  So it would be possible to have just [*] and [+] as the parameters to the
  general matrix multiplication combinator, and let the combinator supply map2, unswons
  and fold. This would imply changing the first line of the last version by a program
  P which does the conversion
  <pre data-v-7837928d>[B1]  [B2]  P   ==>   [ B1] map2  unswons [B2] fold ]

  The conversion is quite similar to the earlier one.
  But now only one parameter, [B1] has to be consed into [fold],
  then [B1] has to be consed, through dip, into [map2 unswons],
  and then these results concatenated.
  So the required program P is
  <pre data-v-7837928d>[fold] cons  [[map2 unswons] cons] dip  concat
  </pre> This program replaces the first line of the previous definition of the general
  matrix multiplication combinator:
  <pre data-v-7837928d>gen-matmul   ==   [fold] cons [[map2 unswons] cons] dip concat
                    [transpose] dip
                    [map popd] cons cons
                    map
  </pre> Now the multiplication operators can be defined quite simply. The first is
  for numerical matrices. In Joy0 this means just integer, in Joy1 this means integer
  or float. The second is for Boolean matrices, of either truth values or sets. The
  third is for second order matrices of numerical matrices. The fourth is for second
  order matrices of Boolean matrices.
  <pre data-v-7837928d>num-matmul     ==   [*]  [+]  gen-matmul
  bool-matmul    ==   [and]  [or]  gen-matmul
  num-matmul2    ==   [num-matmul]  [num-matadd]  gen-matmul
  bool-matmul2   ==   [bool-matmul]  [bool-matadd]  gen-matmul
  </pre> It is easy to see how multiplication of third order matrices would be defined.
  But it is doubtful whether even second order matrices arise.

  <h1 data-v-7837928d>6. Polymorphic matrix operators</h1><p data-v-7837928d>
    It could be useful to have a single matrix mutltiplication operator which can handle
    at least numerical and Boolean matrices. To do so, it must inspect the type of
    the elements. If they are numerical it must behave like num-matmul above, and if
    the are Boolean it must behave like bool-matmul above. If the type is neither,
    an error must be reported and the execution aborted. As a first draft, the following
    is useful:
  <pre data-v-7837928d>                dup first first
                  (* branching on the type,
                     push [*] and [+], or push [and] and [or],
                     or report error and abort *)
                  gen-matmul
  </pre> The branching looks like a three-way branch which could be handled by two
  ifte combinators, one inside another, or by a single cond combinator. But in Joy1
  the numerical and the Boolean cases both split into two: the numerical types are
  integer and and float, and the Boolean cases are logical and set. (In Joy0 the only
  numerical type is integer.) So each of the two correct situations can arise in two
  ways: when the element type is integer or float, and when the element type is logical
  or set. The predicates numerical and boolean test for that. The cond combinator takes
  the two normal cases and as its default the error condition.
  <pre data-v-7837928d>                [ [ [numerical]   pop   [*] [+]         ]
                    [ [boolean]     pop [and] [or]        ]
                    [ "unknown operands\n" putchars abort ] ]
                  cond
  </pre> Alternatively, the branching could be based on those four cases, with a fifth,
  default case for the error situation. Since this branching is on the basis of types,
  the opcase operator is most suitable.
  <pre data-v-7837928d>                [ [ 0     pop [*]   [+]               ]
                    [ 0.0   pop [*]   [+]               ]
                    [ true  pop [and] [or]              ]
                    [ {}    pop [and] [or]              ]
                    [ "unknown operand\n" putchars abort] ]
                  opcase
  </pre> It may be a matter of taste whether the version with the cond combinator or
  the version with the opcase combinator is preferable. Either of the two could be
  used as the insertion in the earlier skeleton.
  <p data-v-7837928d>
    But before that, it is useful to remember at this point that the gen-matmul combinator
    will fail for degenerate matrices. But that is easily fixed right here: the product
    of two degenerate matrices is just the degenerate matrix []. So the earlier skeleton
    should be wrapped inside an ifte combinator: if the top matrix is degenerate, pop
    if off and return the other matrix (which should be degenerate, too). Otherwise,
    proceed with the ordinary version.
  <pre data-v-7837928d>poly-matmul   ==
      [ null ]
      [ pop ] 
      [     dup first first
            [ [ [numerical] pop [*]   [+]              ]
              [ [boolean]   pop [and] [or]             ]
              [ "unknown operand type\n" putchars abort] ]
            cond
            gen-matmul ]
      ifte
  </pre> This definition of the polymorphic matrix multiplication operator is typical
  of how generality can be achieved in Joy without the use of object oriented concepts.
  The extra computation needed for such polymorphism might seem a waste, but it is
  essential for writing useful general libraries.
  <p data-v-7837928d>
    NOTE: Some of the definitions in here have been included in the matrix/vector library,
    but under quite different systematic names.
  </pre></article></div></main><footer data-v-c785faa8><p data-v-c785faa8><a href="https://github.com/joy-language/joy-lang.org" data-v-c785faa8>GitHub</a></footer></div></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{},{}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.10669f42b2e188f55eb1.js"></script><script defer src="/_nuxt/layouts/default.29c0e08e13310e3682fc.js"></script><script defer src="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js"></script><script defer src="/_nuxt/pages/papers-on-joy/design-of-matrix-multiplication-programs.8e00ebe2e6e430523681.js"></script><script defer src="/_nuxt/vendor.230cb916d1973aa790f3.js"></script><script defer src="/_nuxt/app.0a856c7cf6fb3e349fa2.js"></script>
  

