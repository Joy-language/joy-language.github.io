<!DOCTYPE html>
<html data-n-head="" data-n-head-ssr>
  <head>
    <meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Joy Programming Language" name="description" data-hid="description"><title data-n-head="true">Joy language</title><link href="https://fonts.googleapis.com/css?family=Fira+Sans:200,500|Roboto:400|Roboto+Mono:400" rel="stylesheet" data-n-head="true"><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/favicon.ico?" rel="shortcut icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.10669f42b2e188f55eb1.js" rel="preload" as="script"><link href="/_nuxt/vendor.230cb916d1973aa790f3.js" rel="preload" as="script"><link href="/_nuxt/app.0a856c7cf6fb3e349fa2.js" rel="preload" as="script"><link href="/_nuxt/layouts/default.29c0e08e13310e3682fc.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/atomic-programs-of-joy.f2cb1414ae2b6ed9401e.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/survey-of-reproducing-programs.ed8409adcfb2bdec6eeb.js" rel="prefetch"><link href="/_nuxt/pages/libraries-and-c-sources.d2ffa370ff989df9d359.js" rel="prefetch"><link href="/_nuxt/pages/index.73b5e04f9a3fcda5b5fe.js" rel="prefetch"><link href="/_nuxt/pages/about.a3431c5910b96e7d0298.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-algebra-of-joy.7f385b55e84045676f24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-annoying-quadratic-formula.a3d9ef30d4f74df89dfd.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/church-arithmetic-and-church-logic-with-brent-kirby.e11588a1a251690d41af.js" rel="prefetch"><link href="/_nuxt/pages/rationale-for-joy.3e067852511f512169f0.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/tutorial-on-joy.9a4df70c3d63708c2b23.js" rel="prefetch"><link href="/_nuxt/pages/overview-of-joy.8733ad0cbce5d065d604.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/miscellaneous-miniature-implementations-of-joy.417498df53623dd27f3a.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/fast-small-truth-tables.9b1b75741215fa7afac3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/programming-in-joy.d4bc3bc57b9855085dc1.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-matrix-multiplication-programs.8e00ebe2e6e430523681.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/imperative-thinking-for-joy-programs.223ec58c271bc7112421.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-a-joy-interpreter-written-in-joy.eaa748fa0ea2130e1164.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/joy-compared-with-other-functional-languages.e9b1e34a3b81758a64f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/recursion-theory-and-joy.7d268252a6e6c71fa9f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/nested-recursion-and-a-new-recursion-combinator.d40eac9bf6ad0e5cac92.js" rel="prefetch"><link href="/_nuxt/pages/faq.9ffdbd52d27b2df75f94.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/mathematical-foundations-of-joy.4f0b584e560cf803bb24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/floy-a-flat-concatenative-subset-of-joy.9162d7b51e29e1b5b1b9.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/html-manual.e3473b0453170639a088.js" rel="prefetch"><link href="/_nuxt/pages/faq-part-2.9630745e3aaebc47633f.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/lazy-lists-as-reproducing-programs.9516d2d5134cfed90ce3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-current-implementation.e033c23017443bc35c24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/a-rewriting-system-for-joy.4157d6f1ef190fb675ea.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/prospectus-for-john-cowans-joy1.cb4661329c1ed2df6752.js" rel="prefetch"><style data-vue-ssr-id="d505b096:0">html{font-family:Roboto,Arial,sans-serif;margin:0;font-weight:400;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box}body{margin:0;height:100%}:after,:before,:not(pre){-webkit-box-sizing:border-box;box-sizing:border-box;margin:0}.wrapper{min-height:calc(100vh - 102px)}a{color:#3273dc;text-decoration:none}a:hover{text-decoration:underline}</style><style data-vue-ssr-id="6cc65792:0">nav[data-v-251e63b6]{background-color:#000}ul[data-v-251e63b6]{list-style-type:none;padding:0;margin:0}li[data-v-251e63b6]{-webkit-transition:all .2s ease-out;transition:all .2s ease-out;display:inline-block;padding:0;cursor:pointer}li[data-v-251e63b6]:hover{-webkit-transform:scale(1.04);transform:scale(1.04);background-color:#fff;color:#000}li a[data-v-251e63b6]{display:block;padding:15px 25px;text-decoration:none;color:#fff;text-align:center}li:hover a[data-v-251e63b6]{color:#000}.nuxt-link-exact-active[data-v-251e63b6]{text-decoration:overline}</style><style data-vue-ssr-id="23d2604d:0">h1[data-v-7e83a563]{font-size:26px}.lists[data-v-7e83a563]{margin-top:37px;padding-left:12vw;padding-right:12vw}.top-list-item[data-v-7e83a563]{margin-top:11px}li[data-v-7e83a563]{line-height:39px}.no-style-litem[data-v-7e83a563]{list-style-type:none}ul[data-v-7e83a563]{list-style-type:circle}h6[data-v-7e83a563]{font-size:17px}p[data-v-7e83a563]{margin-top:8px;line-height:24px;font-size:16px}</style><style data-vue-ssr-id="e61faf18:0">p[data-v-084c8a36]{margin-top:16px;margin-bottom:16px}hr[data-v-084c8a36]{margin-bottom:16px}pre[data-v-084c8a36]{margin-bottom:auto}code[data-v-084c8a36],kbd[data-v-084c8a36],pre[data-v-084c8a36]{font-family:Roboto Mono,monospace}</style><style data-vue-ssr-id="ca9343dc:0">footer[data-v-c785faa8]{padding:11px 20px 0;height:52px}p[data-v-c785faa8]{-webkit-transition:all .1s ease-in;transition:all .1s ease-in;font-size:15px;float:right;margin:0 16px}a[data-v-c785faa8]{color:#000;text-decoration:none}p[data-v-c785faa8]:hover{-webkit-transform:scale(.94);transform:scale(.94);color:#000;-webkit-text-decoration:#3273dc overline;text-decoration:#3273dc overline}</style>
  </head>
  <body data-n-head="">
    <div id="__nuxt" data-server-rendered="true"><div id="__layout"><div class="container" lang="en"><nav data-v-251e63b6 role="navigation"><ul data-v-251e63b6><li data-v-251e63b6><a href="/" data-v-251e63b6 class="nuxt-link-active">Home</a><li data-v-251e63b6><a href="/papers-on-joy" data-v-251e63b6 class="nuxt-link-active">Papers</a><li data-v-251e63b6><a href="/libraries-and-c-sources" data-v-251e63b6>Libraries/C sources</a><li data-v-251e63b6><a href="/about" data-v-251e63b6>About</a></ul></nav><main class="lists" data-v-7e83a563><div data-v-7e83a563><article data-v-084c8a36 data-v-7e83a563 data-v-7e83a563><h1 data-v-084c8a36> Atomic Programs of Joy </h1><i data-v-084c8a36> by Manfred von Thun </i><p data-v-084c8a36><em data-v-084c8a36> Abstract: </em> Joy is a functional programming language based on the composition
    of functions taking one stack as argument and yielding one stack as value. Stacks
    can contain values of simple types such as truth values, characters and integers,
    and values of aggregate types such as sets, character strings and quoted programs
    with lists as a special case. The stack functions include the usual operations
    such as addition, comparison and list manipulation, but also many new kinds of
    functions which dequote quoted programs in various ways. These new functions behave
    like higher order functions, such as conditionals, various forms of recursion,
    and for aggregates the map, fold and filter functions. This paper gives an overview
    of the basic programs from which others are built by composition and quotation.
  <p data-v-084c8a36>
    Keywords: functional programming, function composition, higher order functions, quotation
    and dequotation of programs, combinators.
  <hr data-v-084c8a36><h1 data-v-084c8a36>Introduction</h1>
  The design of Joy was motivated mainly by <a href="refs.html#{Backus78}" data-v-084c8a36>{Backus78}</a>who argued that language concepts should be selected on the basis of yielding strong
  and clean mathematical laws. This paper describes the atomic programs of Joy from
  which larger programs are concatenated, it does not describe the algebra or other
  theoretical issues related to Joy.
  <p data-v-084c8a36>
    Joy programs denote functions which take <em data-v-084c8a36>state</em>s as arguments and as values.
    Programs are built from atomic programs which also denote functions which take
    states as arguments and as values. The meaning of compound programs has to be given
    in terms of the meanings of atomic programs. It is useful to classify atomic programs
    into categories depending on what kind of function they denote. A coarse classification
    distinguishes just three, called 1) the
    <em data-v-084c8a36>literal</em>s, 2) the <em data-v-084c8a36>operator</em>s and 3) the
    <em data-v-084c8a36>combinator</em>s.
  <p data-v-084c8a36>
    Firstly, the <em data-v-084c8a36>literal</em> atomic programs are those which look like constants
    in conventional languages. They comprise literal numbers (or, more correctly, numerals)
    such as integers, and other literals of type character, string, truth value and
    set. Literals do not denote numbers, characters, strings and so on, but they denote
    functions which take one state as argument and yield as value another state which
    is like the argument state except that the value of the literal has been pushed
    onto the stack component.
  <p data-v-084c8a36>
    Secondly, the <em data-v-084c8a36>operator</em> atoms are those which look like <em data-v-084c8a36>
    n</em>-ary operators in other languages. They include the operations such as for
    addition and the other arithmetical operations, and for the various operations
    on other types. Like all programs, operators denote functions from states to states,
    but the functions are not defined on all states. An <em data-v-084c8a36> n</em>-ary operator (such
    as the binary addition operator) denotes a function which is defined only on states
    whose stack component has <em data-v-084c8a36> n</em> items (such as two integers) on top.
  <p data-v-084c8a36>
    The function yields as value another state which is like the argument state except
    that the <em data-v-084c8a36> n</em> items on the stack have been replaced by the result (such
    as the sum).
  <p data-v-084c8a36>
    Also included as operators are those atoms denoting mere structural functions of
    the stack component such as <code data-v-084c8a36>dup</code>,
    <code data-v-084c8a36>swap</code> and <code data-v-084c8a36>pop</code>, and those that involve input and output
    such as <code data-v-084c8a36>get</code> and <code data-v-084c8a36>put</code>.
  <p data-v-084c8a36>
    Thirdly, the <em data-v-084c8a36>combinator</em> atoms are like operators in that they require
    the top of the stack to contain certain items. But unlike operators, they do not
    treat these items as passive data. Instead they execute these items - and hence
    those items must be quoted programs. So, combinators also denote functions which
    are defined only on states having the appropriate number of quoted programs on
    top of the stack. They yield as values another state which depends on the argument
    state, including the quoted programs, and on the combinator itself.
  <p data-v-084c8a36>
    Literals, operators and combinators can be concatenated to form
    <em data-v-084c8a36>program</em>s. These may then be enclosed in square brackets to form literal
    <em data-v-084c8a36>quotation</em>s. Such literals are not atomic, but if they occur in a program
    they are treated just like other literals: they cause the quoted program to be
    pushed onto the stack. So, literal quotations denote functions which take any stack
    as argument and yield as value another stack which is like the argument stack except
    that it has the quotation pushed on top. Quotations on top of the stack can be
    treated like other values, they can be manipulated, taken apart and combined, but
    they can also be executed by combinators. If a quotation contains only literals,
    then it is a value of the <em data-v-084c8a36>list type</em>. The component literals do not have
    to be of the same type, and they may include further quotations. If a list is executed
    by a combinator, then its components are pushed onto the stack.
  <p data-v-084c8a36>
    The remainder of this paper is organised as follows: The next section describes the
    principal types of Joy and their literals. Following that are four sections on
    operators, the general ones applicable to all types, then those applicable to simple
    types such as integers, characters and truth values, then those applicable to aggregate
    types such as strings, sets and lists, and finally the predicates which return
    truth values. The following three sections deal with combinators, first those that
    are independent of any typing, then those specialised to simple types, and finally
    those specialised to aggregate types.
  <h1 data-v-084c8a36>Types and Literals</h1>
  Joy programs are built from smaller programs by means of concatenation. The ultimate
  building blocks are atomic programs which do not have any programs as parts. Like
  all programs, atoms denote unary functions. It is useful to classify atoms on the
  basis of what kinds of functions they denote. Three broad classes can be distinguished
  in terms of their domain and range. For expository purposes it is helpful to adopt
  procedural terminology for a while, and to express the classification in terms of
  what the atoms do to the stack component of the state.
  <p data-v-084c8a36>
    Some atoms can be applied to any stack and their effect is to push something on the
    stack. The items that can be pushed are of various types. There are <em data-v-084c8a36>simple type</em>s
    such as integers, characters and truth values. There are also <em data-v-084c8a36>aggregate type</em>s
    such as strings, sets and quoted programs. Atomic programs which push a simple
    or aggregate value onto the stack will be called
    <em data-v-084c8a36>literal</em>s. A different kind of atom can be applied only to a non-empty
    stack. Their effect is to re-organise the top few elements of the stack.
  <p data-v-084c8a36>
    Some, like <kbd data-v-084c8a36>dup</kbd>, <kbd data-v-084c8a36>swap</kbd> and <kbd data-v-084c8a36>pop</kbd>, just edit the top
    few elements. Others expect the top few elements to be of certain types and their
    effect is to replace these elements by the result of applying a function to them
    as arguments. These include the arithmetic and relational operators for addition,
    multiplication and comparisons, and the truthfunctional operators. They also include
    list operations like concatenation. Collectively all of them will be called <em data-v-084c8a36>operator</em>s.
    A third kind of atoms expect quoted programs on the top of the stack. Like the
    operators, they pop the quoted programs off the stack. But they do not treat them
    as passive data structures in the way operators do. Instead they cause the quoted
    programs to be executed. These are called
    <em data-v-084c8a36>combinator</em>s.
  <p data-v-084c8a36>
    After this rough exposition of the classification it is important to suppress any
    procedural reading and to revert to the official interpretation of Joy programs
    as denoting unary functions. So the three classes of atoms, namely literals, operators
    and combinators, all denote unary functions from and to states which include a
    stack as a principal component. The remainder of this section will deal with literals.
  <p data-v-084c8a36>
    First, the literals of the <em data-v-084c8a36>integer type</em>. The following is the offical
    semantics of those atoms that look like numerals:
  <blockquote data-v-084c8a36>
    A digit string such as "<code data-v-084c8a36>123</code>" denotes not a <em data-v-084c8a36>
    number</em> but a <em data-v-084c8a36> function</em> from states to states. For any state S1 as argument
    this function yields as its value another state S2 which is like S1 except that
    its stack component has an additional item, the <em data-v-084c8a36> number</em> 123 pushed onto
    it.
  </blockquote>
  The semantics for the <em data-v-084c8a36>truth value type</em> is similar: The two symbols <kbd data-v-084c8a36>true</kbd>and <kbd data-v-084c8a36>false</kbd> denote functions which for any state as argument yields as value
  another state which is like the argument state except that the logical constant <code data-v-084c8a36>true</code>or <code data-v-084c8a36>false</code> has been pushed onto the stack. Literals of the
  <em data-v-084c8a36>character type</em> can be treated just like small numbers. So, a quoted character
  such as <code data-v-084c8a36>'A</code> denotes a function taking any state into another state with
  that character pushed onto the stack.
  <p data-v-084c8a36>
    The three types of truth values, characters and integers constitute what will be
    called simple types. They are simple in that their values do not have parts. There
    are also aggregate types which do have parts. The parts can be extracted by suitable
    operators and the aggregates can be constructed from their parts. Joy has three
    different aggregate types: sets of small numbers, strings of characters, and quoted
    programs, which have lists as a special case.
  <p data-v-084c8a36>
    The <em data-v-084c8a36>set type</em> comprises the usual unordered collections familiar from set
    theory. The elements of a set are written inside curly braces, such as <code data-v-084c8a36>{1 3 5}</code>.
    The whole is a literal atom, and it denotes a function pushing that set onto the
    stack. For most implementations on current machines the elements of sets will be
    small numbers in the range <code data-v-084c8a36>0</code> .. <code data-v-084c8a36>31</code>, The
    <em data-v-084c8a36>string type</em> of character strings constitutes another aggregate type. Its
    literals are written as zero or more characters enclosed in double quotes, such
    as <code data-v-084c8a36>"Hello"</code>. Such a literal again denotes a function, one which pushes
    that string.
  <p data-v-084c8a36>
    The third aggregate type is that of <em data-v-084c8a36>quoted program</em>s, or briefly, <em data-v-084c8a36>quotation</em>s.
    Its literals are written inside square brackets. A program consists of zero or
    more literals, operators or combinators. Enclosing it in square brackets turns
    it into a quoted program. Quotations denote functions which push the quoted program;
    the quoted program is not executed, it is pushed onto the stack in "suspended animation".
    The following are quotations:
  <pre data-v-084c8a36>        [1 2 3]                         ['A 'B "CDE" {10 11 12}]
          [pop dup *]                     [[[]]]
          [peter paul mary]               ["" {} [] [hello "Hello"]
  </pre>
  A value of the <em data-v-084c8a36>list type</em> is just a special case of a quotation in
  which the elements are themselves literals. Quotations can contain other quotations,
  and hence lists can contain other lists.
  <p data-v-084c8a36>
    The following concern connections between quotations and the stack. The stack is
    normally a sequence of values of various types. This sequence is just a special
    list which is modified by programs. Since it is a list, it should be possible to
    put this list on top of the stack - that is to say, on top of itself. Also, it
    should be possible to make the list on top of the stack become the stack. Finally,
    it should be possible to create a new, empty stack. There are three operators that
    do just that:
  <pre data-v-084c8a36>        stack     unstack    newstack
  </pre>
  The <kbd data-v-084c8a36>stack</kbd> operator pushes onto the stack a list containing all
  the elements of the stack. The <kbd data-v-084c8a36>unstack</kbd> operator expects a list on top
  of the stack and makes that the stack. The
  <code data-v-084c8a36>unstack</code> operator undoes what the <code data-v-084c8a36>stack</code> operator does, but
  the reverse is true only in special cases. The
  <kbd data-v-084c8a36>newstack</kbd> operator deletes the entire stack and replaces it with a new,
  empty one. Also, it should be noted that the stack is not always a sequence of values,
  it can also contain operators and combinators. So, strictly speaking the stack is
  always a quotation, and the <code data-v-084c8a36>stack</code> operator pushes a quotation onto the
  stack, and the <code data-v-084c8a36>unstack</code> operator expects a quotation on the stack and
  makes that the new stack.
  <p data-v-084c8a36>
    It is sometimes useful to treat several types together. The
    <em data-v-084c8a36>numeric</em> types are integers and characters, the
    <em data-v-084c8a36>Boolean</em> types are truth values and sets, and the
    <em data-v-084c8a36>sequence</em> types are strings and lists. A <em data-v-084c8a36>leaf</em> is anything which
    is not a list, and a <em data-v-084c8a36>tree</em> is either a leaf or a (possibly empty) list
    of trees.
  <p data-v-084c8a36>
    This completes the brief survey of the six principal types and their literals. Other
    types might be included in more elaborate versions of Joy. Obvious simple types
    to add are real (and perhaps complex) numbers, and an enumeration type as in Pascal.
    It is less clear what new aggregate types are useful since lists already are so
    versatile. Records and arrays are certainly possible. Only files will be considered
    briefly below.
  <h1 data-v-084c8a36>General Operators</h1>
  An <em data-v-084c8a36>operator</em> is a function which expects as argument one stack whose top
  few elements satisfy some condition and which returns a stack in which the top few
  elements have been replaced by something else, and which otherwise is like the argument
  stack. For most operators the top few elements are replaced by just one element,
  but there are some for which they are replaced by none or by two. In fact, operators
  may be defined in which any number (0, 1 ...) of elements on the argument stack are
  replaced by any number (0, 1 ...) of elements on the result stack. A <em data-v-084c8a36>unary operator</em>is one whose argument stack requires at least one element. A <em data-v-084c8a36>binary
  operator</em> is one whose argument stack requires at least two elements. There are
  even some <em data-v-084c8a36>ternary operator</em>s.
  <p data-v-084c8a36>
    First, the following unary operators are defined on all stacks containing at least
    one element:
  <pre data-v-084c8a36>        pop     dup
  </pre>
  The top element does not have to satisfy any particular condition, it can
  be of any type. The <kbd data-v-084c8a36>pop</kbd> operator removes the top element. The <kbd data-v-084c8a36>dup</kbd>operator pushes a duplicate on top, so it replaces the one original by two copies.
  <p data-v-084c8a36>
    The following binary operators are defined on all stacks containing at least two
    elements:
  <pre data-v-084c8a36>        swap    popd    popop    dupd
  </pre>
  The <kbd data-v-084c8a36>swap</kbd> operator interchanges the top two elements. The
  <kbd data-v-084c8a36>popd</kbd> operator removes the second element. The
  <kbd data-v-084c8a36>popop</kbd> operator removes the first and the second element. The <kbd data-v-084c8a36>dupd</kbd>operator duplicates the second element.
  <p data-v-084c8a36>
    The following ternary operators are defined for all stacks containing at least three
    elements:
  <pre data-v-084c8a36>        swapd    rollup    rolldown
  </pre>
  The <kbd data-v-084c8a36>swapd</kbd> operator interchanges the second and third elements but
  leaves the first element in place. The <kbd data-v-084c8a36>rollup</kbd> operator moves the third
  and second element into second and third position and moves the first element into
  third position. The
  <kbd data-v-084c8a36>rolldown</kbd> operator moves the second and first element into third and second
  position and moves the third element into first position.
  <p data-v-084c8a36>
    There is another <em data-v-084c8a36>ternary operator</em>:
  <pre data-v-084c8a36>        choice
  </pre>
  The <kbd data-v-084c8a36>choice</kbd> operator expects three values on top of the stack, say
  <code data-v-084c8a36>X</code>, <code data-v-084c8a36>Y</code> and <code data-v-084c8a36>Z</code>, with
  <code data-v-084c8a36>Z</code> on top. The third value from the top, <code data-v-084c8a36>X</code>, has to be a
  truth value. If it is <code data-v-084c8a36>true</code>, then the
  <code data-v-084c8a36>choice</code> operator just leaves <code data-v-084c8a36>Y</code> on top of the stack, and
  <code data-v-084c8a36>X</code> and <code data-v-084c8a36>Z</code> disappear. On the other hand, if <code data-v-084c8a36>X</code>is false, then the <code data-v-084c8a36>choice</code> operator just leaves <code data-v-084c8a36>Z</code> on top
  of the stack, and <code data-v-084c8a36>X</code> and
  <code data-v-084c8a36>Y</code> disappear. This operator is related to two combinators
  <code data-v-084c8a36>ifte</code> and <code data-v-084c8a36>branch</code> which are explained in the next sections.
  <p data-v-084c8a36>
    There is another operator for multi-choices. It expects a non-empty list of non-empty
    lists on top of the stack and below that one further item.
  <pre data-v-084c8a36>        opcase
  </pre>
  The <kbd data-v-084c8a36>opcase</kbd> operator matches the type of the item with the
  <code data-v-084c8a36>first</code> members of the lists. When a match is found, the
  <code data-v-084c8a36>rest</code> of that list is pushed onto the stack. If no match is found, then
  the last list is used as the default.
  <p data-v-084c8a36>
    The following two operators handle input and output:
  <pre data-v-084c8a36>        put    get
  </pre>
  The <kbd data-v-084c8a36>put</kbd> operator expects one item on top of the stack, it removes
  it and writes it to the output file. The <kbd data-v-084c8a36>get</kbd> operator expects one item
  in the input file, it reads it from there and pushes it on top of the stack.
  <h1 data-v-084c8a36>Operators for Simple Types</h1>
  The following binary operators are defined for all numeric types. They have their
  usual meaning, and the result is given the type of the second parameter.
  <pre data-v-084c8a36>        +    -    *    /    %    max    min
  </pre>
  The following unary operators are defined for all numeric types.
  <pre data-v-084c8a36>        succ    pred    abs    sign
  </pre>
  The <kbd data-v-084c8a36>succ</kbd> and <kbd data-v-084c8a36>pred</kbd> operators yield the
  <em data-v-084c8a36>successor</em> and <em data-v-084c8a36>predecessor</em>, respectively. The
  <kbd data-v-084c8a36>abs</kbd> operator computes the <em data-v-084c8a36>absolute value</em>, and the
  <kbd data-v-084c8a36>sign</kbd> operator returns the <em data-v-084c8a36>signum</em> value, an integer which is <code data-v-084c8a36>-1</code>,
  <code data-v-084c8a36>0</code> or <code data-v-084c8a36>+1</code> depending on whether the parameter is negative,
  zero or positive.
  <p data-v-084c8a36>
    The following mathematical functions are provided:
  <pre data-v-084c8a36>        fact    exp    fib    nfib    gcd
  </pre>
  The unary <kbd data-v-084c8a36>fact</kbd> operator computes the <em data-v-084c8a36>factorial</em> function.
  The binary <kbd data-v-084c8a36>exp</kbd> operator computes the
  <em data-v-084c8a36>exponentiation</em> function, the exponent is the top parameter. The binary <kbd data-v-084c8a36>fib</kbd>operator computes the <em data-v-084c8a36>Fibonacci</em> function. The binary <kbd data-v-084c8a36>nfib</kbd> operator
  computes a similar function, which is the number of calls which a recursive implementation
  of the Fibonacci function would need; if this function is implemented recursively,
  then the number of its calls is the same. The binary <kbd data-v-084c8a36>gcd</kbd> operator computes
  the <em data-v-084c8a36>greatest common
  divisor</em>.
  <p data-v-084c8a36>
    The type of truth values is one of the Boolean types. The operators are
  <pre data-v-084c8a36>        and    or    xor    not
  </pre>
  The three binary operators <kbd data-v-084c8a36>and</kbd>, <kbd data-v-084c8a36>or</kbd> and
  <kbd data-v-084c8a36>xor</kbd> compute the logical <em data-v-084c8a36>conjunction</em>, <em data-v-084c8a36>inclusive
  disjunction</em> and <em data-v-084c8a36>exclusive disjunction</em>. The unary
  <kbd data-v-084c8a36>not</kbd> operator computes the <em data-v-084c8a36>negation</em>.
  <h1 data-v-084c8a36>Operators for Aggregate Types</h1>
  The following unary operators expect a non-empty aggregate on top of the stack:
  <pre data-v-084c8a36>        first    second    third    rest
  </pre>
  The <kbd data-v-084c8a36>first</kbd> operator extracts the first element of values of the
  sequence types string and list. For sets it extracts the first member using the underlying
  ordering. The <kbd data-v-084c8a36>second</kbd> operator expects an aggregate of at least two elements,
  for sequences it extracts the second element, for sets it extracts the second element
  under the ordering. The <kbd data-v-084c8a36>third</kbd> operator expects an aggregate of at least
  three members, it extracts the third element. The <kbd data-v-084c8a36>rest</kbd> operator expects
  an aggregate with at least one member, it returns an aggregate which is like the
  parameter aggregate but has its first element removed.
  <p data-v-084c8a36>
    The following binary operators require an aggregate and a potential member on top
    of the stack:
  <pre data-v-084c8a36>        cons     swons
  </pre>
  The <kbd data-v-084c8a36>cons</kbd> operator expects the aggregate on top of the stack and
  the potential member below. The effect is to add the potential member into the aggregate.
  In the case of strings and lists the potential member is added in front. In the case
  of sets the potential member is added only in case it is not already a member. The
  <kbd data-v-084c8a36>swons</kbd> operator does essentially the same except that it expects the potential
  member on top and the aggregate below. Essentially <code data-v-084c8a36>swons</code> is equivalent
  to the composition
  <code data-v-084c8a36>swap cons</code>, and hence its name. The two operators are
  <em data-v-084c8a36>converse</em>s of each other.
  <p data-v-084c8a36>
    The following unary operators also require a non-empty aggregate on top of the stack:
  <pre data-v-084c8a36>        uncons     unswons
  </pre>
  The <kbd data-v-084c8a36>uncons</kbd> operator replaces the aggregate element by two elements,
  the first and the rest, with the rest on top. The
  <kbd data-v-084c8a36>unswons</kbd> operator does the same, but with the first on top. These two operators
  differ from other operators in that they leave
  <em data-v-084c8a36> two</em> values on top of the stack. Such operators would not make much sense
  in other notations. Their names were chosen because their effect is to undo the effect
  of the two binary operators
  <code data-v-084c8a36>cons</code> and <code data-v-084c8a36>swons</code>.
  <p data-v-084c8a36>
    There are two operators for <em data-v-084c8a36>index</em>ing in various ways:
  <pre data-v-084c8a36>        at    of    drop    take
  </pre>
  These four binary operators expect an aggregate and a number. That number
  is used for indexing into the aggregate. The <kbd data-v-084c8a36>at</kbd> operator expects the aggregate
  <tt data-v-084c8a36>A</tt> and above that a number <tt data-v-084c8a36>N</tt>, it returns that member of the aggregate
  which is at the <tt data-v-084c8a36>N</tt>-th position in the aggregate. The <kbd data-v-084c8a36>of</kbd> operator
  expects a number <tt data-v-084c8a36>N</tt> and above that an aggregate <tt data-v-084c8a36>A</tt>, it returns the
  <tt data-v-084c8a36>N</tt>-th member of <tt data-v-084c8a36>A</tt>. So the two operators are <em data-v-084c8a36>converse</em>s of
  each other. The
  <kbd data-v-084c8a36>drop</kbd> and <kbd data-v-084c8a36>take</kbd> operators both expect an aggregate
  <tt data-v-084c8a36>A</tt> and above that a number <tt data-v-084c8a36>N</tt>. The <code data-v-084c8a36>drop</code> operator returns
  an aggragate like <tt data-v-084c8a36>A</tt> except that the first <tt data-v-084c8a36>N</tt> elements have been
  removed. The <code data-v-084c8a36>take</code> operator returns an aggregate like
  <tt data-v-084c8a36>A</tt> except that only the first <tt data-v-084c8a36>N</tt> elements have been retained. For
  all four operators in the case of sequences the sequence ordering is used, and for
  sets the underlying ordering is used.
  <p data-v-084c8a36>
    The following are some general operators for aggregates:
  <pre data-v-084c8a36>        size     reverse    concat    swoncat
          zip    flatten    transpose
  </pre>
  The unary <kbd data-v-084c8a36>size</kbd> operator determines the number of elements of any
  aggregate, and for lists this means top level members. The unary <kbd data-v-084c8a36>reverse</kbd>operator reverses strings and lists, it has no effect on sets. The binary <kbd data-v-084c8a36>concat</kbd>operator concatenates two sequences of the same type, it appends the top parameter
  to the second parameter. The <kbd data-v-084c8a36>swoncat</kbd> operator does the same except that
  it executes a <code data-v-084c8a36>swap</code> first. The binary
  <kbd data-v-084c8a36>zip</kbd> operator expects two aggregates of the same type. It returns a list
  of lists of two elements, each pair taken from corresponding elements in the aggregates.
  The size of the result list is the same as the size of the smaller of the two parameter
  aggregates. The unary <kbd data-v-084c8a36>flatten</kbd> operator expects a list of sequences and
  combines them by concatenation. The unary
  <kbd data-v-084c8a36>transpose</kbd> operator is for matrix manipulation. It also expects a list
  of lists <tt data-v-084c8a36>L1, L2 ...</tt> and returns a list of lists. The first sublist contains
  the first members of the <tt data-v-084c8a36>Li</tt>, the second sublist contains the second members,
  and so on. The list returned has as many members as the shortest of the <tt data-v-084c8a36>Li</tt>.
  <p data-v-084c8a36>
    The type of sets is another of the Boolean types. The operators are
  <pre data-v-084c8a36>        and    or    xor    not
  </pre>
  The three binary operators <kbd data-v-084c8a36>and</kbd>, <kbd data-v-084c8a36>or</kbd> and
  <kbd data-v-084c8a36>xor</kbd> compute the <em data-v-084c8a36>intersection</em>, <em data-v-084c8a36>union</em> and
  <em data-v-084c8a36>symmetric difference</em>. The unary <kbd data-v-084c8a36>not</kbd> operator computes the <em data-v-084c8a36>complement</em>.
  For most implementations on current machines the complement will be with respect
  to the largest set,
  <code data-v-084c8a36>{0..31}</code>.
  <p data-v-084c8a36>
    The following operators on sequences deal with ordering of their elements:
  <pre data-v-084c8a36>        qsort    qsort1    merge
  </pre>
  The unary <kbd data-v-084c8a36>qsort</kbd> operator uses the <em data-v-084c8a36>quicksort</em> algorithm
  to return a sorted version of the parameter. The
  <kbd data-v-084c8a36>qsort1</kbd> operator does the same, except that it expects a list of sequences
  which it sorts according to the first element of the sequences. The binary <kbd data-v-084c8a36>merge</kbd>operator is like the
  <code data-v-084c8a36>concat</code> operator in that it produces a single sequence. The difference
  is that it picks elements from the two sequences in accordance with their order.
  If the two sequences were sorted, then the result of merging them is also sorted.
  <p data-v-084c8a36>
    The following are arithmetic operations for lists of numbers:
  <pre data-v-084c8a36>        sum    product    scalarproduct
  </pre>
  The first two expect a list of numbers, the <kbd data-v-084c8a36>sum</kbd> operator adds them
  up, the <kbd data-v-084c8a36>product</kbd> operator multiplies them, and for empty lists the results
  are 0 and 1 respectively. The
  <kbd data-v-084c8a36>scalarproduct</kbd> operator expects a list of two lists of numbers. It multiplies
  corresponding elements of the two lists and returns the sum of these products.
  <p data-v-084c8a36>
    The following unary operators expect an aggregate on top of the stack and leave a
    list of various subaggregates on top of the stack:
  <pre data-v-084c8a36>        frontlist    restlist    powerlist    subseqlist    permlist
  </pre>
  Let the size of the aggregate be (N). The <kbd data-v-084c8a36>frontlist</kbd> and
  <kbd data-v-084c8a36>restlist</kbd> operators return a list of <tt data-v-084c8a36>N+1</tt> subaggregates. The <code data-v-084c8a36>frontlist</code>operator returns a list, beginning with the empty aggregate, obtained by successively
  adding the last, second last ... first member of the original aggregate. The <code data-v-084c8a36>restlist</code>operator returns a list, beginning with the original aggregate, by successively removing
  the first, second ... last member of the original aggregate. The <kbd data-v-084c8a36>powerlist</kbd>operator returns a list of all 2^N subaggregates such that for each member of the
  original aggregate there will be one subaggregate in the list containing it and one
  not containing it. The <kbd data-v-084c8a36>subseqlist</kbd> operator is similar, but it returns
  a shorter list of (N * (N-1) / 2 + 1 ) subaggregates containing only consecutive
  members of the original aggregate. The <kbd data-v-084c8a36>permlist</kbd> only applies to sequence
  aggregates, it returns a list of all the <tt data-v-084c8a36>N!</tt> (<tt data-v-084c8a36>N</tt> factorial) permutations
  of the sequence.
  <p data-v-084c8a36>
    A related binary operator is
  <pre data-v-084c8a36>        insertlist
  </pre>
  The <kbd data-v-084c8a36>insertlist</kbd> operator expects a sequence and above that another
  potential member. It returns the list of all sequences obtained by inserting the
  potential member in all possible positions in the sequence.
  <p data-v-084c8a36>
    A related binary operator for finding the <em data-v-084c8a36>cartesian product</em> is
  <pre data-v-084c8a36>        cartproduct
  </pre>
  which expects two aggregates that do not have to be of the same type. The
  <kbd data-v-084c8a36>cartproduct</kbd> operator returns a list of all pairs (as two element lists)
  of elements taken from the two aggregates. If the aggregates have <tt data-v-084c8a36>M</tt> and
  <tt data-v-084c8a36>N</tt> members, there will be <tt data-v-084c8a36>M × N</tt> pairs in the result list.
  <p data-v-084c8a36>
    The following unary operators expect a tree:
  <pre data-v-084c8a36>      treeflatten    treestrip    treereverse    treesize
  </pre>
  The <kbd data-v-084c8a36>treeflatten</kbd> operator turns a tree into a flat list containg
  the leaves of the tree. The <kbd data-v-084c8a36>treestrip</kbd> operator returns a tree with the
  same structure but with all leaves removed. The <kbd data-v-084c8a36>treereverse</kbd> operator returns
  a tree in which (recursively) all internal lists have been reversed. The
  <kbd data-v-084c8a36>treesize</kbd> operator returns an integer which is the number of leaves.
  <h1 data-v-084c8a36>Predicates</h1>
  A <em data-v-084c8a36>predicate</em> is a function which leaves a truth value on the stack. The
  following unary predicates are defined for all numeric types:
  <pre data-v-084c8a36>        odd    even    positive    negative
  </pre>
  The <kbd data-v-084c8a36>odd</kbd> and the <kbd data-v-084c8a36>even</kbd> predicate return
  <code data-v-084c8a36>true</code> or <code data-v-084c8a36>false</code> just in case the parameter is odd or even.
  The <kbd data-v-084c8a36>positive</kbd> and the <kbd data-v-084c8a36>negative</kbd> predicate return <code data-v-084c8a36>true</code>or <code data-v-084c8a36>false</code> just in case the parameter is positive or negative -- note
  that truth values and characters are never negative.
  <p data-v-084c8a36>
    The following binary predicates are defined for all numeric types, they have their
    usual meaning:
  <pre data-v-084c8a36>        =    !=    &lt;    &lt;=    >    >=
  </pre>
  The following are two unary predicates defined for all types:
  <pre data-v-084c8a36>        null    small
  </pre>
  The <kbd data-v-084c8a36>null</kbd> predicate is true if its simple parameter is numerically
  zero or its aggregate parameter is empty. The
  <kbd data-v-084c8a36>small</kbd> predicate is true if its simple parameter is numerically zero or
  1, or its aggregate parameter contains at most one element.
  <p data-v-084c8a36>
    The following binary predicates test aggregates for members:
  <pre data-v-084c8a36>      in    has
  </pre>
  The <kbd data-v-084c8a36>in</kbd>-predicate is true if the second parameter is in the top
  aggregate parameter. The <kbd data-v-084c8a36>has</kbd>-predicate is true if the aggregate second
  parameter has the top parameter as a member. The two predicates are <em data-v-084c8a36>converse</em>s
  of each other.
  <p data-v-084c8a36>
    The following binary predicate is defined for two aggregates of the same kind:
  <pre data-v-084c8a36>        equal
  </pre>
  The <code data-v-084c8a36>equal</code> predicate is true if the two aggregates have the same
  members. For strings and lists this means same members in the same positions. For
  lists this means recursive equality.
  <p data-v-084c8a36>
    Sometimes it is necessary to test a parameter for its type. This is done by the following
    unary predicates:
  <pre data-v-084c8a36>        logical    char    integer    set    string    list    leaf
  </pre>
  The predicates <kbd data-v-084c8a36>logical</kbd>, <kbd data-v-084c8a36>char</kbd>,
  <kbd data-v-084c8a36>integer</kbd>, <kbd data-v-084c8a36>set</kbd>, <kbd data-v-084c8a36>string</kbd> and
  <kbd data-v-084c8a36>list</kbd> are true if the parameter is a true value, character, integer, set,
  string or list, respectively. The predicate
  <kbd data-v-084c8a36>leaf</kbd> is true if the parameter is not a list.
  <p data-v-084c8a36>
    Sometimes it is useful to operate on quoted predicates to obtain another quoted predicate.
    There are three such operators:
  <pre data-v-084c8a36>        conjoin    disjoin    negate
  </pre>
  The two operators <kbd data-v-084c8a36>conjoin</kbd> and <kbd data-v-084c8a36>disjoin</kbd> expect two quoted
  predicates and return one quoted predicate. If that is ever called it will compute
  the conjunction or disjunction of the two parameters. The other operator is <kbd data-v-084c8a36>negate</kbd>which expects one quoted predicate and returns a quoted predicate which computes
  the negation.
  <h1 data-v-084c8a36>General Combinators</h1>
  Most functional languages are based on the lambda calculus. As one of their fundamental
  operations they use the <em data-v-084c8a36>application</em> of a function to its arguments or parameters.
  The formal parameters of functions have explicit names, and application requires
  the substitution of the actual parameters for the formal parameters. In Joy there
  are no named formal parameters, and most of the work of application is done instead
  by
  <em data-v-084c8a36>combinator</em>s. Combinators behave like higher order functions -- they take
  other functions as parameters. However, they take those other functions in the form
  of quoted programs from the stack. Hence combinators are like literals and operators
  in that they denote first order functions from states to states. This is possible
  because the property of being higher order is transferred to (the stack component
  of) the state. So, combinators require that the top of the stack contains one or
  more quotations.
  <p data-v-084c8a36>
    Combinators can be classified in many ways: in terms of the number of expected quotations,
    in terms of the total number of expected parameters, quotations and others, in
    terms of their behaviour, and so on. To fix the terminology, combinators will be
    called <em data-v-084c8a36>
    unary</em>, <em data-v-084c8a36> binary</em>, <em data-v-084c8a36> ternary</em> and so on, if they expect one or
    two or three quotations, and so on. But note that many combinators expect further
    parameters below the quotations which they will execute. The following are some
    simple <em data-v-084c8a36>unary
    combinator</em>s which require the top of the stack to be <em data-v-084c8a36>
    one</em> quotation.
  <pre data-v-084c8a36>        i     x     y
  </pre><p data-v-084c8a36>
    The <kbd data-v-084c8a36>i</kbd> combinator pops the quotation off the stack and executes it, effectively
    by <em data-v-084c8a36>dequoting</em>. The <kbd data-v-084c8a36>x</kbd> combinator leaves the quotation on the
    stack and executes it. Consequently the <code data-v-084c8a36>x</code> combinator will be executing
    on a stack which has as its top element the very same quotation which it is currently
    executing. The <kbd data-v-084c8a36>y</kbd> combinator first converts the quotation <code data-v-084c8a36>[P]</code>  into a different quotation <code data-v-084c8a36>[Q]</code> with the following strange property:
    if <code data-v-084c8a36>[Q]</code> is ever called by some combinator, then it builds a copy of
    itself on top of the stack and then executes the <code data-v-084c8a36>[P]</code>-part of itself.
    After this conversion, the <code data-v-084c8a36>y</code> combinator calls the
    <code data-v-084c8a36>[Q]</code> it has constructed. In this way the <code data-v-084c8a36>y</code> combinator
    builds some of the behaviour of the <code data-v-084c8a36>x</code> combinator into the <code data-v-084c8a36>[Q]</code>.
  <p data-v-084c8a36>
    Another unary combinator is
  <pre data-v-084c8a36>        nullary
  </pre>
  No matter how many parameters the quotation consumes from the stack when <kbd data-v-084c8a36>nullary</kbd>executes it, they are all restored and the final value calculated by the execution
  of the quotation is pushed on top of that.
  <p data-v-084c8a36>
    The next unary combinators allow manipulation of the stack below the top few elements:
  <pre data-v-084c8a36>        dip    dipd    dipdd
  </pre>
  The <kbd data-v-084c8a36>dip</kbd> combinator requires a further element <code data-v-084c8a36>X</code> to
  be below the quotation. It removes the quotation and
  <code data-v-084c8a36>X</code>, saves <code data-v-084c8a36>X</code> somewhere, executes the quotation on the remainder
  of the stack, and finally restores <code data-v-084c8a36>X</code>. The <kbd data-v-084c8a36>dipd</kbd> and the <kbd data-v-084c8a36>dipdd</kbd>combinator are similar. They expect two or three elements, (X) and (Y), or (X), (Y)
  and (Z) below the quotation. The two or three elements are saved and restored after
  the execution of the quotation.
  <p data-v-084c8a36>
    Three further unary combinators are
  <pre data-v-084c8a36>        app1    app2    app3
  </pre>
  Apart from the quotation which they expect on top of the stack, they require
  one or two or three further elements on the stack. So the
  <code data-v-084c8a36>app2</code> combinator requires two further elements, say
  <code data-v-084c8a36>X</code> and <code data-v-084c8a36>Y</code>. In this case the quotation will be executed twice,
  once with <code data-v-084c8a36>X</code> on top of the stack and once with <code data-v-084c8a36>Y</code> on top
  of the stack. The executions could be done in any order, even concurrently, provided
  there are no side effects. If both executions terminate, both should leave behind
  a non-empty stack with respectively <code data-v-084c8a36>X'</code> and <code data-v-084c8a36>Y'</code> on top.
  <p data-v-084c8a36>
    These two values, in their order, are then pushed onto the stack in place of <code data-v-084c8a36>X</code>  and <code data-v-084c8a36>Y</code>. The two other combinators
    <code data-v-084c8a36>app1</code> and <code data-v-084c8a36>app3</code> behave analogously: The
    <code data-v-084c8a36>app1</code> combinator causes just one execution of the quotation, and it
    replaces <code data-v-084c8a36>X</code> by <code data-v-084c8a36>X'</code>. The
    <code data-v-084c8a36>app3</code> combinator cases three executions of the quotation, and it replaces
    <code data-v-084c8a36>X</code>, <code data-v-084c8a36>Y</code> and <code data-v-084c8a36>Z</code> by
    <code data-v-084c8a36>X'</code>, <code data-v-084c8a36>Y'</code> and <code data-v-084c8a36>Z'</code>, maintaining the order.
  <p data-v-084c8a36>
    The <em data-v-084c8a36>binary combinator</em>s expect two quotations on top of the stack.
  <pre data-v-084c8a36>        b     cleave
  </pre>
  The <kbd data-v-084c8a36>b</kbd> combinator expects two quotations <code data-v-084c8a36>[P]</code> and
  <code data-v-084c8a36>[Q]</code>, with <code data-v-084c8a36>[Q]</code> on top. It removes the two quotations and
  executes first <code data-v-084c8a36>[P]</code> and then
  <code data-v-084c8a36>[Q]</code>. The <kbd data-v-084c8a36>cleave</kbd> combinator also expects two quotations, and
  below that an item <code data-v-084c8a36>X</code>. It also first executes <code data-v-084c8a36>[P]</code>, with
  <code data-v-084c8a36>X</code> on top, and then saves the top result element, say <code data-v-084c8a36>P(X)</code>.
  Then it executes
  <code data-v-084c8a36>[Q]</code>, again with <code data-v-084c8a36>X</code>, and saves the top result as
  <code data-v-084c8a36>Q(X)</code>. Finally it restores the stack to what it was below
  <code data-v-084c8a36>X</code> and pushes the two results <code data-v-084c8a36>P(X)</code> and
  <code data-v-084c8a36>Q(X)</code>.
  <p data-v-084c8a36>
    The <em data-v-084c8a36>ternary combinator</em>s expect three quotations on top of the stack. One
    of the most important is
  <pre data-v-084c8a36>        ifte
  </pre>
  The <kbd data-v-084c8a36>ifte</kbd> ("if-then-else") combinator performs branching. Its third
  parameter is the if-part, its second parameter is the then-part, its first parameter,
  on top, is the else-part. It executes the if-part, which must yield a truth value.
  It saves that value and restores the stack to what it was before the if-part was
  executed. If the saved value was <code data-v-084c8a36>true</code> the then-part is executed, otherwise
  the else-part is executed.
  <p data-v-084c8a36>
    There are two combinators for doing simple looping:
  <pre data-v-084c8a36>        whiledo    tailrec
  </pre>
  The binary <kbd data-v-084c8a36>whiledo</kbd> combinator is similar to the
  <code data-v-084c8a36>ifte</code> combinator in that it has a test, the while-part, which is second
  on the stack. The combinator repeatedly executes the while-part and while that yields
  <code data-v-084c8a36>true</code> it executes the other part, the do-part. The ternary <kbd data-v-084c8a36>tailrec</kbd>("tail-recursion") combinator also has a test, the third parameter. If that yields
  true, the second parameter is executed and the combinator exits, otherwise the top
  parameter is executed and after that the process is repeated.
  <p data-v-084c8a36>
    The <em data-v-084c8a36>quaternary combinator</em>s expect four quotations on top of the stack.
  <pre data-v-084c8a36>        linrec     binrec    genrec
  </pre>
  The <kbd data-v-084c8a36>linrec</kbd> combinator for <em data-v-084c8a36>linear recursion</em> expects an
  if-part, a then-part, an else1-part and on top an else2-part. Like the <code data-v-084c8a36>ifte</code>combinator it executes the if-part, and if that yields true it executes the else-part.
  Otherwise it executes the else1-part, then it recurses with all four parts, and finally
  it executes the else2-part. The <kbd data-v-084c8a36>binrec</kbd> combinator for
  <em data-v-084c8a36>binary recursion</em> is similar, except that the else1-part has to produce two
  values. The recursion with all four parts is executed an the two values separately.
  The else2-part then has available the two results from these two executions. The
  <kbd data-v-084c8a36>genrec</kbd> combinator for <em data-v-084c8a36>general recursion</em> is also has an if-part,
  a then-part and two else-parts.
  <p data-v-084c8a36>
    It differs from the other two combinators in that after the execution of the else1-part
    nothing in particular is executed, but a program consisting of the four parts and
    the combinator is pushed onto the stack. The else2-part thus has it available as
    a parameter.
  <p data-v-084c8a36>
    For linear recursion the if-part often is <code data-v-084c8a36>[null]</code> and the else1-part
    often is either <code data-v-084c8a36>[pred]</code> for numeric types or
    <code data-v-084c8a36>[uncons]</code> for aggregate types. The two parts are built into
  <pre data-v-084c8a36>        primrec
  </pre>
  for <em data-v-084c8a36>primitive recursion</em>. The binary <kbd data-v-084c8a36>primrec</kbd> combinator
  expects two quotations, a start-part (similar to the else-part of the earlier combinators)
  and a combine-part (similar to the else2-part of the earlier combinators. Below that
  it expects a value of any type. The combinator essentially supplies the other two
  parts.
  <p data-v-084c8a36>
    There are several combinators which do not have a fixed number of quotation parameters.
    Instead they use a list of quotations. They are
  <pre data-v-084c8a36>        cond    condlinrec
  </pre>
  The <kbd data-v-084c8a36>cond</kbd> combinator is like the one in Lisp, it is a generalisation
  of the <code data-v-084c8a36>ifte</code> combinator. It expects a non-empty list of programs, each
  consisting of a quoted if-part followed by a then-part. The various if-parts are
  executed until one is found that returns <code data-v-084c8a36>true</code>, and then its corresponding
  then-part is executed.
  <p data-v-084c8a36>
    The last program in the list is the default which is executed if none of the if-parts
    yield <code data-v-084c8a36>true</code>. The <kbd data-v-084c8a36>condlinrec</kbd> combinator is similar, it
    expects a list of pairs or triples of quoted programs. Pairs consist of an if-part
    and a then1-part, and triples have an additional then2-part. Again the first if-part
    that yields
    <code data-v-084c8a36>true</code> selects its corresponding then1-part for execution. If there
    is a then2-part, the combinator first recurses and then executes the then2-part.
    The last program is the default, it does not have an if-part.
  <p data-v-084c8a36>
    The <code data-v-084c8a36>cleave</code> combinator also has a generalisation:
  <pre data-v-084c8a36>        construct
  </pre>
  expects two parameters, a quotation and above that a list of quotations. Each
  quotation in the list will produce a value that will eventually be pushed onto the
  stack, and the first quotation determines the stack onto which these values will
  be pushed.
  <h1 data-v-084c8a36>Combinators for Simple Types</h1>
  Some combinators expect values of specific types below their quotation parameters.
  The combinators in this section expect values of simple types.
  <p data-v-084c8a36>
    The following binary combinator expects a truth value below its two quotation parameters:
  <pre data-v-084c8a36>        branch
  </pre>
  The <kbd data-v-084c8a36>branch</kbd> combinator resembles the <code data-v-084c8a36>choice</code> operator
  and the <code data-v-084c8a36>ifte</code> combinator. The truth value below the two quotations determines
  which of the two quotations will be executed. If the truth value is <code data-v-084c8a36>true</code>,
  then the if-part, the second parameter, is executed, otherwise the then-part, the
  top parameter, is executed.
  <p data-v-084c8a36>
    The following unary combinator expects a numeric value below its quotation parameter:
  <pre data-v-084c8a36>        times
  </pre>
  The <kbd data-v-084c8a36>times</kbd> combinator executes its quotation parameter as many times
  as indicated by the numeric value; if the value is zero or less, then the quotation
  is not executed at all.
  <h1 data-v-084c8a36>Combinators for Aggregate Types</h1>
  The combinators in this section expect aggregates below their quotation parameters.
  <p data-v-084c8a36>
    The stack is just a list, so any list could serve as the stack, including a list
    which happens to be on top of the stack. The following unary combinator expects
    a list below its quotation parameter:
  <pre data-v-084c8a36>        infra
  </pre>
  The <kbd data-v-084c8a36>infra</kbd> combinator temporarily discards the remainder of the
  stack and takes the list to be the stack. It then executes the quotation which yields
  a result stack. This result is then pushed as a list onto the original stack replacing
  the original list. Hence any quotation can serve as a complex unary operation on
  lists.
  <p data-v-084c8a36>
    The following unary combinator expects an aggregate below its quotation parameter:
  <pre data-v-084c8a36>        step
  </pre>
  The <kbd data-v-084c8a36>step</kbd> combinator removes the aggregate and the quotation, and
  then repeatedly puts the members of the aggregate on top of the remaining stack and
  executes the quotation. For sequential aggregates such as strings, lists or more
  generally, quotations, the members are selected in the order of their occurrance
  in the aggregate. For sets the members are selected on the basis of their underlying
  order. So the quotation is executed as many times as the aggregate has members. What
  happens to the members depends entirely on the quotation. In the simplest though
  unlikely case where the quotation does nothing, the members are left on the stack
  in the order in which they occurred in the aggregate with the last member on top.
  <p data-v-084c8a36>
    There is a related combinator for stepping through two aggregates:
  <pre data-v-084c8a36>        step2
  </pre>
  The <kbd data-v-084c8a36>step2</kbd> expects two aggregates which do not have to be of the
  same type. Above that it expects a quotation. It steps through the lower aggregate
  and for each member it steps through the higher aggregate. The pairs of members are
  then made available to the quoted program. If the aggregates have <tt data-v-084c8a36>M</tt> and
  <tt data-v-084c8a36>N</tt> members, there will be <tt data-v-084c8a36>M
  × N</tt> pairs.
  <p data-v-084c8a36>
    The following combinators for aggregates are mostly familiar from list processing
    languages:
  <pre data-v-084c8a36>        map    fold     filter     split
  </pre>
  All four step through the members of the aggregate in the same manner as the
  <code data-v-084c8a36>step</code> combinator. The <kbd data-v-084c8a36>map</kbd> combinator combines the results
  of applying the quotation to create a new aggregate of the same type as the original.
  The <kbd data-v-084c8a36>fold</kbd> combinator expects a quotation which computes a binary function,
  below that a value, the <em data-v-084c8a36> initial</em> value, and below that an aggregate. It
  uses the binary function to combine the members of the aggregate into one single
  value, and if the aggregate happens to be empty it returns the initial value.
  <p data-v-084c8a36>
    The <kbd data-v-084c8a36>filter</kbd> combinator needs a quotation which computes a truth value,
    so it is a test. It applies the test to each member of the aggregate and creates
    a new aggregate containing those members of the original which pass the test. The
    resulting aggregate is of the same types as the parameter. The <kbd data-v-084c8a36>split</kbd>  combinator only makes sense in a language in which a function can return two values.
  <p data-v-084c8a36>
    It is like the <code data-v-084c8a36>filter</code> combinator except that it returns two aggregates
    - one containing the members of the original which did not pass the test, and above
    that another containing those which did pass the test. The resulting aggregates
    are of the same type as the parameter. In both result aggregates the ordering of
    the original aggregate is preserved in case they are strings or lists.
  <p data-v-084c8a36>
    The following unary combinators expect an aggregate below their quotation parameter
    which must compute a truth value:
  <pre data-v-084c8a36>        some    all
  </pre>
  The <kbd data-v-084c8a36>some</kbd> combinator returns <code data-v-084c8a36>true</code> if some members of
  the aggregate pass the test of the quotation, otherwise it returns <code data-v-084c8a36>false</code>.
  The <kbd data-v-084c8a36>all</kbd> combinator returns
  <code data-v-084c8a36>true</code> if all members of the aggregate pass the test of the quotation,
  otherwise it returns <code data-v-084c8a36>false</code>. For empty aggregates <code data-v-084c8a36>some</code> returns
  <code data-v-084c8a36>false</code> and
  <code data-v-084c8a36>all</code> returns <code data-v-084c8a36>true</code>.
  <p data-v-084c8a36>
    The following unary combinator expects two aggregates and above that a program suitable
    for combining their respective elements:
  <pre data-v-084c8a36>        zipwith
  </pre>
  The <kbd data-v-084c8a36>zipwith</kbd> combinator produces a list which is as long as the
  smaller of the two aggregate parameters. The elements of the resultlist are obtained
  by using the program parameter to combine corresponding members of the two aggregates.
  <p data-v-084c8a36>
    The following unary combinators expect a program and below that a tree:
  <pre data-v-084c8a36>        treestep    treemap    treefilter    treefold
  </pre>
  They all resemble corresponding combinators for aggregates. The
  <kbd data-v-084c8a36>treestep</kbd> combinator uses the program to process the leaf nodes in the
  same way as <code data-v-084c8a36>step</code> handles members of an aggregate. The <kbd data-v-084c8a36>treemap</kbd>combinator uses the program to compute replacement leaves for a tree which has the
  same structure. The <kbd data-v-084c8a36>treefilter</kbd> combinator needs a program that yields
  a truth value, it produces a tree of only those leaves which pass the test. The <kbd data-v-084c8a36>treefold</kbd>combinator expects an <em data-v-084c8a36> initial</em> value above the tree and above that the quotation
  which is used to combine the leaves with the initial value.
  <p data-v-084c8a36>
    There are two tree combinators which are similar to the
    <code data-v-084c8a36>genrec</code> combinator:
  <pre data-v-084c8a36>        treerec    treerecgen
  </pre>
  and above that two quotations, <code data-v-084c8a36>[O]</code> and <code data-v-084c8a36>[C]</code>. If the
  tree is a leaf, then <code data-v-084c8a36>[O]</code> is executed, typically an operation on a leaf.
  If the tree is not a leaf, then then combinator
  <code data-v-084c8a36>[C]</code> is executed, and it will find on top of the stack the program <code data-v-084c8a36>[[O] [C] treerec]</code>.
  The slightly more general
  <kbd data-v-084c8a36>treerecgen</kbd> combinator also expects a tree but above that three quotations:
  <code data-v-084c8a36>[O1]</code>, <code data-v-084c8a36>[O2]</code> and
  <code data-v-084c8a36>[C]</code>. If the tree is a leaf, then <code data-v-084c8a36>[O1]</code> is executed. If it
  is not a leaf, then first <code data-v-084c8a36>[O2]</code> is executed, and then the combinator
  <code data-v-084c8a36>[C]</code> is executed which will find <code data-v-084c8a36>[[O1] [O2] [C] treerecgen]</code>on top of the stack.
  <hr data-v-084c8a36></article></div></main><footer data-v-c785faa8><p data-v-c785faa8><a href="https://github.com/joy-language/joy-lang.org" data-v-c785faa8>GitHub</a></footer></div></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{},{}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.10669f42b2e188f55eb1.js"></script><script defer src="/_nuxt/layouts/default.29c0e08e13310e3682fc.js"></script><script defer src="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js"></script><script defer src="/_nuxt/pages/papers-on-joy/atomic-programs-of-joy.f2cb1414ae2b6ed9401e.js"></script><script defer src="/_nuxt/vendor.230cb916d1973aa790f3.js"></script><script defer src="/_nuxt/app.0a856c7cf6fb3e349fa2.js"></script>
  

