<!DOCTYPE html>
<html data-n-head="" data-n-head-ssr>
  <head>
    <meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Joy Programming Language" name="description" data-hid="description"><title data-n-head="true">Joy language</title><link href="https://fonts.googleapis.com/css?family=Fira+Sans:200,500|Roboto:400|Roboto+Mono:400" rel="stylesheet" data-n-head="true"><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/favicon.ico?" rel="shortcut icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.10669f42b2e188f55eb1.js" rel="preload" as="script"><link href="/_nuxt/vendor.230cb916d1973aa790f3.js" rel="preload" as="script"><link href="/_nuxt/app.0a856c7cf6fb3e349fa2.js" rel="preload" as="script"><link href="/_nuxt/layouts/default.29c0e08e13310e3682fc.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/the-annoying-quadratic-formula.a3d9ef30d4f74df89dfd.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/survey-of-reproducing-programs.ed8409adcfb2bdec6eeb.js" rel="prefetch"><link href="/_nuxt/pages/libraries-and-c-sources.d2ffa370ff989df9d359.js" rel="prefetch"><link href="/_nuxt/pages/index.73b5e04f9a3fcda5b5fe.js" rel="prefetch"><link href="/_nuxt/pages/about.a3431c5910b96e7d0298.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-algebra-of-joy.7f385b55e84045676f24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/church-arithmetic-and-church-logic-with-brent-kirby.e11588a1a251690d41af.js" rel="prefetch"><link href="/_nuxt/pages/rationale-for-joy.3e067852511f512169f0.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/tutorial-on-joy.9a4df70c3d63708c2b23.js" rel="prefetch"><link href="/_nuxt/pages/overview-of-joy.8733ad0cbce5d065d604.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/miscellaneous-miniature-implementations-of-joy.417498df53623dd27f3a.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/fast-small-truth-tables.9b1b75741215fa7afac3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/programming-in-joy.d4bc3bc57b9855085dc1.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-matrix-multiplication-programs.8e00ebe2e6e430523681.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/imperative-thinking-for-joy-programs.223ec58c271bc7112421.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-a-joy-interpreter-written-in-joy.eaa748fa0ea2130e1164.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/joy-compared-with-other-functional-languages.e9b1e34a3b81758a64f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/recursion-theory-and-joy.7d268252a6e6c71fa9f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/nested-recursion-and-a-new-recursion-combinator.d40eac9bf6ad0e5cac92.js" rel="prefetch"><link href="/_nuxt/pages/faq.9ffdbd52d27b2df75f94.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/mathematical-foundations-of-joy.4f0b584e560cf803bb24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/floy-a-flat-concatenative-subset-of-joy.9162d7b51e29e1b5b1b9.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/html-manual.e3473b0453170639a088.js" rel="prefetch"><link href="/_nuxt/pages/faq-part-2.9630745e3aaebc47633f.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/lazy-lists-as-reproducing-programs.9516d2d5134cfed90ce3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-current-implementation.e033c23017443bc35c24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/a-rewriting-system-for-joy.4157d6f1ef190fb675ea.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/atomic-programs-of-joy.f2cb1414ae2b6ed9401e.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/prospectus-for-john-cowans-joy1.cb4661329c1ed2df6752.js" rel="prefetch"><style data-vue-ssr-id="d505b096:0">html{font-family:Roboto,Arial,sans-serif;margin:0;font-weight:400;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box}body{margin:0;height:100%}:after,:before,:not(pre){-webkit-box-sizing:border-box;box-sizing:border-box;margin:0}.wrapper{min-height:calc(100vh - 102px)}a{color:#3273dc;text-decoration:none}a:hover{text-decoration:underline}</style><style data-vue-ssr-id="6cc65792:0">nav[data-v-251e63b6]{background-color:#000}ul[data-v-251e63b6]{list-style-type:none;padding:0;margin:0}li[data-v-251e63b6]{-webkit-transition:all .2s ease-out;transition:all .2s ease-out;display:inline-block;padding:0;cursor:pointer}li[data-v-251e63b6]:hover{-webkit-transform:scale(1.04);transform:scale(1.04);background-color:#fff;color:#000}li a[data-v-251e63b6]{display:block;padding:15px 25px;text-decoration:none;color:#fff;text-align:center}li:hover a[data-v-251e63b6]{color:#000}.nuxt-link-exact-active[data-v-251e63b6]{text-decoration:overline}</style><style data-vue-ssr-id="23d2604d:0">h1[data-v-7e83a563]{font-size:26px}.lists[data-v-7e83a563]{margin-top:37px;padding-left:12vw;padding-right:12vw}.top-list-item[data-v-7e83a563]{margin-top:11px}li[data-v-7e83a563]{line-height:39px}.no-style-litem[data-v-7e83a563]{list-style-type:none}ul[data-v-7e83a563]{list-style-type:circle}h6[data-v-7e83a563]{font-size:17px}p[data-v-7e83a563]{margin-top:8px;line-height:24px;font-size:16px}</style><style data-vue-ssr-id="2cd3ee5d:0">p[data-v-f740c3da]{margin-top:16px;margin-bottom:16px}hr[data-v-f740c3da]{margin-bottom:16px}pre[data-v-f740c3da]{margin-bottom:auto}code[data-v-f740c3da],kbd[data-v-f740c3da],pre[data-v-f740c3da]{font-family:Roboto Mono,monospace}</style><style data-vue-ssr-id="ca9343dc:0">footer[data-v-c785faa8]{padding:11px 20px 0;height:52px}p[data-v-c785faa8]{-webkit-transition:all .1s ease-in;transition:all .1s ease-in;font-size:15px;float:right;margin:0 16px}a[data-v-c785faa8]{color:#000;text-decoration:none}p[data-v-c785faa8]:hover{-webkit-transform:scale(.94);transform:scale(.94);color:#000;-webkit-text-decoration:#3273dc overline;text-decoration:#3273dc overline}</style>
  </head>
  <body data-n-head="">
    <div id="__nuxt" data-server-rendered="true"><div id="__layout"><div class="container" lang="en"><nav data-v-251e63b6 role="navigation"><ul data-v-251e63b6><li data-v-251e63b6><a href="/" data-v-251e63b6 class="nuxt-link-active">Home</a><li data-v-251e63b6><a href="/papers-on-joy" data-v-251e63b6 class="nuxt-link-active">Papers</a><li data-v-251e63b6><a href="/libraries-and-c-sources" data-v-251e63b6>Libraries/C sources</a><li data-v-251e63b6><a href="/about" data-v-251e63b6>About</a></ul></nav><main class="lists" data-v-7e83a563><div data-v-7e83a563><article data-v-f740c3da data-v-7e83a563 data-v-7e83a563><p data-v-f740c3da>
    14-FEB-05
  <p data-v-f740c3da><em data-v-f740c3da>Abstract:</em> Complex expressions can be difficult to evaluate in Joy and
    in other stack-based languages, especially when some of the parameters are needed
    repeatedly for the computation of intermediate values. This note describes some
    techniques that can be valuable in such cases. The example used is the quadratic
    formula.
  <p data-v-f740c3da>
    An equation of the form a * x^2 + b * x + c = 0 has either no solution in the reals,
    or it has two solutions in the reals ("not necessarily distinct" as they say).
    The solutions, if any, are given by
  <pre data-v-f740c3da>             -b  +/- sqrt(b^2 - 4 * a * c)
               -----------------------------
                          2 * a
  </pre>
  R. Kent Dybvig, The SCHEME Programming Languagage, 1987, p 44, gives the following
  definition
  <pre data-v-f740c3da>        (define quadratic-formula
             (lambda (a b c)
                (let ([minusb (0 - b)]
                      [radical (sqrt (- (* b b) (* 4 ( * a c))))]
                      [divisor (* 2 a)] )
                   let ([root1 (/ (+ minusb radical) divisor)]
                        [root2 (/ (- minusb radical) divisor)])
                     (cons root1 root2)))))
  </pre>
  For a = 2, b = -4, c = -6 the solutions are x = 3 and x = -1, and the programs
  gives the solutions in the form of a (dotted) pair:
  <pre data-v-f740c3da>         (quadratic-formula 2 -4 -6)  =>  (3 . -1)
  </pre>
  Dybvig remarks (p 45):
  <pre data-v-f740c3da>      ".. by employing two let expressions, the definition makes
         clear the dependency of root1 and root2 on the values of
         minusb, radical, and divisor. Equally important, the let
         expressions make clear the lack of dependencies among minusb, 
         radical, and divisor and between root1 and root2."      
  </pre>
  The remainder of this note is concerned with writing a program in Joy which
  does the same thing, using the Scheme program as a model. The general plan is to
  develop some constructions in Joy which can play the same role as the let-expressions
  in Scheme (or other languages).
  <p data-v-f740c3da>
    The simplest let-expressions are those in which only a single expression is evaluated
    and given a name, which is then available in the body:
  <pre data-v-f740c3da>        (let ([name expression])
               ( body ))                      
  </pre>
  In Joy there is no name to be given to the value of the expression, but the
  value of the expression can be pushed on top of the stack by the nullary combinator:
  <pre data-v-f740c3da>        [expression] nullary  body
  </pre>
  The nullary combinator executes the quotation on top on the remainder of the
  stack, possibly consuming several values, and then restores that remainder and pushes
  whatever top value the execution of the quotation had produced.
  <p data-v-f740c3da>
    But this is of no use for multiple let-expressions in which there are several names
    to be defined independently, as in the first half of the Scheme program in which
    three names are defined, or in the second half in which two are defined.
  <p data-v-f740c3da>
    The effect of multiple let-expressions can be simulated in Joy by a simple but very
    useful device. The aim is to compute several values independently which are to
    be used later. In Joy these values are anomymous. The general pattern is
  <pre data-v-f740c3da>        [[..] [..] [..]]  [i]  map
  </pre>
  This is perhaps a surprising use of the map combinator. In all cases the map
  combinator expects on top of the stack a single quotation and in most cases below
  that a list or other aggregate of values. But map can also handle the case where
  that list is a list of quotations to be executed. If the single quotation is [i],
  the the quoted i combinator will execute each of the three listed quotations and
  the map combinator assembles these into a list of the three values that were on top
  of the stack at the end of the three executions. Note that the three result values
  are computed independently of each other, and each of the three computations can
  modify the stack in any way, and after each of the three computations the original
  stack below the list of three quotations is restored. It is these three properties
  that make the device useful for structuring Joy programs.
  <p data-v-f740c3da>
    In many cases the three values that have been computed from the three quotations
    are required not as a single list on top of the stack but as three independent
    values. Of course it is easy enough to decompose the list, in the present case
    by
  <pre data-v-f740c3da>        uncons  uncons  uncons  pop
  </pre>
  This will work even in the rare case where the result list contains operators,
  as in [2 + 3]. But the sequence of uncons'es is clumsy, especially if the list is
  long. It would be preferable to use some code which decomposes the list independently
  of its length. One device is the step combinator, which expects a quotations and
  below that a list or other aggregate. It successively puts the elements of the list
  onto the stack and executes the quotation. The top value after each of the executions
  is pushed onto the stack. In the present case the required quotation [], which does
  nothing. So, for example,
  <pre data-v-f740c3da>    1 2 3 [[pop dup *] [+] [2 *]]  [i] map  [] step
  </pre>
  will leave 1 2 3 4 5 6 on top of the stack, the 6 topmost, after producing
  the list [4 5 6] just after the map.
  <p data-v-f740c3da>
    Applying these constructions mechanically to the nested multiple let-expressions
    in the Scheme program results in the following definition in Joy:
  <pre data-v-f740c3da>DEFINE
      quadratic-1  ==                                # a b c => [root1 root2 ]
          [ [ pop pop 2 * ]                          # divisor
            [ pop 0 swap - ]                         # minusb
            [ swap dup * rollup * 4 * - sqrt ] ]     # radical
          [i] map [] step
          [ [ + swap / ]                             # root1
            [ - swap / ] ]                           # root2
          [i] map  [] step
          [] cons cons                               # build pair
          [ pop pop pop pop pop pop ] dip.           # cleanup stack
  </pre><p data-v-f740c3da>
    But the program is unsatisfactory for a number of reasons:
  <p data-v-f740c3da>
    1. Most glaringly, in line 7 the list of two roots is decomposed by [] step. But
    then in line 8 the two roots are recomposed to a list. So, the final [] step in
    line 7, and all of line 8 should be deleted.
  <p data-v-f740c3da>
    2. In line 4 the list of three intermediate values is also decomposed by [] step.
    Just like a sequence of uncons operations, this will work even in the rare case
    where the list contains operators, as in [2 + swap]. But in the case of the quadratic
    formula the list of intermediate values is just a normal list of literals, namely
    numbers. Because of that it is possible to decompose the list by just the i combinator,
    which will do the same job simpler and also more efficiently.
  <p data-v-f740c3da>
    3. In line 9 the six pops remove the three parameters (a b c) and the three inttermeddiate
    values (divisor minusb radical). A language such as Scheme need not (and cannot)
    explicitly express the disappearancce of these values. But the three parameters
    are no longer needed in the computation of the two roots from the three intermediate
    values. And yet, during that computation the three parameters are still visible.
    But is only by inspecting the code for the computations that it becomes apparent
    that the parameters are not used directly. In Scheme the independence is not (and
    cannot be) expressed explicitly. But it can be expressed in Joy. The three (dipped)
    pops for the three parameters can occur as soon as they are no longer needed, and
    that is immediately after the first map. Similarly the three (dipped) pops for
    the three intermediate values can occur after the second map. But when the number
    of pops is small (three in this case) we can do better than [pop pop pop] dip.
    The combinators nullary, unary, binary and ternary are normally used to ensure
    that a quoted program does not consume more than 0, 1, 2 or 3 values from the stack.
    They can also be used to ensure that exactly that many are consumed. So the two
    lots of three pops can both be expressed by the ternary combinator.
  <pre data-v-f740c3da>DEFINE
      quadratic-2  ==                                # a b c => [root1 root2 ]
          [ [ [ pop pop 2 * ]                        # divisor
              [ pop 0 swap - ]                       # minusb
              [ swap dup * rollup * 4 * - sqrt ] ]   # radical
            [i] map ]
          ternary i
          [ [ [ + swap / ]                           # root1
              [ - swap / ] ]                         # root2
            [i] map ]
          ternary.
  </pre><p data-v-f740c3da>
    This version of the program is the best of the three in this note. It has now been
    added to the numlib.joy standard library.
  <p data-v-f740c3da>
    There is another device which sometimes can be useful, especially when the number
    of pops is larger than can be handled by a single combinator such as ternary. This
    might arise if the number of intermediate values is large, and they have been computed
    as a list, most probably by [i] map. In such a case that very same list can be
    used as the (temporary) stack for the following computations. The combinator infra
    expects a list and above that a quotation. It will treat the list as the stack
    and execute the quotation using that stack. It will return the modified list on
    top of the regular stack. In the present program for the quadratic formula, after
    the three intermediate values have been computed as a list, the remaining computation
    for the two roots can be done under the control of the infra combinator. Note that
    this is in the last line of the program below. When that returns, the required
    final value will be what is on top of this temporary stack, which the first element
    on the list, and that can be extracted with the first operator. The remaining intermediate
    values thereby disappear, no matter how many there were. The device is an overkill
    in the present case for the quadratic formula, but it can be useful elsewhere.
  <p data-v-f740c3da>
    The device can also be used when instead several parameters there is only one, but
    it is a possibly long list of values. This situation does not obtain in the present
    case, but we can make it so by a chain of three conses into an initially empty
    list. This is only done in the program below to enable the first use of the infra
    combinator. So the following illustrates the use of the infra combinator twice,
    once for computing the intermediate values, and once for computing the final result.
    The first use relied on the ugly chain of conses at the beginninng, and would not
    really be recommended. But the second use would be a reasonable and more widely
    useful alternative to the ternary combinator. Note also that because of the infra
    combinator some of the order of computations needed to be different from the preceding
    program.
  <pre data-v-f740c3da>DEFINE
      quadratic-3  ==                                # a b c => [root1 root2 ]
          [] cons cons cons                          # list of parameters
          [ [ [ [dup * swap] dip * 4 * - sqrt ]      # radical
              [ pop 0 swap - ]                       # minusb
              [ 2 * ] ]                              # divisor
            [i] map ]
          infra first
          [ [ [ + swap / ]                           # root1
              [ - swap / ] ]                         # root2
            [i] map ]
          infra first.
  </pre><hl2 data-v-f740c3da>
    Postscript: Combinators as parameters to other combinators
    <p data-v-f740c3da>
      The construction [i] map is only one of many others of the form [C] map, where C
      is a combinator. This can be useful when C is a combinator other than i. Note
      that these two are equivalent:
    <pre data-v-f740c3da>        [  [..]     [..]  ]  [..]    ]    [C]  map
          [ [[..] C] [[..] C] [[..] C] ]    [i]  map
  </pre>
    In a way the C distributes from the right (inside the [C]) over the quotations.
    An example would be
    <pre data-v-f740c3da>        [1 2 3 4]  [[even] [2 >]]  [filter]  map
  </pre>
    which leaves [[2 4] [3 4]] on top of the stack, with the original [1 2 3
    4] just below.
    <p data-v-f740c3da>
      Constructions in which combinators take other combinators as parameter have not been
      explored much in Joy. Another example, with two quoted combination parameters
      is the first program below, which is equivalent to the second:
    <pre data-v-f740c3da>        [even]  [pop size 5 >]  [       filter]  [       map]  ifte
                  [    size 5 >]  [[even] filter]  [[even] map]  ifte
  </pre>
    Both programs expect a list (or set) of numbers, and, for lists of more than
    5 members they return a list of the even numbers, and for shorter lists they return
    a list of as many truth values, depending on whether the corresponding number is
    even or not. In this example the quotation [even] distributes from the right into
    the then-part end the else-part.
  </hl2></article></div></main><footer data-v-c785faa8><p data-v-c785faa8><a href="https://github.com/joy-language/joy-lang.org" data-v-c785faa8>GitHub</a></footer></div></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{},{}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.10669f42b2e188f55eb1.js"></script><script defer src="/_nuxt/layouts/default.29c0e08e13310e3682fc.js"></script><script defer src="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js"></script><script defer src="/_nuxt/pages/papers-on-joy/the-annoying-quadratic-formula.a3d9ef30d4f74df89dfd.js"></script><script defer src="/_nuxt/vendor.230cb916d1973aa790f3.js"></script><script defer src="/_nuxt/app.0a856c7cf6fb3e349fa2.js"></script>
  

