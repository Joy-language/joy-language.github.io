<!DOCTYPE html>
<html data-n-head="" data-n-head-ssr>
  <head>
    <meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Joy Programming Language" name="description" data-hid="description"><title data-n-head="true">Joy language</title><link href="https://fonts.googleapis.com/css?family=Fira+Sans:200,500|Roboto:400|Roboto+Mono:400" rel="stylesheet" data-n-head="true"><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/favicon.ico?" rel="shortcut icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.10669f42b2e188f55eb1.js" rel="preload" as="script"><link href="/_nuxt/vendor.230cb916d1973aa790f3.js" rel="preload" as="script"><link href="/_nuxt/app.0a856c7cf6fb3e349fa2.js" rel="preload" as="script"><link href="/_nuxt/layouts/default.29c0e08e13310e3682fc.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/programming-in-joy.d4bc3bc57b9855085dc1.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/survey-of-reproducing-programs.ed8409adcfb2bdec6eeb.js" rel="prefetch"><link href="/_nuxt/pages/libraries-and-c-sources.d2ffa370ff989df9d359.js" rel="prefetch"><link href="/_nuxt/pages/index.73b5e04f9a3fcda5b5fe.js" rel="prefetch"><link href="/_nuxt/pages/about.a3431c5910b96e7d0298.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-algebra-of-joy.7f385b55e84045676f24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-annoying-quadratic-formula.a3d9ef30d4f74df89dfd.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/church-arithmetic-and-church-logic-with-brent-kirby.e11588a1a251690d41af.js" rel="prefetch"><link href="/_nuxt/pages/rationale-for-joy.3e067852511f512169f0.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/tutorial-on-joy.9a4df70c3d63708c2b23.js" rel="prefetch"><link href="/_nuxt/pages/overview-of-joy.8733ad0cbce5d065d604.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/miscellaneous-miniature-implementations-of-joy.417498df53623dd27f3a.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/fast-small-truth-tables.9b1b75741215fa7afac3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-matrix-multiplication-programs.8e00ebe2e6e430523681.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/imperative-thinking-for-joy-programs.223ec58c271bc7112421.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-a-joy-interpreter-written-in-joy.eaa748fa0ea2130e1164.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/joy-compared-with-other-functional-languages.e9b1e34a3b81758a64f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/recursion-theory-and-joy.7d268252a6e6c71fa9f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/nested-recursion-and-a-new-recursion-combinator.d40eac9bf6ad0e5cac92.js" rel="prefetch"><link href="/_nuxt/pages/faq.9ffdbd52d27b2df75f94.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/mathematical-foundations-of-joy.4f0b584e560cf803bb24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/floy-a-flat-concatenative-subset-of-joy.9162d7b51e29e1b5b1b9.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/html-manual.e3473b0453170639a088.js" rel="prefetch"><link href="/_nuxt/pages/faq-part-2.9630745e3aaebc47633f.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/lazy-lists-as-reproducing-programs.9516d2d5134cfed90ce3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-current-implementation.e033c23017443bc35c24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/a-rewriting-system-for-joy.4157d6f1ef190fb675ea.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/atomic-programs-of-joy.f2cb1414ae2b6ed9401e.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/prospectus-for-john-cowans-joy1.cb4661329c1ed2df6752.js" rel="prefetch"><style data-vue-ssr-id="d505b096:0">html{font-family:Roboto,Arial,sans-serif;margin:0;font-weight:400;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box}body{margin:0;height:100%}:after,:before,:not(pre){-webkit-box-sizing:border-box;box-sizing:border-box;margin:0}.wrapper{min-height:calc(100vh - 102px)}a{color:#3273dc;text-decoration:none}a:hover{text-decoration:underline}</style><style data-vue-ssr-id="6cc65792:0">nav[data-v-251e63b6]{background-color:#000}ul[data-v-251e63b6]{list-style-type:none;padding:0;margin:0}li[data-v-251e63b6]{-webkit-transition:all .2s ease-out;transition:all .2s ease-out;display:inline-block;padding:0;cursor:pointer}li[data-v-251e63b6]:hover{-webkit-transform:scale(1.04);transform:scale(1.04);background-color:#fff;color:#000}li a[data-v-251e63b6]{display:block;padding:15px 25px;text-decoration:none;color:#fff;text-align:center}li:hover a[data-v-251e63b6]{color:#000}.nuxt-link-exact-active[data-v-251e63b6]{text-decoration:overline}</style><style data-vue-ssr-id="23d2604d:0">h1[data-v-7e83a563]{font-size:26px}.lists[data-v-7e83a563]{margin-top:37px;padding-left:12vw;padding-right:12vw}.top-list-item[data-v-7e83a563]{margin-top:11px}li[data-v-7e83a563]{line-height:39px}.no-style-litem[data-v-7e83a563]{list-style-type:none}ul[data-v-7e83a563]{list-style-type:circle}h6[data-v-7e83a563]{font-size:17px}p[data-v-7e83a563]{margin-top:8px;line-height:24px;font-size:16px}</style><style data-vue-ssr-id="c5b0859a:0">p[data-v-7c2d3108]{margin-top:16px;margin-bottom:16px}hr[data-v-7c2d3108]{margin-bottom:16px}pre[data-v-7c2d3108]{margin-bottom:auto}code[data-v-7c2d3108],kbd[data-v-7c2d3108],pre[data-v-7c2d3108]{font-family:Roboto Mono,monospace}</style><style data-vue-ssr-id="ca9343dc:0">footer[data-v-c785faa8]{padding:11px 20px 0;height:52px}p[data-v-c785faa8]{-webkit-transition:all .1s ease-in;transition:all .1s ease-in;font-size:15px;float:right;margin:0 16px}a[data-v-c785faa8]{color:#000;text-decoration:none}p[data-v-c785faa8]:hover{-webkit-transform:scale(.94);transform:scale(.94);color:#000;-webkit-text-decoration:#3273dc overline;text-decoration:#3273dc overline}</style>
  </head>
  <body data-n-head="">
    <div id="__nuxt" data-server-rendered="true"><div id="__layout"><div class="container" lang="en"><nav data-v-251e63b6 role="navigation"><ul data-v-251e63b6><li data-v-251e63b6><a href="/" data-v-251e63b6 class="nuxt-link-active">Home</a><li data-v-251e63b6><a href="/papers-on-joy" data-v-251e63b6 class="nuxt-link-active">Papers</a><li data-v-251e63b6><a href="/libraries-and-c-sources" data-v-251e63b6>Libraries/C sources</a><li data-v-251e63b6><a href="/about" data-v-251e63b6>About</a></ul></nav><main class="lists" data-v-7e83a563><div data-v-7e83a563><article data-v-7c2d3108 data-v-7e83a563 data-v-7e83a563><i data-v-7c2d3108> By Manfred von Thun </i><h1 data-v-7c2d3108> Introduction </h1>
  This paper shows how to write simple programs in Joy. Since Joy is very different
  from familiar programming languages, it takes a while to become used to writing programs
  in Joy. One way to start the learning process is by way of writing some simple generally
  useful library programs. In an implementation these may be part of an actual library,
  or they may be built into the language.
  <p data-v-7c2d3108>
    Some general <em data-v-7c2d3108>utility program</em>s include operators for manipulating the Joy
    stack just below the top element, further operators for manipulating aggregate
    values, and a few output programs. Generally useful are the
    <em data-v-7c2d3108>stack type</em> and the
    <em data-v-7c2d3108>queue type</em>. Values and operators of these two types are easily implemented
    as Joy lists and list operators.
  <p data-v-7c2d3108>
    Another collection of useful operators take an aggregate as parameter and produce
    a list of subaggregates. These operators are <em data-v-7c2d3108>polymorphic</em> in the sense
    that the aggregate parameter can be a (small) set, a string, or a list. For example,
    one such operator can take a set as parameter and produces a list of its subsets.
    All of these operators are definable without recursion by using the <kbd data-v-7c2d3108>linrec</kbd>  combinator.
  <p data-v-7c2d3108>
    Some <em data-v-7c2d3108>arithmetic operator</em>s are often used to illustrate recursive definitions,
    although it is well known that iterative execution is more efficient. In particular
    the use of <em data-v-7c2d3108>accumulating parameter</em>s can often replace recursion. This is
    easily done in Joy using various iteration combinators.
  <p data-v-7c2d3108>
    Values of <em data-v-7c2d3108>sequence type</em>s, such as strings and lists, can be sorted, and
    sorted sequences can be merged. Programs for doing this are easily written in Joy
    without recursive definitions but using appropriate combinators instead.
  <p data-v-7c2d3108>
    Joy's inbuilt <em data-v-7c2d3108>set type</em> is implemented just as bitstrings, and hence it
    is limited to small sets of small numbers. The more useful <em data-v-7c2d3108>big set type</em>,
    which allows large sets of elements of any type, can be implemented in any language
    which has lists. It is simple to do in Joy, and the usual set-theoretic operations
    are easily provided. A similar implementation can be used for the <em data-v-7c2d3108>dictionary type</em>,
    which uses lookup tables for finite functions.
  <p data-v-7c2d3108>
    Also useful is the <em data-v-7c2d3108>tree type</em>, of lists, or lists of lists, or lists of
    lists of lists ... of elements other than lists.
  <p data-v-7c2d3108>
    The remainder of this paper illustrates programming in Joy by way of simple examples.
    Many of the programs are first written in pseudo-code and the translated into Joy.
    Some of the Joy programs here have been adapted from the literature on ML or Miranda\footnote{"Miranda"
    is a trademark of Research Software Ltd}. The next section defines some useful
    general purpose operators and combinators. This is followed by a section on two
    little collections of operators for two datatypes, stacks and queues. A longer
    section deals with programs for creating and manipulating lists of subaggregates.
    A shorter section then illustrates the use of accumulating parameters for the efficient
    implementation of numeric functions. Then there is another section on sorting sequences
    and on merging sorted sequences. Another section gives an implementation of unrestricted
    sets and of lookup dictionaries.
  <h1 data-v-7c2d3108>Utility operators and combinators</h1><p data-v-7c2d3108>
    This section describes some very simple utilities which are useful in very different
    settings. Joy definitions are of the form
  <pre data-v-7c2d3108>        ATOM   ==   PROGRAM
  </pre>
  where the long equals <kbd data-v-7c2d3108>==</kbd> means that the atom on the left is being
  defined to cause the execution of the program on the right.
  <p data-v-7c2d3108>
    Joy has three important operations for manipulating the top few items of the stack:
    <kbd data-v-7c2d3108>pop</kbd> for removing the top item,
    <kbd data-v-7c2d3108>dup</kbd> for creating a copy of the top item, and <kbd data-v-7c2d3108>swap</kbd> for interchanging
    the top two items. Often it is necessary to perform similar operations further
    below the stack. The following define three similar operators which leave the top
    element of the stack intact and perform the work just below that. All three use
    the <kbd data-v-7c2d3108>dip</kbd> combinator which takes as a parameter a quoted program and below
    that a further item. The item is saved, the quoted program is executed and the
    item then restored.
  <pre data-v-7c2d3108>        popd   ==  [pop ] dip
          dupd   ==  [dup ] dip
          swapd  ==  [swap] dip
  </pre>
  The <kbd data-v-7c2d3108>popd</kbd> operator removes the second item. The <kbd data-v-7c2d3108>dupd</kbd>operator duplicates the second item. The <kbd data-v-7c2d3108>swapd</kbd> operator interchanges the
  second and third item.
  <p data-v-7c2d3108>
    Three similar operators affect the order of the top three items on the stack. The
    <kbd data-v-7c2d3108>rollup</kbd> operator places items one, two and three from the top in the
    order two, three, one. The <kbd data-v-7c2d3108>rolldown</kbd> operator places items one, two and
    three in the order three, one, two. The <kbd data-v-7c2d3108>rotate</kbd> operator places them
    in the order three, two, one.
  <pre data-v-7c2d3108>        rollup     ==  swap [swap] dip
          rolldown   ==  [swap] dip swap
          rotate     ==  swap [swap] dip swap
  </pre><p data-v-7c2d3108>
    The next examples are for <em data-v-7c2d3108>unary operator</em>s which expect an item on the
    stack and replace it with either a set or a string or a list containing just that
    item. All three operators work by first pushing The <em data-v-7c2d3108> empty set </em><kbd data-v-7c2d3108> {} </kbd>  or the <em data-v-7c2d3108>empty string</em><kbd data-v-7c2d3108>""</kbd> or the <em data-v-7c2d3108>empty list</em><kbd data-v-7c2d3108>[]</kbd>}
    on top of the stack. Then they use the <kbd data-v-7c2d3108>cons</kbd> operation to add the item
    below into the aggregate. The items have to be of the right type. The <kbd data-v-7c2d3108>unitset</kbd>  operator requires a small number, the <kbd data-v-7c2d3108>unitstring</kbd> operator requires a
    character, and the <kbd data-v-7c2d3108>unitlist</kbd> operator requires anything. If the items
    are not of the right type, an error occurs when the <code data-v-7c2d3108>cons</code> is executed.
  <pre data-v-7c2d3108>        unitset     ==  {} cons
          unitstring  ==  "" cons
          unitlist    ==  [] cons
  </pre>
  The action of all three is reversed by the single standard operator
  <kbd data-v-7c2d3108>first</kbd>.
  <p data-v-7c2d3108>
    Analogously one may define three operators
    <kbd data-v-7c2d3108>pairset</kbd>, <kbd data-v-7c2d3108>pairstring</kbd> and <kbd data-v-7c2d3108>pairlist</kbd>, which form a
    set, string or list from <em data-v-7c2d3108> two</em> appropriate items on top of the stack:
  <pre data-v-7c2d3108>        pairset     ==  {} cons cons
          pairstring  ==  "" cons cons
          pairlist    ==  [] cons cons
  </pre>
  The action of all three is reversed by a single operator <kbd data-v-7c2d3108>unpair</kbd>,
  which may be defined in either of two equivalent ways:
  <pre data-v-7c2d3108>        unpair  ==  uncons uncons pop
          unpair  ==  uncons first
  </pre><p data-v-7c2d3108>
    Joy has two operators applicable to
    <em data-v-7c2d3108> non-empty</em> sets, strings and lists: The operator <kbd data-v-7c2d3108>first</kbd> extracts
    the first item of a string or list, and that item from a set which is the first
    in the underlying order. The operator <kbd data-v-7c2d3108>rest</kbd> removes the first item and
    returns the remaining set, string or list. Sometimes it is necessary to extract
    the
    <kbd data-v-7c2d3108>second</kbd> or <kbd data-v-7c2d3108>third</kbd> item. Suitable definitions are these:
  <pre data-v-7c2d3108>        second  ==  rest first
          third  ==  rest rest first
  </pre><p data-v-7c2d3108>
    The operators <kbd data-v-7c2d3108>uncons</kbd> and <kbd data-v-7c2d3108>unswons</kbd> undo what is done by
    <code data-v-7c2d3108>cons</code> and <code data-v-7c2d3108>swons</code>, Often it is useful to dissect not just
    one aggregate into its <code data-v-7c2d3108>first</code> and <code data-v-7c2d3108>rest</code>, but to dissect
    two aggregates. This can be done by <kbd data-v-7c2d3108>uncons2</kbd> and <kbd data-v-7c2d3108>unswons2</kbd>,
    defined as follows:
  <pre data-v-7c2d3108>        uncons2   ==  [uncons ] dip uncons  swapd
          unswons2  ==  [unswons] dip unswons swapd
  </pre>
  Both expect two aggregates on top of the stack, both leave two <code data-v-7c2d3108>first</code>s
  and two <code data-v-7c2d3108>rest</code>s on the stack. For <code data-v-7c2d3108>uncons2</code> the two <code data-v-7c2d3108>first</code>s
  are items 3 and 4 on the stack, the two <code data-v-7c2d3108>rest</code>s are items 1 and 2. For
  <code data-v-7c2d3108>unswons2</code> it is the other way around.
  <p data-v-7c2d3108>
    Similarly, it is sometimes necessary to test whether at least one of two aggregates
    is empty, or whether at least one of two numeric values is equal to zero. For a
    single parameter this is done by <code data-v-7c2d3108>null</code>, for two parameters it is
    done by <kbd data-v-7c2d3108>null2</kbd>, defined in either of two equivalent ways:
  <pre data-v-7c2d3108>        null2  ==  [null] [true] [pop null] ifte
          null2  ==  [ [[null] true] [pop null] ]  cond
  </pre><p data-v-7c2d3108>
    Strings and lists are special kinds of aggregates, they are <em data-v-7c2d3108>sequence</em>s.
    Sometimes it is necessary to reverse sequences. The naive way of doing this is
    recursively as follows:
  <pre data-v-7c2d3108>          To reverse a sequence S:
                   If    S is empty
                         then return the empty sequence
                         else    remove the first element
                                 reverse the rest of S
                                 append the first element of S at the tail
  </pre>
  It is easy to see that this is very inefficient because the append operation
  requires a lot of copying, and every element to be appended requires portions of
  the rest to be copied again and again. A well-known optimisation uses an extra parameter,
  an <em data-v-7c2d3108>accumulating parameter</em>, to obtain the same effect. The idea is to prepend
  the elements of the original list onto the accumulating parameter. Sometimes this
  is expressed by analogy with railways. The <kbd data-v-7c2d3108>shunt</kbd> operator takes two sequences
  as parameters and, starting at the front of the topmost parameter, moves all items
  onto the front of the second parameter. Joy has a combinator <kbd data-v-7c2d3108>step</kbd> for
  stepping through all items of its top parameter, and for each item executing a program
  that is given as a further parameter. That program has to take the item and add it
  to the accumulating parameter, so it is the <kbd data-v-7c2d3108>swons</kbd> operator. So this is
  how <code data-v-7c2d3108>shunt</code> can be defined:
  <pre data-v-7c2d3108>        shunt  ==  [swons] step
  </pre>
  To reverse a list or a string, an empty list or empty string has to be supplied
  as an accumulating parameter just below the list or string that is to be reversed.
  So here are definitions for <kbd data-v-7c2d3108>reverselist</kbd> and <kbd data-v-7c2d3108>reversestring</kbd>:
  <pre data-v-7c2d3108>        reverselist    ==  [] swap shunt
          reversestring  ==  "" swap shunt
  </pre>
  But there is something unsatisfactory about this, the reversal operation should
  be polymorphic. So the following version of <kbd data-v-7c2d3108>reverse</kbd> first tests whether
  the sequence to be reversed is a list or not, and inserts the appropriate accumulating
  parameter. The testing is done by the <kbd data-v-7c2d3108>iflist</kbd> combinator which takes two
  (here rather tiny) programs as parameters. and below that one other item, the list
  or string to be reversed. If the latter happens to be a list, then the first quoted
  program is executed, and it will push an empty list. Otherwise the second program
  is executed, and it will push an empty string. In either case the two top items are
  now
  <code data-v-7c2d3108>swap</code>ped and then <code data-v-7c2d3108>shunt</code>ed.
  <pre data-v-7c2d3108>        reverse  ==  [[]] [""] iflist swap shunt
  </pre><p data-v-7c2d3108>
    It comes as a surprise that lists can be reversed in another way. The idea is this:
    When a list is executed by a combinator, all the members of the list will be literals,
    so they will each be pushed onto the stack. The last element of the list will end
    up on top of the stack. So the elements of the list will then be in reverse order.
    To make use of this idea we have to arrange that an initially empty list is treated
    as a stack. This is what the <kbd data-v-7c2d3108>infra</kbd> combinator does. It takes a list
    as one parameter and a program as the second. It uses the list as a temporary stack
    and executes the program. The resultant stack is then pushed as a list. For the
    reversal problem the program is the list to be reversed, and the other parameter
    has to be the empty list. That empty list first has to be inserted below the list
    to be reversed. So another program to reverse a list is this:
  <pre data-v-7c2d3108>        reverselist  ==  [] swap infra
  </pre>
  What makes this version possible is that in Joy the principle that <em data-v-7c2d3108>program = data</em>is extended to <em data-v-7c2d3108>program = data = memory</em>. This version is actually more efficient
  than the one given earlier. Of course it cannot be adapted for reversing strings.
  <p data-v-7c2d3108>
    The two principal operators for explicit output are
    <kbd data-v-7c2d3108>put</kbd>, which prints a single value of any type, and <kbd data-v-7c2d3108>putch</kbd>,
    which prints a single stand alone character without quote symbol. Two useful little
    utility operators are worth defining. The <kbd data-v-7c2d3108>putchars</kbd> operator uses the
    <kbd data-v-7c2d3108>step</kbd> combinator to step through the characters in a list or string and
    writes them to the output file without the enclosing
    <code data-v-7c2d3108>[]</code> or <code data-v-7c2d3108>""</code>. The <kbd data-v-7c2d3108>newline</kbd> operator just outputs
    the newline character <code data-v-7c2d3108>\n</code> to terminate a line.
  <pre data-v-7c2d3108>        putchars  ==  [putch] step
          newline     ==  '\n put
  </pre><p data-v-7c2d3108>
    Using the <code data-v-7c2d3108>step</code> combinator it is easy to define several conversion
    operators which can be useful. The first two produce sets from aggregates of upper
    or lower case aggregates. The last two produce strings of upper or lower case characters
    from aggregates of small numbers.
  <pre data-v-7c2d3108>        upper2set == {} swap [64 - swons] step
          lower2set == {} swap [96 - swons] step
          set2upper == "" swap [64 + swons] step
          set2lower == "" swap [96 + swons] step
  </pre><p data-v-7c2d3108>
    The <kbd data-v-7c2d3108>dip</kbd> combinator expects a quotation and below that an item that will
    be saved before execution of the quotation and restored afterwards. Sometimes one
    wants to save and restore two or even three items, so it is useful to have further
    variants <kbd data-v-7c2d3108>dip2</kbd> and <kbd data-v-7c2d3108>dip3</kbd>, defined as follows:
  <pre data-v-7c2d3108>        dip2  ==  [dip] cons dip
          dip3  ==  [dip] cons dip2
  </pre>
  Note that <kbd data-v-7c2d3108>cons</kbd> is being used to build a <em data-v-7c2d3108>constructed program</em>that is then supplied as a parameter to the last combinator.
  <h1 data-v-7c2d3108>Stacks and queues</h1><p data-v-7c2d3108>
    This section and the next two contain implementations of two simple data types. Members
    of the <em data-v-7c2d3108>stack type</em> are linear structures which allow read and write access
    at one end only, and members of the <em data-v-7c2d3108>queue type</em> are linear structures which
    allow read access at one end and write access at the other end. Both have this
    much in common: the stack or queue remains on the Joy stack, and any stack or queue
    operations using it leave it there. Of course it can be explicitly removed with
    <code data-v-7c2d3108>pop</code>.
  <p data-v-7c2d3108><em data-v-7c2d3108> 1.</em> First, the <em data-v-7c2d3108>stack type</em>. A stack is a linear structure that
    can grow by having items added, inspected and removed all from the same end. The
    simplest way to implement stacks in Joy is as lists. One essential operator is
    <kbd data-v-7c2d3108>st-new</kbd> for the creation of a new empty stack, which is just an empty
    list. So the definition is
  <pre data-v-7c2d3108>        st-new  ==  []
  </pre><p data-v-7c2d3108>
    Stacks can have additional items pushed onto them, and this is done by adding them
    to the front of the list. Since the stack is already there, the new item will typically
    be first pushed onto the Joy stack, and then it is to be pushed onto the stack.
    One way to do this is to <code data-v-7c2d3108>swap</code> the item and the stack and then perform
    a <code data-v-7c2d3108>cons</code> operation. But Joy has an operation which combines these two,
    namely <kbd data-v-7c2d3108>swons</kbd>. So the <kbd data-v-7c2d3108>st-push</kbd> operation can be defined by
  <pre data-v-7c2d3108>        st-push  ==  swons
  </pre>
  An essential predicate is <kbd data-v-7c2d3108>st-null</kbd> for testing whether a stack is
  empty or null. However it will not do to just use <code data-v-7c2d3108>null</code>, since this will
  remove the stack --- but typically the stack is intended for further applications.
  So, to avoid losing the stack, it has to be <code data-v-7c2d3108>dup</code>licated first, and then
  the <code data-v-7c2d3108>null</code> test can be applied to the duplicate:
  <pre data-v-7c2d3108>        st-null  ==  dup null
  </pre><p data-v-7c2d3108>
    The previous two operations both make sense when the stack is empty, but this is
    not the case for the stack operations to follow. The first of these is <kbd data-v-7c2d3108>st-top</kbd>  for extracting the top element of the stack, while leaving the stack itself unchanged.
    The second is <kbd data-v-7c2d3108>st-pop</kbd> for removing the top element. The third is <kbd data-v-7c2d3108>st-pull</kbd>  which combines the last two, it is the opposite of push. It extracts the top item
    and pops the stack. Ignoring the complication of an empty stack, the definitions
    would simply be:
  <pre data-v-7c2d3108>        st-top   ==  dup first
          st-pop   ==  rest
          st-pull  ==  unswons
  </pre>
  To guard against an empty stack, a test has to be performed to determine whether
  the stack is empty. If it is, then an error message should be given, otherwise the
  operation should be performed. So for all three operations the structure will be
  of the form
  <pre data-v-7c2d3108>        ==   [null]  [ERROR-MESSAGE]  [PERFORM OPERATION]  ifte
  </pre>
  The error messages should state which of the operations was being attempted,
  but otherwise they should be the same. So the name of the operation is given as a
  string parameter to an error handling operation. That particular operation will be
  called
  <code data-v-7c2d3108>_st-error</code>, and we leave the details of its implementation till a little
  later. The leading underscore <code data-v-7c2d3108>_</code> in the name has been added because this
  operation is not intended to be used by the programmer; in the current implementation
  the <kbd data-v-7c2d3108>help</kbd> command hides identifiers with a leading underscore. The remaining
  stack operations are then:
  <pre data-v-7c2d3108>        st-top  == [null] ["st-top"  _st-error] [dup first] ifte
          st-pop  == [null] ["st-pop"  _st-error] [rest     ] ifte
          st-pull == [null] ["st-pull" _st-error] [unswons  ] ifte
  </pre>
  As may be seen, the three operations still have a lot in common, and one might
  consider extracting that further. However, the result is likely to be less clear
  to the human reader. It remains to implement the error operation. It should state
  that an error has occurred due to an empty stack, and this part is the same for all
  three operations. It should also state which of the operations failed. So a minimal
  implementation of <code data-v-7c2d3108>_st-error</code> would simply write one string which is common
  for any call, and another string which is the specific parameter. This is crude but
  very easy to implement:
  <pre data-v-7c2d3108>        _st-error  ==  "non_empty stack needed for " put put
  </pre>
  A minor improvement is to concatenate the two strings (in the right order),
  so that only one string has to be written. But the double quotation marks in the
  output still look silly. So instead of writing the one or two strings with <code data-v-7c2d3108>put</code>,
  it looks nicer to write their constituent characters with <kbd data-v-7c2d3108>putchars</kbd>. Also,
  the line should be terminated with <kbd data-v-7c2d3108>newline</kbd>. Finally, there is little sense
  in continuing the computation, so after the two parts of the error message have been
  displayed, it is best to <kbd data-v-7c2d3108>abort</kbd>, to return to the top level.
  <p data-v-7c2d3108>
    In a library implementation for the collection of definitions of stack operations
    might look like this:
  <pre data-v-7c2d3108>LIBRA (* stack *)

  _st-error == "non-empty stack needed for " putchars putchars newline abort;
  st-new  == [];
  st-push == swons;
  st-null == dup null;
  st-top  == [null] ["st-top"  _st-error] [dup first] ifte;
  st-pop  == [null] ["st-pop"  _st-error] [rest     ] ifte;
  st-pull == [null] ["st-pull" _st-error] [unswons  ] ifte.
  </pre>
  As may be seen from the example, a library declaration begins with the word
  <kbd data-v-7c2d3108>LIBRA</kbd> and terminates with a period. In between is a sequence of definitions
  separated by semicolons <kbd data-v-7c2d3108>;</kbd>. A definition consists of an atomic symbol and
  then the symbol <kbd data-v-7c2d3108>==</kbd> followed by a Joy program. Note again that the <code data-v-7c2d3108>_st-error</code>operator is not really intended to be used outside the remaining definitions. It
  could well be hidden completely from outside. A mechanism for this will be illustrated
  below.
  <p data-v-7c2d3108><em data-v-7c2d3108> 2.</em> Next, the <em data-v-7c2d3108>queue type</em>. A queue is a linear structure that
    can grow by having items added at one end, and inspected or removed from the other
    end. A simple minded implementation would consists of a single Joy list to which
    items are added at the end and removed from the front. But adding something at
    the end requires copying the entire list every time. Nothing would be gained by
    reversing the role of front and end, because in that case the removal requires
    copying of (almost) the entire list. A better implementation uses <em data-v-7c2d3108> two</em>  lists. Conceptually one is the front of the queue, and items are removed at the
    front. Conceptually the other list is the back of the queue, but in reverse, and
    items are added to the front of this list. If at any time the list implementing
    the front of the queue becomes empty, the other list gets explicitly reversed and
    it becomes the front, and the empty list becomes the rear. There are two auxiliary
    operators that need only be visible to the remaining operators but not to the outside;
    in the following they are hidden in the private part of this module. Because they
    are hidden, there is no need to choose names which indicate the datatype on which
    they operate.
  <pre data-v-7c2d3108>LIBRA (* queue *)

  HIDE
    error   == "non_empty queue needed for " putchars putchars newline abort;
    prepare == [null] [swap reverse] [] ifte
  IN
    q-new   == [] [];
    q-add   == swap [swons] dip;
    q-addl  == swap [shunt] dip;
    q-null  == prepare dup null;
    q-front == prepare [null] ["q-front" error] [dup first] ifte;
    q-rem   == prepare [null] ["q-rem "  error] [unswons  ] ifte
  END.
  </pre><p data-v-7c2d3108>
    As may be seen, such a declaration consists of the word <kbd data-v-7c2d3108>HIDE</kbd>, followed
    by a sequence of definitions, then the word <kbd data-v-7c2d3108>IN</kbd> followed by another sequence
    of definitions, and then the word <kbd data-v-7c2d3108>END</kbd>. A sequence of definitions is
    again separated by semicolons <kbd data-v-7c2d3108>;</kbd>. The whole declaration can occur inside
    a library declaration where a single definition can occur. Any hiding declaration
    can occur wherever a single definition can occur, so they can be nested.
  <p data-v-7c2d3108>
    The first auxiliary error reporting procedure, <code data-v-7c2d3108>error</code>, is similar to
    the one for stacks. The second auxiliary operation, <code data-v-7c2d3108>prepare</code>, prepares
    the two lists: if the list implementing the front happens to be empty, the roles
    of the two lists are interchanged. If the front list is not empty, nothing is done.
  <p data-v-7c2d3108>
    A new queue is created by <kbd data-v-7c2d3108>q-new</kbd> in the form of two empty lists. An item
    can be added (to the "rear of the queue") by <kbd data-v-7c2d3108>q-add</kbd> which adds it to
    the front of the second list. The members of a whole list can be added to the rear
    by <kbd data-v-7c2d3108>q-addl</kbd>. The operator <kbd data-v-7c2d3108>q-null</kbd> first prepares the two lists
    so that the list implementing the front is not empty, if that is possible at all.
    It then tests the front list. The operator <kbd data-v-7c2d3108>q-front</kbd> and <kbd data-v-7c2d3108>q-rem</kbd>  extract respectively a copy of the front element or the front element itself. The
    copy or the original are left above the two lists. Both operators require the queue
    to be prepared so that the list implementing the front is not empty. Also, both
    operators need to check whether the front really is non-empty. If it is not, the
    error operator is called.
  <p data-v-7c2d3108>
    The definitions for stacks and queues are part of the library file
    <kbd data-v-7c2d3108>TYPLIB.JOY</kbd>.
  <h1 data-v-7c2d3108>Lists of subaggregates</h1>
  The <em data-v-7c2d3108>aggregate type</em>s of Joy comprise sets of small numbers, or strings of
  characters, or lists of items of any kind. Much of this section deals with lists
  of aggregates constructed from a given aggregate. The principal tool is the <kbd data-v-7c2d3108>linrec</kbd>combinator. It expects four program parameters on the stack, an if-part, a then-part,
  a rec1-part and a rec2-part. Execution begins by saving the four parts and then executing
  the if-part. If that produces the truth value <code data-v-7c2d3108>true</code> on top of the stack,
  the then-part is executed and the combinator exits. Otherwise the rec1-part is executed,
  then the combinator calls itself with the same four parts, and then the rec2-part
  is executed.
  <p data-v-7c2d3108>
    The first definition below is for an operator <kbd data-v-7c2d3108>restlist</kbd> which takes any
    aggregate as parameter and produces the list of all those subaggregates that would
    be formed by repeatedly taking the <kbd data-v-7c2d3108>rest</kbd>s of the aggregate. Such an operator
    can of course be defined recursively and this could be done in any language. But
    in Joy it is possible to use a non-recursive definition using the <code data-v-7c2d3108>linrec</code>  combinator. Here is some pseudocode:
  <pre data-v-7c2d3108>1.      If    the aggregate is empty
  2.            then  form its unitlist
  3.            else    take a copy and the rest of that,
                        recurse using this rest,
                        eventually forming a list of aggregates,
  4.                    use cons to add the original aggregate
                        to the front of this list
  </pre>
  The above pseudocode translates directly into a recursive form in any language,
  but in Joy a non-recursive definition is also possible. The four program parameters
  for the <code data-v-7c2d3108>linrec</code> combinator correspond exactly to the labelled lines.
  Nothing corresponds to the unlabelled line, the <code data-v-7c2d3108>linrec</code> combinator recurses
  here automatically.
  <pre data-v-7c2d3108>    restlist  ==
  1.        [ null ]
  2.        [ unitlist ]
  3.        [ dup rest ]
  4.        [ cons ]
            linrec
  </pre><p data-v-7c2d3108>
    The next program also takes an aggregate as parameter and produces a list of subaggregates.
    But the subaggregates are those obtained by successively deleting the last elements.
    In analogy with the previous operator it will be called the <kbd data-v-7c2d3108>frontlist</kbd>  operator. For empty aggregate parameters again the unitlist has to be returned,
    so the if-part and the then-part are the same as before. Also, for non-empty aggregates
    the aggregate has to be taken apart in the rec1-part. This can be done in two ways.
    We can take the front aggregate and the last element, but that would require defining
    a suitable operator, and it would require expensive copying in the case of list
    or string aggregates. Alternatively we can just <code data-v-7c2d3108>uncons</code>. This leaves
    only the rec2-part to be written. But it will be more complicated than for the
    previous operator. Let us ignore for the moment that the operator is intended to
    be used for aggregates of any of the three types. When the anonymous recursion
    has completed, the stack will contain the first item of the non-empty aggregate
    and above that the <code data-v-7c2d3108>frontlist</code> of its rest. The first item has to be
    <code data-v-7c2d3108>cons</code>ed into each member of the frontlist, and that is best done by
  <pre data-v-7c2d3108>        [cons]  map
  </pre>
  Then that first item, which is now still the second element on the stack,
  has to be deleted. This can be done by a variant of <code data-v-7c2d3108>pop</code>, namely <code data-v-7c2d3108>popd</code>.
  Finally, assuming that the operator is to be used for lists, the empty list has to
  be added to the frontlist, and the easiest way is by <code data-v-7c2d3108>[] swap cons</code>, or
  simply by <code data-v-7c2d3108>[] swons</code>. This gives the following provisional rec2-part:
  <pre data-v-7c2d3108>        [ [cons] map   popd   [] swons ]
  </pre>
  But the assumption that the operator is to be used only for lists is unnecessarily
  restrictive. The final part, adding an empty aggregate, should depend on what the
  initial aggregate was, a set, a string or a list. This can be achieved by looking
  up the first element of the frontlist, it is a one element aggregate and taking its
  rest produces the required empty aggregate of that type. So the required rec2-part
  is:
  <pre data-v-7c2d3108>        [ [cons] map   popd   dup first rest swons ]
  </pre>
  The entire definition for <code data-v-7c2d3108>frontlist</code>, applicable to any aggregate,
  now is:
  <pre data-v-7c2d3108>    frontlist ==
          [ null ]
          [ unitlist ]
          [ uncons ]
          [ [cons] map popd dup first rest swons ]
          linrec
  </pre><p data-v-7c2d3108>
    The next program defines an operator <kbd data-v-7c2d3108>subseqlist</kbd> which is in some ways
    a combination of the preceding ones. Again it takes any aggregate as parameter
    and returns a list of subaggregates. This time the subaggregates are all those
    obtainable from the parameter aggregate by deleting first or last elements. For
    ordered aggregates, lists and strings, the resulting subaggregates will still contain
    elements in the same order as the parameter. It is tempting to define the operator
    very simply by
  <pre data-v-7c2d3108>        ==   frontlist  [restlist]  map
  </pre>
  But this produces not a list of subsequences but a list of list of subsequences.
  This list of lists could then be flattened to a single list, even if this is somewhat
  inefficient. However, a different solution is possible.
  <p data-v-7c2d3108>
    The if-part and the then-part are as for <code data-v-7c2d3108>restlist</code> and <code data-v-7c2d3108>frontlist</code>,
    of course. The rec2-part is easy, it is only necessary to <code data-v-7c2d3108>concat</code>enate
    two lists that were produced by the rec1-part. But the rec1-part is rather complex,
    and this is what it has to do: the first element of the aggregate has to be extracted
    and later it has to be <code data-v-7c2d3108>cons</code>ed into every subaggregate of the <code data-v-7c2d3108>frontlist</code>  of the rest of the aggregate. But also the rest of the aggregate has to be made
    available for the <code data-v-7c2d3108>linrec</code> combinator to work on. So the rec1-part must
    <code data-v-7c2d3108>uncons</code> the aggregate, and produce a second copy of the rest. The second
    copy has to be kept aside by using the <code data-v-7c2d3108>dip</code> combinator to work on the
    original copy. So an intermediate draft of the rec1-part looks like this:
  <pre data-v-7c2d3108>        [ uncons  dup
            [ ... ]
            dip ]
  </pre>
  The <code data-v-7c2d3108>[...]</code> program must take the <code data-v-7c2d3108>frontlist</code> (of the
  original copy of the rest) and then <code data-v-7c2d3108>cons</code> the first element into each
  of the members of the result. We already know how to do that, and how to delete the
  hidden first member. So the rec2-part is the following:
  <pre data-v-7c2d3108>        [ uncons  dup
            [ frontlist  [cons] map  popd ]
            dip ]
  </pre>
  The entire program now is this:
  <pre data-v-7c2d3108>    subseqlist ==
          [ null ]
          [ unitlist ]
          [ uncons dup [frontlist [cons] map popd] dip ]
          [ concat ]
          linrec
  </pre>
  The program uses <code data-v-7c2d3108>frontlist</code>, but because the latter is defined
  without recursion, it is possible to simply use the RHS of the definition of <code data-v-7c2d3108>frontlist</code>and insert that textually into the definition of <code data-v-7c2d3108>subseqlist</code>. The <code data-v-7c2d3108>frontlist</code>and <code data-v-7c2d3108>subseqlist</code> operators were adapted from recursive programs in \AX{Thompson}{1991
  p 247}{Thompson:91}.
  <p data-v-7c2d3108>
    The next program defines a unary operator <kbd data-v-7c2d3108>powerlist</kbd> which for any aggregate
    returns a list of all subaggregates. If the parameter aggregate has <var data-v-7c2d3108>N</var>  members, the resulting list of subaggregates has <var data-v-7c2d3108>2^N</var> members.
  <pre data-v-7c2d3108>    powerlist ==
          [ null ]
          [ unitlist ]
          [ uncons ]
          [ dup swapd [cons] map popd swoncat ]
          linrec
  </pre>
  It uses the <code data-v-7c2d3108>linrec</code> combinator and the same if-part and then-part
  as the previous programs. It also uses the same rec1-part as the <code data-v-7c2d3108>frontlist</code>program: before recursing, the parameter is split into its first and its rest by
  <code data-v-7c2d3108>uncons</code>. The recursion then produces the powerlist of the rest. The rec2-part
  then uses that result to produce two copies, using <code data-v-7c2d3108>dup</code>. One copy is
  left untouched, the other has the original first element
  <code data-v-7c2d3108>cons</code>ed before every sublist using <code data-v-7c2d3108>map</code>. For this to work,
  the original first element has to be placed in the right position by <code data-v-7c2d3108>swapd</code>and eventually deleted by <code data-v-7c2d3108>popd</code>. The two resultant lists are finally
  combined with
  <code data-v-7c2d3108>swoncat</code>. This produces the list of subaggregates starting with the empty
  one; if <code data-v-7c2d3108>concat</code> is used instead of <code data-v-7c2d3108>swoncat</code>, the list ends
  with the empty one. Neither method yields the subsequences sorted according to <code data-v-7c2d3108>size</code>;
  but see the later section on sorted sequences.
  <p data-v-7c2d3108>
    The next program defines a binary operator <kbd data-v-7c2d3108>insertlist</kbd>. This operator
    expects a list or a string as a parameter and below that a potential list member
    or a character. It returns a list whose elements are either lists or strings, each
    with the potential member or character inserted once at all possible positions.
    So if the original list or string has <var data-v-7c2d3108>N</var> members, the resultant list
    has <var data-v-7c2d3108>N+1</var> lists or strings as members.
  <pre data-v-7c2d3108>    insertlist ==       (*   Item  Sequence   ->   List(Sequence) *)
          cons
          [ small ]
          [ unitlist ]
          [ dup                           (* keep original *)
            unswons [uncons] dip swons ]  (* take out second *)
          [ swap [swons] cons map         (* swons in second *)
            cons ]                        (* cons in original *)
          linrec
  </pre>
  The operator can also be used, with a set parameter instead of a string or
  list. Then it produces a list of <var data-v-7c2d3108>N+1</var> identical sets, each with the new
  member added. But such a use will rarely be wanted.
  <p data-v-7c2d3108>
    The <kbd data-v-7c2d3108>permlist</kbd> operator expects a sequence and returns the list of all
    <em data-v-7c2d3108>permutation</em>s of that sequence. So if the original sequence has <var data-v-7c2d3108>N</var>  members, the result list has factorial(<var data-v-7c2d3108>N</var>) members.
  <pre data-v-7c2d3108>    permlist ==
          [ small ]
          [ unitlist ]
          [ uncons ]
          [ swap [swap insertlist] cons map
            flatten ]
          linrec
  </pre>
  Note again that in the two preceding programs the <code data-v-7c2d3108>map</code> combinator
  uses a <em data-v-7c2d3108>constructed program</em>.
  <p data-v-7c2d3108>
    The <kbd data-v-7c2d3108>zip</kbd> operator expects two aggregate parameters, not necessarily of
    the same type, and not necessarily of the same <code data-v-7c2d3108>size</code>. It produces a
    list of two element lists by combining corresponding elements from the two aggregates.
    The result list contains as many pairs as the smaller of the two parameter aggregates.
    Here is the definition:
  <pre data-v-7c2d3108>    zip ==
          [ null2 ]
          [ pop pop [] ]
          [ uncons2 ]
          [ [pairlist] dip cons ]
          linrec
  </pre>
  This might be paraphrased as: If one or the other of the two parameter aggregates
  is <code data-v-7c2d3108>null</code>, then <code data-v-7c2d3108>pop</code> them both and return the empty list <code data-v-7c2d3108>[]</code>,
  otherwise take out the two <code data-v-7c2d3108>first</code> elements and the two <code data-v-7c2d3108>rest</code>s,
  recurse with the two <code data-v-7c2d3108>rest</code>s producing a result list of two element lists
  of that, then <code data-v-7c2d3108>dip</code> below that result list to combine the two previous
  <code data-v-7c2d3108>first</code>s with <kbd data-v-7c2d3108>pairlist</kbd> to form a two element list, and <code data-v-7c2d3108>cons</code>that into the front of the result list.
  <p data-v-7c2d3108>
    Related to this is the more general <kbd data-v-7c2d3108>zipwith</kbd> combinator, adapted from
    \AX{Bird and Wadler}{1988 p 57}{Bird:88}. It takes three parameters, two aggregates
    and one quotation which can be used to combine members of the aggregates. The program
    again uses the <code data-v-7c2d3108>linrec</code> combinator which needs four quoted programs
    as parameters. The fourth quotation now has to be a <em data-v-7c2d3108>constructed program</em>,
    it is built from the program parameter of <code data-v-7c2d3108>zipwith</code> and the program
    stub <code data-v-7c2d3108>[dip cons]</code> already seen for <code data-v-7c2d3108>zip</code>. The other three
    program parameters for <code data-v-7c2d3108>linrec</code> first have to be <code data-v-7c2d3108>dip</code>ped
    below the parameter of <code data-v-7c2d3108>zipwith</code>. The definition for this combinator
    thus is:
  <pre data-v-7c2d3108>    zipwith ==
  1.       [ [ null2 ]
  2.         [ pop pop [] ]
  3.         [ uncons2 ] ]
           dip
  4.       [ dip cons ] cons
           linrec
  </pre><p data-v-7c2d3108>
    A list of sequences can be concatenated into a single sequence by the unary operator
    <kbd data-v-7c2d3108>flatten</kbd>. The code is straightforward: if the parameter list is empty,
    then there is nothing to concatenate, leave it as it is. Otherwise use <code data-v-7c2d3108>uncons</code>  to take out its first and its rest, recurse anonymously on the rest to produce
    the <code data-v-7c2d3108>flatten</code>ed result of that, and finally <code data-v-7c2d3108>concat</code>enate
    the saved first part to the front of the last result.
  <pre data-v-7c2d3108>    flatten  ==  [null]  []  [uncons]  [concat] linrec
  </pre><p data-v-7c2d3108>
    A two dimensional <em data-v-7c2d3108>matrix</em> can be implemented as a list of lists. One important
    matrix operation is the interchange of rows and columns, performed by the unary
    operator <kbd data-v-7c2d3108>transpose</kbd>. A draft of the program is the following:
  <pre data-v-7c2d3108>          To transpose a list of lists LL :
  1                If    LL is empty or some sublist of LL is empty
  2                      then     pop  it off and return the empty list  [] 
                         else    (all sublists are non-empty)
  3a                             construct a list of all the  first s of sublists
  3b                             construct a list of all the  rest s of sublists
                                 recurse anonymously on the list of  rests
  4                               cons  the list of  firsts into the result.
  </pre>
  This version has been adapted from \AX{Reade}{1989 p 133}{Reade:89}. To test
  the disjunction whether LL is empty or some of its sublists are empty, we use the
  conditional combinator <kbd data-v-7c2d3108>ifte</kbd>. The if-part has to test whether LL is empty,
  and if it is, then the then-part has to return <code data-v-7c2d3108>true</code>. Otherwise the then-part
  will have to determine whether some sublists of LL are empty. This is best done with
  the combinator <kbd data-v-7c2d3108>some</kbd>. So part 1 of the Joy version is:
  <pre data-v-7c2d3108>1        [null]  [true]  [[null] some]  ifte
  </pre>
  For parts 3a and 3b it is necessary to use the parameter LL to produce two
  lists, of the <code data-v-7c2d3108>first</code>s and the <code data-v-7c2d3108>rest</code>s. Either of these two
  can be obtained with the <kbd data-v-7c2d3108>map</kbd> combinator. To obtain the two lists, the
  <kbd data-v-7c2d3108>cleave</kbd> combinator can be used, it takes two quotation parameters and a
  further parameter, and produces two values, one from each of the two quotations.
  So parts 3a and 3b are just:
  <pre data-v-7c2d3108>3a      [ [first] map ]
  3b      [ [rest ] map ]
          cleave
  </pre>
  The entire Joy program thus is:
  <pre data-v-7c2d3108>    transpose ==
  1       [ [null] [true] [[null] some] ifte ]
  2       [ pop [] ]
  3       [ [[first] map] [[rest] map] cleave ]
  4       [ cons ]
          linrec;
  </pre><p data-v-7c2d3108>
    Alternatively, line 1 can be replaced by the following:
  <pre data-v-7c2d3108>1        [ [null] [[null] some] disjoin i ]
  </pre>
  Here the two tests are first <kbd data-v-7c2d3108>disjoin</kbd>ed to form a single test predicate.
  This is the called by the <code data-v-7c2d3108>i</code> combinator. The net effect is exactly the
  same as in the version given earlier.
  <p data-v-7c2d3108>
    A common binary operation on aggregates is that of forming the <em data-v-7c2d3108>Cartesian product</em>.
    It will take two aggregates as parameters and produce the list of two element list
    which each contain one element from each of the two aggregates. If the two aggregates
    have <var data-v-7c2d3108>M</var> and <var data-v-7c2d3108>N</var> members respectively, then the resultant list
    has <var data-v-7c2d3108>M \times N</var> elements. In order to form the Cartesian product, it
    is necessary to consider each of the members of one aggregate with each of the
    members of the other aggregate. This is like <code data-v-7c2d3108>step</code>ping through an aggregate,
    except that there are two aggregate to be stepped through. It will be useful first
    to define a combinator <kbd data-v-7c2d3108>step2</kbd> which does just that, leaving at each step
    two items on top of the stack. Then the Cartesian product operator will just form
    their pairs, and then form a list of all these pairs. An application of the <code data-v-7c2d3108>step2</code>  combinator will look like this:
  <pre data-v-7c2d3108>        A1   A2   [P]   step2
  </pre>
  The implementation is based on the simple idea that
  <code data-v-7c2d3108>A2</code> and <code data-v-7c2d3108>[P]</code> be used to construct a program which is then
  used by the ordinary <code data-v-7c2d3108>step</code> combinator to step through the elements of
  <code data-v-7c2d3108>A1</code>:
  <pre data-v-7c2d3108>        A1   [ .. A2 .. [P] .. ]   step
  </pre>
  We now fill in the dots. The program to be constructed has to <code data-v-7c2d3108>step</code>through the members of <code data-v-7c2d3108>A2</code> using a program which depends on <code data-v-7c2d3108>[P]</code>.
  It has to do this for each member of <code data-v-7c2d3108>A1</code>, and when it has done that the
  current member of <code data-v-7c2d3108>A1</code> can be <code data-v-7c2d3108>pop</code>ped off. So the program
  will have to look like this:
  <pre data-v-7c2d3108>        A1   [ A2  [ .. P ]  step  pop ]   step
  </pre>
  Since <code data-v-7c2d3108>P</code> must be allowed to consume a current member of
  <code data-v-7c2d3108>A1</code> but this still has to be available for the next inner <code data-v-7c2d3108>step</code>,
  that member of <code data-v-7c2d3108>A1</code> first has do be duplicated, below the current member
  of <code data-v-7c2d3108>A2</code>. So the dots are just <code data-v-7c2d3108>[dup] dip</code>. In sum, the required
  program is
  <pre data-v-7c2d3108>        A1   [ A2  [ [dup]  dip  P ]  step  pop ]   step
  </pre>
  The definition of <kbd data-v-7c2d3108>step2</kbd> must construct that program from <code data-v-7c2d3108>A2</code>and <code data-v-7c2d3108>[P]</code> and then call <code data-v-7c2d3108>step</code> with just two parameters, the
  program just constructed and below that the other aggregate <code data-v-7c2d3108>A1</code>. The
  definition looks like this:
  <pre data-v-7c2d3108>    step2  ==
          [[dup] dip]  swoncat            (* form inner quote *)
          [step pop]  cons                (* form outer quote *)
          cons                            (* insert A2 *)
          step                            (* through A1 *)
  </pre><p data-v-7c2d3108>
    It is now relatively easy to define the <em data-v-7c2d3108>Cartesian product</em> operator as
    follows. First we need to insert an <em data-v-7c2d3108>accumulating parameter</em>, an empty list
    <code data-v-7c2d3108>[]</code>. It has to be inserted <em data-v-7c2d3108> below</em> the two aggregates of which
    the Cartesian product is to be computed. This is easily done with <code data-v-7c2d3108>[] rollup</code>.
    The program which is then used by the <code data-v-7c2d3108>step2</code> combinator has to form
    the <code data-v-7c2d3108>pairlist</code> of the two items on top of the stack. The resultant pair
    has to be inserted into the accumulator with
    <code data-v-7c2d3108>swons</code>. But between the accumulator and the just formed pair is the
    current original member of the first aggregate which must be left intact. So the
    pair and the member have to be <code data-v-7c2d3108>swap</code>ped, and the <code data-v-7c2d3108>swons</code>  has to be done below the member, by <code data-v-7c2d3108>dip</code>. This is the program that
    is given as the parameter for <code data-v-7c2d3108>step2</code>. So the definition for the <kbd data-v-7c2d3108>cartproduct</kbd>  operator is
  <pre data-v-7c2d3108>    cartproduct  ==
          [] rollup
          [pairlist swap [swons] dip]
          step2
  </pre>
  The program works for aggregates of any type, and the two aggregates do not
  have to be of the same type. If both are lists of numbers or sets of small numbers,
  other variations are possible: By changing the pairing operator <code data-v-7c2d3108>pairlist</code>to, say, multiplication <code data-v-7c2d3108>*</code>, we obtain a program which produces a list
  of all products. By further changing the accumulator <code data-v-7c2d3108>[]</code> to the number
  <code data-v-7c2d3108>0</code> and the insertion operation <code data-v-7c2d3108>swons</code> to, say, addition <code data-v-7c2d3108>+</code>,
  we obtain a program which produces the sum of all <var data-v-7c2d3108>M \times N</var> products.
  For two numeric aggregates of the same size, say <var data-v-7c2d3108>N</var>, another binary operator
  can be defined, the <kbd data-v-7c2d3108>scalarproduct</kbd>:
  <pre data-v-7c2d3108>        scalarproduct  ==
              0 rollup                             (* accumulator *)
              [ null2 ]
              [ popd ]
              [ uncons2 [* +] dip2 ]
              tailrec
  </pre>
  It produces the sum of all <var data-v-7c2d3108>N</var> products of pairs taken from corresponding
  positions in the two aggregates.
  <h1 data-v-7c2d3108>Arithmetic operators</h1><p data-v-7c2d3108>
    This section gives efficient implementation of several well-known functions which
    are often used in the literature for demonstration purposes: the <em data-v-7c2d3108>factorial</em>,
    the <em data-v-7c2d3108>Fibonacci</em>-function,
    <em data-v-7c2d3108>exponentiation</em> and the <em data-v-7c2d3108>greatest common divisor</em>. All of them are
    often defined recursively, and of course they can be defined recursively in Joy.
    Using one of several suitable recursion combinators they can be computed recursively
    in Joy without a recursive definition. But recursive execution in any language
    can be inefficient.
  <p data-v-7c2d3108>
    There are well known techniques for <em data-v-7c2d3108>removing linear recursion</em>, see for
    example \AX{Bauer and W\"ossner}{1982 Chapter 4}{Bauer-Woessner:82}. The same topic
    is discussed in \AX{Henson}{1987 Chapter 4}{Henson:87} using the useful concept
    of <em data-v-7c2d3108>eureka definition</em>s due to Burstall and Darlington. These involve creative
    steps in the production of more efficient versions of programs, and hence would
    be difficult to perform by an optimising program.
  <p data-v-7c2d3108>
    Several of the functions to be defined require a little program to be executed a
    number of times. A useful combinator for this is <kbd data-v-7c2d3108>times</kbd>. It requires
    the program to be repeated as the top element of the stack and the required number
    of repetitions to be the second element on the stack.
  <p data-v-7c2d3108>
    The factorial of a number <var data-v-7c2d3108>n</var> is simply the product of <var data-v-7c2d3108>n</var> factors
    from <var data-v-7c2d3108>1</var> to <var data-v-7c2d3108>n</var>. To compute it using <code data-v-7c2d3108>times</code>, a small
    program has to be pushed on top of the number <var data-v-7c2d3108>n</var> which is the parameter.
    The number itself will be consumed by <code data-v-7c2d3108>times</code>. The program works on
    two other numbers on the stack. One of these is the accumulating parameter, it
    has to start at <var data-v-7c2d3108>1</var>. The other is the next factor to be used by the program
    with which to multiply the accumulator. The multiplication has to be done without
    losing the factor, so it has to be duplicated first. Apart from doing the multiplication,
    the program also has to increment the factor using the successor operator <kbd data-v-7c2d3108>succ</kbd>.
    The program which is the parameter to <code data-v-7c2d3108>times</code> thus is
  <pre data-v-7c2d3108>        [dup  [*]  dip  succ]
  </pre>
  Before the <code data-v-7c2d3108>times</code> combinator can get to work on the parameter
  <var data-v-7c2d3108>n</var> and the quoted program, the accumulator and the first factor have to
  be placed in position, below the parameter <var data-v-7c2d3108>n</var>. Both begin with the value
  <var data-v-7c2d3108>1</var>, so the <code data-v-7c2d3108>rolldown</code> operator can be used to push these two
  values below <var data-v-7c2d3108>n</var>. Finally, after <code data-v-7c2d3108>times</code> has completed, the stack
  will contain the required accumulator value but also on top of that the next factor.
  The latter is simply <code data-v-7c2d3108>pop</code>ped off. The entire definition of <kbd data-v-7c2d3108>fact</kbd>is:
  <pre data-v-7c2d3108>        fact == 1 1 rolldown [dup [*] dip succ] times pop
  </pre><p data-v-7c2d3108>
    The <em data-v-7c2d3108>Fibonacci</em> function can be computed in a similar way. Again there is
    a certain computation that has to be repeated a number of times as given by the
    parameter <var data-v-7c2d3108>n</var>. Again the computation involves two further numbers, the
    larger one is to be replaced by their sum, and the smaller one is to be replaced
    by the former larger one. Adding the two must not destroy the original larger number,
    so again it has to be <code data-v-7c2d3108>dup</code>licated. The addition is then performed under
    the control of <code data-v-7c2d3108>dip</code>. Then the two numbers are <code data-v-7c2d3108>swap</code>ped.
    This describes the little program that serves as the parameter to the <code data-v-7c2d3108>times</code>  combinator. Before it can start, the two initial values <var data-v-7c2d3108>0</var> and <var data-v-7c2d3108>1</var>  have to be placed below the parameter <var data-v-7c2d3108>n</var> with <code data-v-7c2d3108>rolldown</code>.
    When it has completed, the required accumulated sum is the second element, and
    the top element, the useless next summand, is <code data-v-7c2d3108>pop</code>ped. So this is the
    definition of <kbd data-v-7c2d3108>fib</kbd>:
  <pre data-v-7c2d3108>        fib  ==  0 1 rolldown [dup [+] dip swap] times pop
  </pre>
  This version of the Fibonacci function requires a computation time which is
  a linear function of the parameter <var data-v-7c2d3108>n</var>.
  <p data-v-7c2d3108>
    The recursive version of the Fibonacci function requires quadratic computation time.
    Since the result values are not very large, it is often used as a test program.
    What is of interest is the number of recursive calls made during the computation,
    to be divided by the total time it took. To obtain the number of recursive calls
    it is often convenient to use a variant of the Fibonacci function, sometimes called
    <kbd data-v-7c2d3108>nfib</kbd>. It has the property that the value returned is the same as the
    number of calls made during recursive execution. The following are recursive definitions
    of Fibonacci and its variant:
  <pre data-v-7c2d3108>    r-fib  ==  [small] []      [pred dup pred [r-fib ] app2 +     ] ifte
      r-nfib ==  [small] [pop 1] [pred dup pred [r-nfib] app2 + succ] ifte
  </pre>
  These are recursive definitions which of course are intended to run in quadratic
  time. The following is a definition of <kbd data-v-7c2d3108>nfib</kbd> which uses accumulators to
  run in linear time. Of course it does not measure its own runtime, it is included
  here to illustrate a programming technique.
  <pre data-v-7c2d3108>        nfib  ==  1 1 rolldown [dup [+ succ] dip swap] times pop
  </pre><p data-v-7c2d3108>
    The next two programs are for <em data-v-7c2d3108>binary operator</em>s which compute functions
    of two parameters: the <em data-v-7c2d3108>exponentiation</em> function and the <em data-v-7c2d3108>greatest common divisor</em>.
    Exponentiation can be computed by performing a certain operation as many times
    as given by the exponent. This description again suggests using the <code data-v-7c2d3108>times</code>  combinator to execute a quoted program several times. The operation to be repeated
    consists in multiplying an accumulator by the base which is the second parameter.
    So it is necessary to construct a little program from the base which for every
    call will multiply by the base. Assuming that the base is in the right position
    on the stack, the program is easily constructed, by
  <pre data-v-7c2d3108>        [*] cons
  </pre>
  Before the <em data-v-7c2d3108>constructed program</em> can be handed to <code data-v-7c2d3108>times</code>,
  the initial value <var data-v-7c2d3108>1</var> has to be placed as an accumulator below the two numbers
  which are the two parameters, the base and the exponent. This is done by <code data-v-7c2d3108>1 rollup</code>.
  To get the two parameters into the order appropriate for <code data-v-7c2d3108>cons</code> it is
  necessary to perform a <code data-v-7c2d3108>rotate</code> first. So here is the <kbd data-v-7c2d3108>exp</kbd> operator:
  <pre data-v-7c2d3108>        exp  ==  1 rotate [*] cons times
  </pre>
  The technique of first constructing a program (here by <code data-v-7c2d3108>cons</code>)
  and then supplying it to a combinator (here <code data-v-7c2d3108>times</code>) is very useful in
  Joy.
  <p data-v-7c2d3108>
    The next program computes the greatest common divisor of two numbers, using <em data-v-7c2d3108>Euclid's algorithm</em>.
    The algorithm uses two numbers and repeatedly takes the remainder after dividing
    one by the other. The remainder obtained is then used to replace the dividend.
    The process is repeated as long as the potential divisor is positive. So, unlike
    the previous programs, we cannot use the <code data-v-7c2d3108>times</code> combinator. Instead
    a combinator called <code data-v-7c2d3108>while</code> is used which resembles while-loops in imperative
    languages. It takes two parameters: the while-part is a quoted program which must
    return a truth value, and the do-part is a quoted program which can compute anything.
    The while-part in the following <kbd data-v-7c2d3108>gcd</kbd> program is of course very similar
    to a corresponding part in the <code data-v-7c2d3108>fib</code> program.
  <pre data-v-7c2d3108>    gcd  ==  [0 >] [dup [rem] dip swap] while pop
  </pre><p data-v-7c2d3108>
    Two other arithmetic functions that are sometimes useful are for computing the <kbd data-v-7c2d3108>sum</kbd>  or the <kbd data-v-7c2d3108>product</kbd> of a set or a list of numbers. Both are best implemented
    by <kbd data-v-7c2d3108>step</kbd>ping through all members of the set or list, doing additions
    or multiplications with an accumulator every time. The initial accumulator value,
    <code data-v-7c2d3108>0</code> or <code data-v-7c2d3108>1</code>, is first pushed onto the stack below the parameter
    set or list. For comparison, the third line below gives a definition of the <kbd data-v-7c2d3108>size</kbd>  operator which is applicable to any aggregate. The fourth line below gives a definition
    of a similar operator
    <kbd data-v-7c2d3108>size2</kbd> for determining the total number of elements in a list of aggregates.
    If these aggregates are themselves lists, then their members are counted but not
    the members of their sublists.
  <pre data-v-7c2d3108>    sum     ==  0  swap  [+       ]  step
      product ==  1  swap  [*       ]  step
      size    ==  0  swap  [pop succ]  step
      size2   ==  0  swap  [size  + ]  step
  </pre>
  A generalisation of <code data-v-7c2d3108>size2</code> for counting the leaves in recursive
  lists or trees is <kbd data-v-7c2d3108>treesize</kbd>, defined later.
  <h1 data-v-7c2d3108>Sorted sequences</h1><p data-v-7c2d3108>
    The <em data-v-7c2d3108>sequence type</em>s of Joy are the <em data-v-7c2d3108>string type</em> and the <em data-v-7c2d3108>list type</em>.
    Values of these types can be ordered. Strings contain just characters, but lists
    may contain anything. So for lists it only makes sense to speak of ordering if
    the elements are characters or integers or something else that has an ordering
    defined on it.
  <p data-v-7c2d3108>
    An informal description of the <em data-v-7c2d3108>quicksort</em> algorithm is this:
  <pre data-v-7c2d3108>To sort a sequence S :
  1       If    S is small (has only 0 or 1 element)
  2             then it is sorted already, leave it alone
                else    (S has at least one element)
  3                     using     the first of S
                                  as a "pivot" for comparison,
                                  split the rest of S into two portions -
                                  those that are less than the pivot
                                  and those that are not
                        separately sort both portions P1 and P2
  4                     concatenate    the now sorted lesser portion,
                                       the pivot, and
                                       the sorted other portion.
  </pre>
  The following is a definitions of an operator <kbd data-v-7c2d3108>qsort</kbd> which uses
  the above algorithm. But instead of using explicit <em data-v-7c2d3108>binary recursion</em> it uses
  the <kbd data-v-7c2d3108>binrec</kbd> combinator. This is like the <code data-v-7c2d3108>linrec</code> combinator
  except that it recurses twice, once each on the top two element of the stack. The
  recursions again occur between the rec1-part and the rec2-part. The program also
  uses another combinator <kbd data-v-7c2d3108>split</kbd> which takes as parameter an aggregate and
  above that a quoted program which must return a truth value. The <code data-v-7c2d3108>split</code>combinator returns two aggregates, containing those elements for which the test yields
  <code data-v-7c2d3108>false</code> and those for which it yields <code data-v-7c2d3108>true</code>. The <code data-v-7c2d3108>split</code>combinator has access to the remainder of the stack which in this case contains the
  pivot. So the test determines whether the pivot is <code data-v-7c2d3108>></code> than the element
  being examined.
  <pre data-v-7c2d3108>    qsort  ==
  1       [ small ]
  2       [ ]
  3       [ uncons [>] split ]
  4       [ swap23 cons concat ]
          binrec
  </pre><p data-v-7c2d3108>
    Sometimes it is required to sort a list of aggregates on the basis of their first
    elements. In that case it is necessary to supply to the comparison operator <code data-v-7c2d3108>></code>  not the pivot and the element to be apportioned by <code data-v-7c2d3108>split</code>, but their
    first elements instead. This is conveniently done by the <kbd data-v-7c2d3108>app2</kbd> combinator
    which applies a quoted program to two elements on top of the stack and replaces
    them by whatever values the programs return.
  <pre data-v-7c2d3108>    qsort1  ==
  1       [ small ]
  2       [ ]
  3       [ uncons [[first] app2 > ] split ]
  4       [ swap23 cons concat ]
          binrec
  </pre><p data-v-7c2d3108>
    Note that in part 3 when the first element of the pivot has to be compared with the
    first element of the aggregate to be apportioned, the first element of the pivot
    is being extracted every time. It would perhaps be more efficient if the first
    element of the pivot is extracted just once, as soon as the pivot is available.
    In that case it is necessary to take the pivot apart with
    <code data-v-7c2d3108>unswons</code>, but this has to be done by <code data-v-7c2d3108>dip</code>ping below the
    rest of the list still to be sorted. Then the quotation parameter to <code data-v-7c2d3108>split</code>  just needs to take out the <code data-v-7c2d3108>first</code> of the current aggregate and compare
    it with the first of the pivot. After <code data-v-7c2d3108>split</code> has done its job, the
    pivot has to be re-assembled by <code data-v-7c2d3108>swons</code>, but this now has to be done
    below the two portions with <kbd data-v-7c2d3108>dip2</kbd>. So part 3 can be replaced by
  <pre data-v-7c2d3108>3       [ uncons [unswons] dip [first >] split [swons] dip2 ]
  </pre><p data-v-7c2d3108>
    Sometimes it might be necessary to sort a list of items on the basis not of their
    first element but on their size or their second or third element or even the size
    of the second of the third element. For the last example it would only be necessary
    to use <code data-v-7c2d3108>[third second size]</code> instead of <code data-v-7c2d3108>[first]</code> in the
    <code data-v-7c2d3108>qsort1</code> program. But it would be impossible to anticipate all alternative
    sorting bases for a library, and it would be awkward to have to write the appropriate
    sorting program on every special occasion. It is possible to write a general quicksort
    program which takes as an additional parameter something like
    <code data-v-7c2d3108>[first]</code> or <code data-v-7c2d3108>[third second size]</code>. The <kbd data-v-7c2d3108>mk-qsort</kbd>  combinator does just that:
  <pre data-v-7c2d3108>    mk_qsort ==
          [ [small] [] ] dip
          [ app2 >] cons [split] cons [uncons] swoncat
          [ swap23 cons concat ]
          binrec
  </pre>
  It begins in line 1 by inserting the standard if-part and then-part below
  its parameters. In line 2 it uses the parameter to build a <em data-v-7c2d3108>constructed program</em>,
  the required rec1-part. Then in line 3 it pushes the standard rec2-part. At this
  point the top five elements of the stack are the list to be sorted and above that
  the four program parts needed for <code data-v-7c2d3108>binrec</code>. The latter now executes. For
  example the program
  <pre data-v-7c2d3108>        [third second size]  mk-qsort
  </pre>
  will sort a list of lists of three or more elements whose third member are
  aggregates of two or more elements. It will sort according to the size of the second
  of the third element.
  <p data-v-7c2d3108>
    The binary operator <kbd data-v-7c2d3108>insert</kbd> takes a sorted sequence and a potential new
    member as parameters, it returns a new sequence with the additional member inserted
    in the appropriate position. Here is a draft program:
  <pre data-v-7c2d3108>To insert an item into a sorted sequence :
  1       If    the sequence is empty or
                 its first element is >= than the item
  2             then add the new item in the front of the sequence
  3             else    set aside the first item of the sequence
                        recurse with the rest of the sequence and the new item
  4                     add the previously set aside first item to the front
  </pre>
  The disjunction in line 1 is best handled by the <kbd data-v-7c2d3108>disjoin</kbd> operator
  on programs. It expects two quoted programs which return a truth value, and it returns
  a single quoted program which computes their disjunction. So line 1 consists of two
  quoted programs one of them tests whether the sequence is empty, the other tests
  whether its first element is <code data-v-7c2d3108>>=</code> than the item to be inserted. The
  <code data-v-7c2d3108>disjoin</code> operator then produces their disjunction. The resulting program
  is the if-part for the <code data-v-7c2d3108>linrec</code> combinator. The other three parts are
  now quite obvious. So the definition in Joy is:
  <pre data-v-7c2d3108>    insert ==
  1       [ pop null ]  [ [first] dip ]  disjoin
  2       [ swons ]
  3       [ [uncons] dip ]
  4       [ cons ]
          linrec
  </pre><p data-v-7c2d3108>
    Two sorted sequences can be <kbd data-v-7c2d3108>merge</kbd>d into a single sequence which respects
    the original ordering. Here is a very informal algorithm for a recursive version:
  <pre data-v-7c2d3108>To merge two sorted sequences : 
          If    the first sequence is empty,
                then throw it away and return the second sequence.
          If the second sequence is empty,
                then throw it away and return the first sequence.
          (Both sequences are non-empty, so both have a first element:)
          If the first of the first sequence is less than the first of the second,
                then    set the lesser element aside,
                        recurse using the rest of the first sequence,
                        prepend the previously set aside element.
          If the first of the first sequence is greater than the first of the second,
                then set the lesser element aside,
                        recurse using the rest of the second sequence,
                        prepend the previously set aside element.
         (The two first elements of the sequences are equal:)
          Default  
                set both first elements aside,
                recurse using the rests of both sequences,
                prepend the two previously set aside elements.
  </pre><p data-v-7c2d3108>
    Like just about all programming languages, Joy has an if-then-else construct (<code data-v-7c2d3108>ifte</code>)
    for two-way branching. Multiway branching can be achieved by nested <code data-v-7c2d3108>ifte</code>s,
    but this can become difficult to read. Joy has another combinator for multi-way
    branching borrowed from Lisp. The combinator <kbd data-v-7c2d3108>cond</kbd> expects one parameter
    which is a list of cases. The last case is the default case, the other cases each
    consist of a condition or if-part and a program or then-part The condition is a
    quoted program in front of the program. Execution of the <code data-v-7c2d3108>cond</code> combinator
    tests successive conditions, and for the first condition that yields
    <code data-v-7c2d3108>true</code> the associated program is executed. If none of the conditions
    is true, the default case is executed. The informal algorithm given earlier now
    translates into the following recursive definition of <kbd data-v-7c2d3108>r-merge</kbd>:
  <pre data-v-7c2d3108>    r-merge  ==
          [ [ [null] pop]
            [ [pop null] swap pop]
            [ [unswons2 &lt;] [uncons] dip r-merge cons]
            [ [unswons2 >] uncons swap23 r-merge cons]
            [ uncons2 r-merge cons cons] ]
          cond
  </pre><p data-v-7c2d3108>
    As may be seen from the earlier informal version and the above Joy version, for each
    case the program recurses at most once. Therefore the program has the pattern of
    <em data-v-7c2d3108>linear recursion</em>. However, because there are three cases in which recursion
    occurs, it is not possible to use the <code data-v-7c2d3108>linrec</code> combinator. However,
    Joy has a combinator <kbd data-v-7c2d3108>condlinrec</kbd> which has features of <code data-v-7c2d3108>cond</code>  and <code data-v-7c2d3108>linrec</code>. The combinator <code data-v-7c2d3108>condlinrec</code> also expects one
    parameter which is a list of cases. Again the last case is the default case, and
    the other cases consist of a list of two or three quoted programs. If there are
    just two parts, then they are called the if-part and the then-part. Their meaning
    is as for <code data-v-7c2d3108>cond</code>. If there are three parts, then they are called the
    if-part, the rec1-part and the rec2-part. In that case linear recursion occurs
    between execution of the rec1-part and the rec2-part. The following is a non-recursive
    definition of <kbd data-v-7c2d3108>merge</kbd>:
  <pre data-v-7c2d3108>    merge ==
          [ [ [null] [pop] ]
            [ [pop null] [swap pop] ]
            [ [unswons2 &lt;] [[uncons] dip] [cons] ]
            [ [unswons2 >] [uncons swap23] [cons] ]
            [ [uncons2] [cons cons] ] ]
          condlinrec;
  </pre><p data-v-7c2d3108><p data-v-7c2d3108>
    Sometimes it is necessary to merge two lists of aggregates on the basis of their
    first elements. In that case the comparisons <code data-v-7c2d3108>&lt;</code> and <code data-v-7c2d3108>></code>  should not be applied to the elements of the sequences but to their first members.
    A simple solution is to replace the two comparisons respectively by the following
    two:
  <pre data-v-7c2d3108>        [first] app2 &lt;              [first] app2 >
  </pre>
  So the definition of the <kbd data-v-7c2d3108>merge1</kbd> operator could be
  <pre data-v-7c2d3108>    merge1 ==
          [ [ [null] [pop] ]
            [ [pop null] [swap pop] ]
            [ [unswons2 [first] app2 &lt;] [[uncons] dip] [cons] ]
            [ [unswons2 [first] app2 >] [uncons swap23] [cons] ]
            [ [uncons2] [cons cons] ] ]
          condlinrec
  </pre>
  The definition of <code data-v-7c2d3108>merge</code> (and especially <code data-v-7c2d3108>merge1</code>)
  could be optimised so that the <code data-v-7c2d3108>unswons</code> (and the <code data-v-7c2d3108>first</code>)
  is not done repeatedly for each comparison. As the definitions stand, they are easy
  to understand and work correctly.
  <h1 data-v-7c2d3108>Big sets and dictionaries</h1><p data-v-7c2d3108>
    Computer words are short bit-sequences and a common size is 32. These can be used
    to implement small sets of small numbers 0..31, with a few common set operations
    implemented in hardware. Joy uses this in its <em data-v-7c2d3108>set type</em>. But often it
    is necessary to have either much larger sets or sets of larger elements. Such a
    <em data-v-7c2d3108>big set type</em> can be implemented in various ways: as unordered lists, as
    ordered lists, as unbalanced trees or as balanced trees. Each implementation method
    has its advantages and disadvantages. The following implementation of big sets
    in terms of ordered lists has been adapted from \AX{Bird and Wadler}{1988 p 230
    ff}{Bird:88}.
  <p data-v-7c2d3108>
    The empty set is represented as an empty list, in this library it is written as <kbd data-v-7c2d3108>bs-new</kbd>.
  <pre data-v-7c2d3108>LIBRA (* big sets *)

  bs-new == [];
  </pre><p data-v-7c2d3108>
    One very important binary set operation is <em data-v-7c2d3108>union</em>. The two parameters are
    sorted lists, and the returned value also has to be a sorted list. It would appear
    that the two lists should be simply
    <kbd data-v-7c2d3108>merge</kbd>d. But if they have an element in common, then the returned list
    would then contain the element twice. However, in sets any element should occur
    at most once. This consideration affects the default case, the last case of the
    program list which is the parameter. The case occurs when the first elements of
    the two parameter lists are equal. So in the definition of <kbd data-v-7c2d3108>bs-union</kbd>  instead of saving and later restoring both, only one is saved and later restored.
  <pre data-v-7c2d3108>bs-union ==
          [ [ [null] [pop] ]
            [ [pop null] [swap pop] ]
            [ [unswons2 &lt;] [[uncons] dip] [cons] ]
            [ [unswons2 >] [uncons swap23] [cons] ]
            [ [rest [uncons] dip] [cons] ] ]
          condlinrec;
  </pre><p data-v-7c2d3108>
    The same situation arises for <em data-v-7c2d3108>insert</em>ing or adding a new member to a set.
    If the new member is already in the set, then it should not be inserted again.
    So if the first member of the current list is equal to the candidate new member,
    then the candidate is just popped off in the third line below. In the definition
    of <kbd data-v-7c2d3108>bs-insert</kbd> the only recursion occurs in the last, the default case.
  <pre data-v-7c2d3108>bs-insert ==
          [ [ [pop null] [swons] ]
            [ [[first] dip >] [swons] ]
            [ [[first] dip =] [pop] ]
            [ [[uncons] dip] [cons] ] ]
          condlinrec;
  </pre><p data-v-7c2d3108>
    The next operator tests for <em data-v-7c2d3108>member</em>ship, so it must return a truth value.
    If the list is null or its first element is <code data-v-7c2d3108>></code> than the candidate,
    then <code data-v-7c2d3108>false</code> is returned. If the first element is <code data-v-7c2d3108>=</code> to
    the candidate, then <code data-v-7c2d3108>true</code> is returned. In the default case, when the
    relation is <code data-v-7c2d3108>&lt;</code>, the list has to be inspected recursively further
    down. So the case must contain two programs to effect the recursion. However, on
    the way back from the recursion, the last returned truth value is the one to be
    used. Hence no further action is required, and the second program is just <code data-v-7c2d3108>[]</code>.
    This is the definition of <kbd data-v-7c2d3108>bs-member</kbd>:
  <pre data-v-7c2d3108>bs-member ==
          [ [ [pop null] [pop2 false] ]
            [ [[first] dip >] [pop2 false] ]
            [ [[first] dip =] [pop2 true] ]
            [ [[rest] dip] [] ] ]
          condlinrec;
  </pre><p data-v-7c2d3108>
    The same device is used in the default case of the definition of <kbd data-v-7c2d3108>bs-differ</kbd>  for finding the <em data-v-7c2d3108>difference</em> between two sets. As may be seen, there are
    two further recursive cases, for <code data-v-7c2d3108>&lt;</code> and <code data-v-7c2d3108>></code>, and one
    of them uses the same device again.
  <pre data-v-7c2d3108>bs-differ ==
          [ [ [null] [pop]]
            [ [pop null] [pop pop []] ]
            [ [unswons2 &lt;] [[uncons] dip] [cons] ]
            [ [unswons2 >] [rest] [] ]
            [ [[rest] dip rest] [] ] ]
          condlinrec;
  </pre><p data-v-7c2d3108>
    The next definition is for <kbd data-v-7c2d3108>bs-delete</kbd>, it <em data-v-7c2d3108>delete</em>s a specified
    member from a set, if it is a member at all. The only recursive case is the default
    case.
  <pre data-v-7c2d3108>bs-delete ==
          [ [ [pop null] [pop] ]
            [ [[first] dip >] [pop] ]
            [ [[first] dip =] [pop rest] ]
            [ [[uncons] dip] [cons] ] ]
          condlinrec.
  </pre><p data-v-7c2d3108>
    The operations of inserting or deleting members into or from a set are essentially
    special cases of taking unions or differences with unitsets. So the following definitions
    might have been given instead of the earlier, more efficient definitions:
  <pre data-v-7c2d3108>    bs-insert  ==  unitlist bs-union;
      bs-delete  ==  unitlist bs-differ;
  </pre><p data-v-7c2d3108>
    A dictionary is a way of implementing finite functions as argument-value pairs. A
    pair is best implemented in Joy as a two element list. The totality of pairs is
    then essentially a big set, and any of the ways of implementing these is suitable
    here. If the argument part of pairs is subject to an ordering relation, the sets
    of pairs can be implemented as lists ordered in accordance with the first element,
    the argument of the pairs. Not surprisingly then, some of the code to follow is
    reminiscent of code for <code data-v-7c2d3108>qsort1</code> and <code data-v-7c2d3108>merge1</code>. The following
    is a library for the <em data-v-7c2d3108>dictionary type</em>. A new dictionary is created by <kbd data-v-7c2d3108>d-new</kbd>.
    A predicate <kbd data-v-7c2d3108>d-null</kbd> returns <code data-v-7c2d3108>true</code> or <code data-v-7c2d3108>false</code> according
    as the parameter dictionary is empty or not. New pairs are added by <kbd data-v-7c2d3108>d-add</kbd>,
    they are inserted in the correct place based on the ordering of the first member
    of the pairs. The union or difference of two dictionaries is given by the two binary
    operators <kbd data-v-7c2d3108>d-union</kbd> and <kbd data-v-7c2d3108>d-differ</kbd>. A single pair is removed
    by the binary operator <kbd data-v-7c2d3108>d-rem</kbd>, it removes the pair whose first member
    matches the given query parameter. Instead of a test for membership there is a
    binary operator
    <kbd data-v-7c2d3108>d-look</kbd> which extracts the first pair whose first element matches the
    query.
  <p data-v-7c2d3108>
    Only the program for one of the operators will be developed here, the program for
    <kbd data-v-7c2d3108>d-union</kbd>:
  <pre data-v-7c2d3108>To form the union of two dictionaries D1 and D2:
  1       If D2 is empty, pop it off and return just D1
  2       If D1 is empty, retain D2, pop D1 and return D2
  3       Extract    the first pairs from D1 and D2,
                     from both pairs compare their firsts with &lt;
          If the comparison is true,
                     below D2, uncons D1 into its first
                     and rest
                     recurse anonymously on the rest of D1 and D2
                     cons the saved first pair from D1
                     into the result
  4       Extract    the first pairs from D1 and D2,
                     from both pairs compare their firsts with >
          If the comparison is true,
                     uncons D2, put its first below D2
                     recurse anonymously on D1 and the rest of D2
                     cons the saved first pair from D2
                     into the result
          Default (the firsts of the first pairs of D1 and D2
                      are =):
                     uncons both D1 and D2 into their
                     first and rest,
                     recurse on the two rests to form their union,
                     cons the two saved firsts into the result.
  </pre>
  In the default case both first pairs are retained, so that if one is deleted,
  the other one, which may well have a different second component, is still available.
  <p data-v-7c2d3108>
    As may be seen, the <kbd data-v-7c2d3108>d-union</kbd> operator is very similar to the <code data-v-7c2d3108>bs-union</code>  operator. The other three operators <kbd data-v-7c2d3108>d-differ</kbd>, <kbd data-v-7c2d3108>d-look</kbd> and
    <kbd data-v-7c2d3108>d-rem</kbd> are similar to their counterparts for big sets. The entire library
    is the following:
  <pre data-v-7c2d3108>LIBRA (* dictionary *)

  d_new   == [];
  d_null  == null;
  d_add   ==
          [ [ [pop null] [swons] ]
            [ [[first] dip [first] app2 >=] [swons] ]
            [ [[uncons] dip] [cons] ] ]
          condlinrec;
  d_union ==
          [ [ [null] [pop] ]
            [ [pop null] [popd] ]
            [ [unswons2 [first] app2 &lt;] [[uncons] dip] [cons] ]
            [ [unswons2 [first] app2 >] [uncons swap23] [cons] ]
            [ [uncons2] [cons cons] ] ]
          condlinrec;
  d_differ ==
          [ [ [null] [pop]]
            [ [pop null] [pop pop []] ]
            [ [unswons2 [first] app2 &lt;] [[uncons] dip] [cons] ]
            [ [unswons2 [first] app2 >] [rest] [] ]
            [ [[rest] dip rest] [] ] ]
          condlinrec;
  d_look  == [dup] dip
          [ [ [pop null] [pop pop "not found"] ]
            [ [[first first] dip >] [pop pop "not found"] ]
            [ [[first first] dip =] [pop first] ]
            [ [[rest] dip] [] ] ]
          condlinrec;
  d_rem   ==
          [ [ [pop null] [pop] ]
            [ [[first first] dip >] [pop] ]
            [ [[first first] dip =] [pop rest] ]
            [ [[uncons] dip] [cons] ] ]
          condlinrec.
  </pre>
  The definitions of big sets and dictionaries are part of the library file
  <kbd data-v-7c2d3108>TYPLIB.JOY</kbd>.
  <h1 data-v-7c2d3108>Trees</h1><p data-v-7c2d3108>
    Apart from the <em data-v-7c2d3108>aggregate type</em>s it is useful to have another type, the
    <em data-v-7c2d3108>tree type</em>. These are lists which can contain lists as members which might
    contain lists as members and so on. Formally define a <em data-v-7c2d3108> leaf</em> to be anything
    which is not a list. Then a <em data-v-7c2d3108> tree</em> is defined to be either a leaf or a
    list of trees. Sometimes one needs the concept of a <em data-v-7c2d3108> proper tree</em> -- this
    is just a list of trees. Trees are similar to other aggregates, but since the tree
    datatype is recursive, a special treatment is generally needed.
  <p data-v-7c2d3108>
    Just as there is the <code data-v-7c2d3108>step</code> combinator to step through the elements
    of an aggregate, so there is a <kbd data-v-7c2d3108>treestep</kbd> combinator to step through the
    leaves of a tree. For example, the following are the already familiar program for
    computing the sum of the numbers in an aggregate and a similar program for computing
    the sum of the numbers in a tree:
  <pre data-v-7c2d3108>            sum  ==  0 swap [+]     step
          treesum  ==  0 swap [+] treestep
  </pre>
  In the same way, the following are a familiar program and a new one for determining
  the <code data-v-7c2d3108>size</code> of an aggregate and the <kbd data-v-7c2d3108>treesize</kbd> of a tree:
  <pre data-v-7c2d3108>            size  ==  0 swap [pop succ]     step
          treesize  ==  0 swap [pop succ] treestep
  </pre>
  Similarly, the following are a familiar program and a new one for shunting
  members of an aggregate or a tree, respectively, into an initially empty list:
  <pre data-v-7c2d3108>            shunt  ==  [swons]     step
          treeshunt  ==  [swons] treestep
  </pre>
  For the binary operator <kbd data-v-7c2d3108>treeshunt</kbd> the all leaves will appear in
  the result list, but in reverse order.
  <p data-v-7c2d3108>
    A tree may be flattened completely, losing its entire internal structure but retaining
    the order of the leaves by the unary operator
    <kbd data-v-7c2d3108>treeflatten</kbd>:
  <pre data-v-7c2d3108>        treeflatten  ==  [] swap treeshunt reverse
  </pre><p data-v-7c2d3108>
    From a given tree we can obtain the reverse list of its leaves by
  <pre data-v-7c2d3108>        []  swap  treeshunt
  </pre>
  But this may not be what is wanted. To reverse the tree while retaining its
  structure it is necessary to reverse the top level list, reverse the second level
  lists, reverse the third level lists and so on. For tasks such as this Joy has a
  ternary combinator <kbd data-v-7c2d3108>treegenrec</kbd> for general recursion through trees. It
  is used like this:
  <pre data-v-7c2d3108>        [O1]  [O2]  [C]  treerecgen
  </pre>
  Here <code data-v-7c2d3108>[O1]</code> must be a program applicable to leaves,
  <code data-v-7c2d3108>[O2]</code> must be an operator applicable to lists, and <code data-v-7c2d3108>[C]</code> must
  be a combinator applicable to lists with operators such as <code data-v-7c2d3108>[O2]</code>. Different
  choices of the three quotation parameters yield surprisingly different operators
  for trees or combinators applicable to trees. Using this combinator the unary <kbd data-v-7c2d3108>treereverse</kbd>operator is defined by
  <pre data-v-7c2d3108>        treereverse  ==  [] [reverse] [map] treegenrec
  </pre><p data-v-7c2d3108>
    The same <code data-v-7c2d3108>treegenrec</code> combinator can be used to define a unary combinator
    <kbd data-v-7c2d3108>treemap</kbd> which takes a tree and quoted program as parameters and returns
    a tree of the same structure but with each leaf as modified by the program parameter.
  <pre data-v-7c2d3108>        treemap  ==  [] [map] treegenrec
  </pre><p data-v-7c2d3108>
    The same combinator can be used to define a unary combinator
    <kbd data-v-7c2d3108>treefilter</kbd> which expects a tree and a quoted predicate. What is returned
    is a tree of the same structure but with only those leaves which pass the test
    predicate.
  <pre data-v-7c2d3108>        treefilter  ==  [] swap orlistfilter [map] treegenrec
  </pre>
  The first portion, <code data-v-7c2d3108>[] swap</code> just inserts the required <code data-v-7c2d3108>[O1]</code>which in this case does nothing. Following that is a modification of the test predicate,
  to be explained presently. The rest of the definition is familiar.
  <pre data-v-7c2d3108>        treefilter  ==  [] swap orlistfilter [map] treegenrec
  </pre>
  The <code data-v-7c2d3108>[O2]</code> operator to be used here is constructed from the test
  predicate <code data-v-7c2d3108>[P]</code> by <kbd data-v-7c2d3108>orlistfilter</kbd>, which constructs
  <pre data-v-7c2d3108>        [ [ [list] [P] disjoin ]  filter ]
  </pre>
  The <code data-v-7c2d3108>orlistfilter</code> is defined in two steps:
  <pre data-v-7c2d3108>        orlist  ==  [list] swap disjoin
          orlistfilter  ==  orlist [filter] cons
  </pre>
  An operator to remove all leaves from a tree, but retaining its list structure
  is <kbd data-v-7c2d3108>treestrip</kbd>, defined as follows:
  <pre data-v-7c2d3108>        treestrip  ==  [list] treefilter
  </pre><p data-v-7c2d3108>
    Trees cannot have lists as leaves, but otherwise they are very flexible. In particular
    they can be used as queues. The following is a small collection of operations for
    manipulating trees when the focus is only on their leaves. A new empty tree is
    generated by <kbd data-v-7c2d3108>t-new</kbd>. A new leaf or a whole tree of leaves is added
    to an existing tree by the operator <kbd data-v-7c2d3108>t-add</kbd>; it always ensures that the
    tree is of a form suitable for the remaining operators. The tree predicate <kbd data-v-7c2d3108>t-null</kbd>  tests whether the tree is empty. It first has to prepare the tree by ensuring that
    it does not consist of lists of lists and so on which ultimately only contain the
    empty list. Since this is also required by two other operators, the preparing is
    done by a hidden unary operator. Two other operator <kbd data-v-7c2d3108>t-front</kbd> and <kbd data-v-7c2d3108>t-rem</kbd>  produce, respectively, the first leaf together with the remainder of the tree,
    or just the remainder of the tree after removing the first leaf. Both operators
    first have to check that the tree is non-empty; if it is, then an error is reported.
    A leaf or proper tree can be turned into a suitable form by <kbd data-v-7c2d3108>t-reset</kbd>.
  <p data-v-7c2d3108>
    The implementation is as follows. A proper tree is always a list, and an empty tree
    starts off by <kbd data-v-7c2d3108>t-new</kbd> as an empty list. Anything can be added by <kbd data-v-7c2d3108>t-add</kbd>  to an existing tree, and this has to ensure that the result has a suitable standard
    form. The same is true for <kbd data-v-7c2d3108>t-reset</kbd> which firstmakes a copy of an existing
    tree. The other operators, <kbd data-v-7c2d3108>t-null</kbd>, <kbd data-v-7c2d3108>t-front</kbd> and <kbd data-v-7c2d3108>t-rem</kbd>  all require the tree to be in a suitable standard form. This is done by <code data-v-7c2d3108>prepare</code>  which is defined using <kbd data-v-7c2d3108>condlinrec</kbd>. If the tree is <code data-v-7c2d3108>null</code>,
    it is left as it is. If the <code data-v-7c2d3108>first</code> is <code data-v-7c2d3108>null</code>, then the <code data-v-7c2d3108>rest</code>  is taken and <code data-v-7c2d3108>condlinrec</code> recurses. If the <code data-v-7c2d3108>first</code> of the
    <code data-v-7c2d3108>first</code> is a list, then that is <code data-v-7c2d3108>unswonsed</code>, <code data-v-7c2d3108>condlinrec</code>  recurses and on return does nothing further. In all other cases the tree is left
    as it is.
  <pre data-v-7c2d3108>HIDE                                                    (* tree *)
      error        ==  "non-empty tree needed for" putchars putchars abort;
      prepare      ==  [ [ [null] [] ]
                       [ [first null] [rest] [] ]
                       [ [first first list] [[unswons] infra] [] ]
                       [ [] ] ]
                       condlinrec
  IN
      t-new        ==  [];
      t-reset      ==  dup  unitlist unitlist;
      t-add        ==  unitlist unitlist cons;
      t-null       ==  prepare
                       dup null;
      t-front      ==  prepare
                       [null]
                       ["t-front\n" error]
                       [dup first first]
                       ifte;
      t-rem        ==  prepare
                       [null]
                       ["t-rem\n" error]
                       [unswons unswons [swons] dip]
                       ifte
  END
  </pre><p data-v-7c2d3108>
    The definitions of trees is partof the library file <kbd data-v-7c2d3108>TYPLIB.JOY</kbd>.
  </article></div></main><footer data-v-c785faa8><p data-v-c785faa8><a href="https://github.com/joy-language/joy-lang.org" data-v-c785faa8>GitHub</a></footer></div></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{},{}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.10669f42b2e188f55eb1.js"></script><script defer src="/_nuxt/layouts/default.29c0e08e13310e3682fc.js"></script><script defer src="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js"></script><script defer src="/_nuxt/pages/papers-on-joy/programming-in-joy.d4bc3bc57b9855085dc1.js"></script><script defer src="/_nuxt/vendor.230cb916d1973aa790f3.js"></script><script defer src="/_nuxt/app.0a856c7cf6fb3e349fa2.js"></script>
  

