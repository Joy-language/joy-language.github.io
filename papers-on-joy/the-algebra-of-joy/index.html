<!DOCTYPE html>
<html data-n-head="" data-n-head-ssr>
  <head>
    <meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Joy Programming Language" name="description" data-hid="description"><title data-n-head="true">Joy language</title><link href="https://fonts.googleapis.com/css?family=Fira+Sans:200,500|Roboto:400|Roboto+Mono:400" rel="stylesheet" data-n-head="true"><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/favicon.ico?" rel="shortcut icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.10669f42b2e188f55eb1.js" rel="preload" as="script"><link href="/_nuxt/vendor.230cb916d1973aa790f3.js" rel="preload" as="script"><link href="/_nuxt/app.0a856c7cf6fb3e349fa2.js" rel="preload" as="script"><link href="/_nuxt/layouts/default.29c0e08e13310e3682fc.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/the-algebra-of-joy.7f385b55e84045676f24.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/survey-of-reproducing-programs.ed8409adcfb2bdec6eeb.js" rel="prefetch"><link href="/_nuxt/pages/libraries-and-c-sources.d2ffa370ff989df9d359.js" rel="prefetch"><link href="/_nuxt/pages/index.73b5e04f9a3fcda5b5fe.js" rel="prefetch"><link href="/_nuxt/pages/about.a3431c5910b96e7d0298.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-annoying-quadratic-formula.a3d9ef30d4f74df89dfd.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/church-arithmetic-and-church-logic-with-brent-kirby.e11588a1a251690d41af.js" rel="prefetch"><link href="/_nuxt/pages/rationale-for-joy.3e067852511f512169f0.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/tutorial-on-joy.9a4df70c3d63708c2b23.js" rel="prefetch"><link href="/_nuxt/pages/overview-of-joy.8733ad0cbce5d065d604.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/miscellaneous-miniature-implementations-of-joy.417498df53623dd27f3a.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/fast-small-truth-tables.9b1b75741215fa7afac3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/programming-in-joy.d4bc3bc57b9855085dc1.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-matrix-multiplication-programs.8e00ebe2e6e430523681.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/imperative-thinking-for-joy-programs.223ec58c271bc7112421.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-a-joy-interpreter-written-in-joy.eaa748fa0ea2130e1164.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/joy-compared-with-other-functional-languages.e9b1e34a3b81758a64f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/recursion-theory-and-joy.7d268252a6e6c71fa9f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/nested-recursion-and-a-new-recursion-combinator.d40eac9bf6ad0e5cac92.js" rel="prefetch"><link href="/_nuxt/pages/faq.9ffdbd52d27b2df75f94.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/mathematical-foundations-of-joy.4f0b584e560cf803bb24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/floy-a-flat-concatenative-subset-of-joy.9162d7b51e29e1b5b1b9.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/html-manual.e3473b0453170639a088.js" rel="prefetch"><link href="/_nuxt/pages/faq-part-2.9630745e3aaebc47633f.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/lazy-lists-as-reproducing-programs.9516d2d5134cfed90ce3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-current-implementation.e033c23017443bc35c24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/a-rewriting-system-for-joy.4157d6f1ef190fb675ea.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/atomic-programs-of-joy.f2cb1414ae2b6ed9401e.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/prospectus-for-john-cowans-joy1.cb4661329c1ed2df6752.js" rel="prefetch"><style data-vue-ssr-id="d505b096:0">html{font-family:Roboto,Arial,sans-serif;margin:0;font-weight:400;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box}body{margin:0;height:100%}:after,:before,:not(pre){-webkit-box-sizing:border-box;box-sizing:border-box;margin:0}.wrapper{min-height:calc(100vh - 102px)}a{color:#3273dc;text-decoration:none}a:hover{text-decoration:underline}</style><style data-vue-ssr-id="6cc65792:0">nav[data-v-251e63b6]{background-color:#000}ul[data-v-251e63b6]{list-style-type:none;padding:0;margin:0}li[data-v-251e63b6]{-webkit-transition:all .2s ease-out;transition:all .2s ease-out;display:inline-block;padding:0;cursor:pointer}li[data-v-251e63b6]:hover{-webkit-transform:scale(1.04);transform:scale(1.04);background-color:#fff;color:#000}li a[data-v-251e63b6]{display:block;padding:15px 25px;text-decoration:none;color:#fff;text-align:center}li:hover a[data-v-251e63b6]{color:#000}.nuxt-link-exact-active[data-v-251e63b6]{text-decoration:overline}</style><style data-vue-ssr-id="23d2604d:0">h1[data-v-7e83a563]{font-size:26px}.lists[data-v-7e83a563]{margin-top:37px;padding-left:12vw;padding-right:12vw}.top-list-item[data-v-7e83a563]{margin-top:11px}li[data-v-7e83a563]{line-height:39px}.no-style-litem[data-v-7e83a563]{list-style-type:none}ul[data-v-7e83a563]{list-style-type:circle}h6[data-v-7e83a563]{font-size:17px}p[data-v-7e83a563]{margin-top:8px;line-height:24px;font-size:16px}</style><style data-vue-ssr-id="cea73b4e:0">p[data-v-fe51c94a]{margin-top:16px;margin-bottom:16px}hr[data-v-fe51c94a]{margin-bottom:16px}pre[data-v-fe51c94a]{margin-bottom:auto}code[data-v-fe51c94a],kbd[data-v-fe51c94a],pre[data-v-fe51c94a]{font-family:Roboto Mono,monospace}</style><style data-vue-ssr-id="ca9343dc:0">footer[data-v-c785faa8]{padding:11px 20px 0;height:52px}p[data-v-c785faa8]{-webkit-transition:all .1s ease-in;transition:all .1s ease-in;font-size:15px;float:right;margin:0 16px}a[data-v-c785faa8]{color:#000;text-decoration:none}p[data-v-c785faa8]:hover{-webkit-transform:scale(.94);transform:scale(.94);color:#000;-webkit-text-decoration:#3273dc overline;text-decoration:#3273dc overline}</style>
  </head>
  <body data-n-head="">
    <div id="__nuxt" data-server-rendered="true"><div id="__layout"><div class="container" lang="en"><nav data-v-251e63b6 role="navigation"><ul data-v-251e63b6><li data-v-251e63b6><a href="/" data-v-251e63b6 class="nuxt-link-active">Home</a><li data-v-251e63b6><a href="/papers-on-joy" data-v-251e63b6 class="nuxt-link-active">Papers</a><li data-v-251e63b6><a href="/libraries-and-c-sources" data-v-251e63b6>Libraries/C sources</a><li data-v-251e63b6><a href="/about" data-v-251e63b6>About</a></ul></nav><main class="lists" data-v-7e83a563><div data-v-7e83a563><article data-v-fe51c94a data-v-7e83a563 data-v-7e83a563><h1 data-v-fe51c94a>The Algebra of Joy</h1><i data-v-fe51c94a> by Manfred von Thun </i><p data-v-fe51c94a><em data-v-fe51c94a>Abstract:</em> Joy is a functional programming language which is not based
    on the application of functions to arguments but on the composition of functions.
    The language makes extensive use of combinators which perform the role of higher
    order functions. The algebra of Joy programs can be used to express formal properties
    of many first and second order functions without using variables ranging over values
    or over functions. Some of these properties are idempotency, inverses, converses,
    commutativity, symmetry, associativity, homomorphisms and distribution. The paper
    also gives several analogues of concepts from category theory.
  <p data-v-fe51c94a><em data-v-fe51c94a>Keywords:</em> functional programming, function composition, algebra of programs,
    monoids, categories, functors, natural transformations, monads.
  <hr data-v-fe51c94a><h2 data-v-fe51c94a>Introduction</h2>
  This paper describes a rich algebra of Joy programs which can be used for formal
  manipulation of Joy programs. Concatenation of Joy programs denote the composition
  of the functions which the concatenated parts denote. Hence if <code data-v-fe51c94a> Q1 </code>and <code data-v-fe51c94a> Q2
  </code> are programs which denote the same function and <code data-v-fe51c94a> P
  </code> and <code data-v-fe51c94a> R </code> are other programs, then the two concatenations <code data-v-fe51c94a> P Q1 R </code>and <code data-v-fe51c94a> P Q2 R </code> also denote the same function. In other words, programs
  <code data-v-fe51c94a> Q1 </code> and <code data-v-fe51c94a> Q2 </code> can replace each other in concatenations.
  This can serve as a rule of inference for <em data-v-fe51c94a>rewriting</em>.
  <p data-v-fe51c94a>
    As premises one needs axioms such as in the first three lines below, and definitions
    such as in the fourth line:
  <pre data-v-fe51c94a>(+)                2  3  +   ==   5
  (dup)              5  dup   ==   5  5
  (*)                5  5  *   ==   25
  (def square)       square  ==  dup *
  </pre>
  A derivation using the above axioms and the definition looks like this:
  <pre data-v-fe51c94a>                   2  3  +  square
             ==      5  square                               (+)
             ==      5  dup  *                               (def square)
             ==      5  5  *                                 (dup)
             ==      25                                      (*)
  </pre>
  The comments in the right margin explain how a line was obtained from the
  previous line. The derivation shows that the expressions in the first line and the
  last line denote the same function, or that the function in the first line is identical
  with the function in the last line.
  <p data-v-fe51c94a>
    Consider the following equations in infix notation: The first says that multiplying
    a number <code data-v-fe51c94a>x</code> by 2 gives the same result as adding it to itself. The
    second says that the <kbd data-v-fe51c94a>size</kbd> of a
    <kbd data-v-fe51c94a>reverse</kbd>d list is the same as the <code data-v-fe51c94a>size</code> of the original list.
  <pre data-v-fe51c94a>        2 * x  =  x + x                 size(reverse(x))  =  size(x)
  </pre>
  In Joy the same equations would be written, <em data-v-fe51c94a> without
  variables</em>, like this:
  <pre data-v-fe51c94a>        2  *   ==   dup  +              reverse  size   ==   size
  </pre><p data-v-fe51c94a>
    Other equivalences express algebraic properties of various operations. For example,
    the predecessor <kbd data-v-fe51c94a>pred</kbd> of the successor
    <kbd data-v-fe51c94a>succ</kbd> of a number is just the number itself. The conjunction <kbd data-v-fe51c94a>and</kbd>  of a truth value with itself gives just the truth value. The less than relation
    <code data-v-fe51c94a>&lt;</code> is the converse of the greater than relation <code data-v-fe51c94a>></code>.
    Inserting a number with
    <kbd data-v-fe51c94a>cons</kbd> into a list of numbers and then taking the
    <kbd data-v-fe51c94a>sum</kbd> of that gives the same result as first taking the sum of the list
    and then adding the other number.
  <p data-v-fe51c94a>
    In conventional notation these are expressed by
  <pre data-v-fe51c94a>        pred(succ(x))  =  x             x and x  =  x
          x &lt;y  =  y > x                 sum(cons(x,y))  =  x + sum(y)
  </pre>
  In Joy these are expressed <em data-v-fe51c94a> without variables</em><pre data-v-fe51c94a>        succ  pred   ==   id            dup  and   ==   id
          &lt;  ==   swap >                 cons  sum   ==   sum  +
  </pre>
  Some properties of operations have to be expressed by combinators. One of
  these is the <kbd data-v-fe51c94a>dip</kbd> combinator which expects a program on top of the stack
  and below that another value. It saves the value, executes the program on the remainder
  of the stack and then restores the saved value.
  <p data-v-fe51c94a>
    In the first example below, the <code data-v-fe51c94a>dip</code> combinator is used to express
    the associativity of addition. Another combinator is the
    <kbd data-v-fe51c94a>app2</kbd> combinator which expects a program on top of the stack and below
    that two values. It applies the program to the two values. In the second example
    below it expresses one of the De Morgan laws. In the third example it expresses
    that the <code data-v-fe51c94a>size</code> of two lists <kbd data-v-fe51c94a>concat</kbd>enated is the sum of the
    <code data-v-fe51c94a>size</code>s of the two concatenands. The last example uses both combinators
    to express that multiplication distributes (from the right) over addition. (Note
    that the program parameter for <code data-v-fe51c94a>app2</code> is first constructed from the
    multiplicand and <code data-v-fe51c94a>*</code>.)
  <pre data-v-fe51c94a>        [+]  dip  +   ==   +  +
          and  not   ==   [not]  app2  or
          concat  size   ==   [size]  app2  +
          [+]  dip  *   ==   [*]  cons  app2  +
  </pre><p data-v-fe51c94a>
    The remainder of this paper is organised as follows: The next five sections give
    detailed examples of algebraic laws which Joy operators satisfy. All of these laws
    are well known when expressed in familiar notation, what is new here is that they
    can be expressed in Joy notation without the use of implicitly or explicitly universally
    quantified variables. Then follow three sections using concepts from category theory,
    but no previous knowledge is assumed.
  <h2 data-v-fe51c94a>Idempotency, inverses and unit elements</h2>
  A unary function <code data-v-fe51c94a>f(x)</code> is said to be <em data-v-fe51c94a>idempotent</em> if applying
  it once is "as good as" applying it twice. In conventional notation this means that
  for all <code data-v-fe51c94a>x</code><pre data-v-fe51c94a>        f(f(x))  =  f(x)
  </pre>
  For example, the function <kbd data-v-fe51c94a>abs</kbd> which returns the absolute value
  of a number is idempotent. Another one is the function defined on lists or strings
  which returns a sorted version - sorting an already sorted sequence makes no difference.
  <pre data-v-fe51c94a>        abs(abs(n))  =  abs(n)          sort(sort(s))  =  sort(s)
  </pre>
  Composition can be used to express that stack operations are
  <em data-v-fe51c94a>idempotent</em>. The following express the idempotency of
  <kbd data-v-fe51c94a>abs</kbd> and <kbd data-v-fe51c94a>sort</kbd>:
  <pre data-v-fe51c94a>        abs abs  ==  abs                sort sort  ==  sort
  </pre>
  Another idempotent Joy function, one which has no counterpart in conventional
  notation, is the <kbd data-v-fe51c94a>newstack</kbd> function, it throws away anything that is on
  the stack. Doing it twice in succession gives the same result as doing it once:
  <pre data-v-fe51c94a>        newstack  newstack   ==   newstack
  </pre><p data-v-fe51c94a>
    The remainder of this section illustrates the use of the <em data-v-fe51c94a>identity
    function</em> in Joy algebra. This function is denoted by the symbol
    <kbd data-v-fe51c94a>id</kbd>. It has the property that for all programs
    <code data-v-fe51c94a>P</code>,
  <pre data-v-fe51c94a>        id  P   ==   P   ==   P  id
  </pre><p data-v-fe51c94a>
    Let <code data-v-fe51c94a>f(x)</code> be a unary function. Another unary function
    <code data-v-fe51c94a>g(x)</code> is said to be its <em data-v-fe51c94a>inverse</em> if for all
    <code data-v-fe51c94a>x</code><pre data-v-fe51c94a>        g(f(x))  =  x
  </pre>
  For example, the predecessor function on integers is the inverse of the successor
  function on integers: for all integers <code data-v-fe51c94a>x</code><pre data-v-fe51c94a>        pred(succ(x))  =  x
  </pre>
  It may or may not be that if one function is the inverse of a second then
  the second is the inverse of the first. This is true of the predecessor and successor
  functions when defined on integers, but not when defined on natural numbers. The
  identity function can be used to express that one function is the inverse of another
  and that certain values are unit elements.
  <p data-v-fe51c94a>
    The atomic program <kbd data-v-fe51c94a>succ</kbd> denotes a function which takes a stack as argument
    and yields a stack as value. The argument stack has to have an integer (or a character)
    on top. The value stack is like the argument stack except that the integer (or
    character) has been incremented by 1. The semantics for <kbd data-v-fe51c94a>pred</kbd> is analogous,
    it decrements the integer (or character). The following express that the functions
    denoted by the symbols <code data-v-fe51c94a>succ</code> and
    <code data-v-fe51c94a>pred</code> are <em data-v-fe51c94a>inverse</em>s of each other:
  <pre data-v-fe51c94a>        pred succ  ==  id               succ pred  ==  id
  </pre><p data-v-fe51c94a>
    The <kbd data-v-fe51c94a>cons</kbd> function expects a list on top of the argument stack. Below
    that it expects another value. The value that is returned is another stack which
    is like the argument stack except that the two top elements of the argument stack
    have been replaced by a new list which has the value inserted into it at the front.
    The
    <kbd data-v-fe51c94a>uncons</kbd> function undoes this. It expects a non-empty list and leaves
    the first and the rest of the list. The two functions are inverses of each other:
  <pre data-v-fe51c94a>        cons uncons  ==  id             uncons cons  ==  id
  </pre>
  It is worth pointing out this cannot be expressed in conventional notation
  because there the <code data-v-fe51c94a>uncons</code> operation makes no sense. Actually, both functions
  are polymorphic in that instead of lists they can operate on strings or on sets The
  two equations still hold applied to strings. Only the right equation holds for sets.
  <p data-v-fe51c94a>
    The symbols <kbd data-v-fe51c94a>pairlist</kbd>, <kbd data-v-fe51c94a>pairstring</kbd> and
    <kbd data-v-fe51c94a>pairset</kbd> denote functions which expect two potential members of lists,
    strings or sets on top of the stack. They return a new stack with the two members
    replaced by a single list, string or set. The polymorphic <kbd data-v-fe51c94a>unpair</kbd> function
    is their inverse, but not vice versa. Since <code data-v-fe51c94a>unpair</code> leaves two results,
    the following have no counterpart in conventional notation.
  <pre data-v-fe51c94a>        pairlist unpair  ==  id
          pairstring unpair  ==  id
          pairset unpair  ==  id
  </pre><p data-v-fe51c94a>
    Some functions are inverses of themselves. Examples of
    <em data-v-fe51c94a>self-inverse</em> functions are the Boolean negation function and the list
    reversal function: for all Boolean values <code data-v-fe51c94a>b</code> and for all lists <code data-v-fe51c94a>l</code><pre data-v-fe51c94a>        not(not(b))  =  b               reverse(reverse(l))  =  l
  </pre>
  In Joy the two unary operators <kbd data-v-fe51c94a>not</kbd> and <kbd data-v-fe51c94a>reverse</kbd> are polymorphic.
  The <code data-v-fe51c94a>not</code> operator expects a truth value or a set on top of the stack
  and returns a stack which has the complementary truth value or set on top of the
  stack. The
  <code data-v-fe51c94a>reverse</code> operator expects a list or a string on top of the stack and
  returns a stack which has the reversal the list or string on top of the stack. The
  two functions are self-inverses, and this is expressed by
  <pre data-v-fe51c94a>        not not  ==  id                 reverse reverse  ==  id
  </pre><p data-v-fe51c94a>
    Let <code data-v-fe51c94a>f(x,y)</code> be a binary function. A constant
    <code data-v-fe51c94a>c</code> is called a left or right <em data-v-fe51c94a>unit element</em> if the first or
    the second equation holds for all <code data-v-fe51c94a>x</code><pre data-v-fe51c94a>        f(c,x)  =  x                    f(x,c)  =  x
  </pre>
  Left and right unit elements often coincide, and then they are just called
  unit elements. In particular, this is true for the unit elements of commutative functions.
  For example, 0 is the unit element for addition, and 1 is the unit element for multiplication.
  In conventional infix notation:
  <pre data-v-fe51c94a>        n + 0  =  n  =  0 + n            n * 1  =  n  =  1 * n
  </pre><p data-v-fe51c94a>
    The identity function can also be used to express that certain literals are <em data-v-fe51c94a>right unit</em>  elements for binary operations: 0 for addition, 1 for multiplication, the <em data-v-fe51c94a>empty string</em><code data-v-fe51c94a>""</code> or the <em data-v-fe51c94a>empty list</em><code data-v-fe51c94a>[]</code> for concatenation, the
    truth value <kbd data-v-fe51c94a>false</kbd> and the <em data-v-fe51c94a>empty
    set</em><code data-v-fe51c94a>{}</code> for logical disjunction and set union, and the truth value
    <kbd data-v-fe51c94a>true</kbd> for logical conjunction.
  <pre data-v-fe51c94a>        0 +  ==  id                     1 *  ==  id
          "" concat  ==  id               [] concat  ==  id
          false or  ==  id                {} or  ==  id
          true and  ==  id
  </pre><h2 data-v-fe51c94a>Idempotency, zero elements and arities</h2>
  This section illustrates the <code data-v-fe51c94a>dup</code> and <code data-v-fe51c94a>pop</code> operators in
  Joy algebra. The Joy operator <kbd data-v-fe51c94a>dup</kbd> expects one value on top of the stack
  and pushes a duplicate on top. For example,
  <pre data-v-fe51c94a>        42 dup  ==  42 42
  </pre>
  Both sides of the equation denote compositions of two functions. On the left
  the first function pushes a number and the second makes a duplicate of the top element.
  On the right the two functions are the same, each pushes a number. The equation says
  that the function on the left is identical to the one on the right. Both functions
  are defined for all stacks, and both return a stack which is like the argument stack
  except that two copies of the number 42 have been pushed.
  <p data-v-fe51c94a>
    A binary function <code data-v-fe51c94a>f(x,y)</code> is called <em data-v-fe51c94a>idempotent</em> if for all
    <code data-v-fe51c94a>x</code><pre data-v-fe51c94a>        f(x,x)  =  x
  </pre>
  Two examples are the Boolean conjunction and disjunction operations: for all
  <code data-v-fe51c94a>b</code><pre data-v-fe51c94a>        b and b  =  b                   b or b  =  b
  </pre>
  In Joy the <code data-v-fe51c94a>dup</code> operator can express idempotency of the Boolean
  operations <kbd data-v-fe51c94a>and</kbd> and <kbd data-v-fe51c94a>or</kbd> which are defined for truth values and
  for sets. It can also express the idempotency of the numeric binary <kbd data-v-fe51c94a>min</kbd>and <kbd data-v-fe51c94a>max</kbd> operators:
  <pre data-v-fe51c94a>        dup and  ==  id                 dup or  ==  id
          dup min  ==  id                 dip max  ==  id
  </pre><p data-v-fe51c94a>
    The Joy operator <kbd data-v-fe51c94a>pop</kbd> expects one value on top of the stack and removes
    it. For example
  <pre data-v-fe51c94a>        17 42 pop  ==  17
  </pre>
  On the left the composition of three functions first pushes two numbers and
  then pops the second. On the right the function just pushes the first number. The
  two functions are identical since for all argument stacks they have the same result
  stack.
  <p data-v-fe51c94a>
    Let <code data-v-fe51c94a>f(x,y)</code> be a binary function. A constant
    <code data-v-fe51c94a>c</code> is called a left or right <em data-v-fe51c94a>zero element</em> of
    <code data-v-fe51c94a>f(x,y)</code> if the first or second equation holds for all
    <code data-v-fe51c94a>x</code>:
  <pre data-v-fe51c94a>        f(c,x)  =  c                    f(x,c)  =  c
  </pre>
  For example, the number zero is a left and right zero element for multiplication,
  and in conventional infix notation the laws looks like this:
  <pre data-v-fe51c94a>        0 * n  =  0                     n * 0  =  0
  </pre>
  The <code data-v-fe51c94a>pop</code> operator can also be used to express that particular
  values are zero elements for binary operations: 0 for multiplication, <code data-v-fe51c94a>false</code>and the empty set <code data-v-fe51c94a>{}</code> for logical conjunction and set intersection, and
  <code data-v-fe51c94a>true</code> for logical disjunction.
  <pre data-v-fe51c94a>        0 *  ==  pop 0
          false and  ==  pop false         {} and  ==  pop {}
          true or  ==  pop true
  </pre><p data-v-fe51c94a>
    The two operators <code data-v-fe51c94a>dup</code> and <code data-v-fe51c94a>pop</code> are related by the identity
  <pre data-v-fe51c94a>        dup pop  ==  id
  </pre>
  The <code data-v-fe51c94a>pop</code> operator can also be used to express the
  <em data-v-fe51c94a>arity</em> of a function, the number of parameters which it expects. For example,
  numbers are nullary, the successor function is unary, and addition is binary. There
  is no way to express this in conventional notation. In Joy it is expressed by:
  <pre data-v-fe51c94a>        42 pop  ==  id        succ pop  ==  pop        + pop  ==  pop pop
  </pre>
  Similar laws express that some operators return two results on the stack:
  <pre data-v-fe51c94a>        uncons pop pop  ==  pop        dup pop pop  ==  pop
  </pre><h2 data-v-fe51c94a>Converses, commutativity and symmetry</h2>
  This section illustrates the use of the <code data-v-fe51c94a>swap</code> operator in Joy algebra.
  The Joy operator <kbd data-v-fe51c94a>swap</kbd> expects two values of any type on top of the stack;
  its effect is to interchange them. The operator is its own inverse:
  <pre data-v-fe51c94a>        swap swap  ==  id
  </pre><p data-v-fe51c94a>
    Let <code data-v-fe51c94a>f(x,y)</code> be a binary function. Another binary function
    <code data-v-fe51c94a>g(x,y)</code> is its <em data-v-fe51c94a>converse</em> if for all <code data-v-fe51c94a>x</code> and <code data-v-fe51c94a>y</code><pre data-v-fe51c94a>        f(x,y)  =  g(y,x)
  </pre>
  For example, the numeric comparison relation <code data-v-fe51c94a>&lt;</code> has as its
  converse the relation <code data-v-fe51c94a>></code>:
  <pre data-v-fe51c94a>        (i &lt;j)  =  (j > i)
  </pre>
  In Joy notation the <code data-v-fe51c94a>swap</code> operator can express that comparison
  predicates <code data-v-fe51c94a>&lt;</code> and <code data-v-fe51c94a>&lt;=</code> have as their converses the predicates
  <code data-v-fe51c94a>></code> and <code data-v-fe51c94a>>=</code> by the laws
  <pre data-v-fe51c94a>        swap >   ==   &lt;                swap >=    ==    &lt;=
  </pre>
  The operator <kbd data-v-fe51c94a>swons</kbd> is similar to <code data-v-fe51c94a>cons</code>, it expects
  an aggregate and a new value on top of the stack. It leaves a new aggregate with
  the value inserted. But whereas <code data-v-fe51c94a>cons</code> expects the aggregate on top and
  the value below, <code data-v-fe51c94a>swons</code> expects them in the opposite order, the value
  on top and the aggregate below. It follows that <code data-v-fe51c94a>swons</code> is the converse
  of
  <code data-v-fe51c94a>cons</code>. In the same way, a binary string or list operation
  <kbd data-v-fe51c94a>swoncat</kbd> is defined to be the converse of
  <code data-v-fe51c94a>concat</code>.
  <pre data-v-fe51c94a>        swap cons  ==  swons            swap concat  ==  swoncat
  </pre><p data-v-fe51c94a>
    One function is the converse of a second function if and only if the second is the
    converse of the first. This says that converseness is a symmetric relation. In
    Joy it is expressed by the following: for all programs <code data-v-fe51c94a>P</code> and <code data-v-fe51c94a>Q</code><pre data-v-fe51c94a>        swap P  ==  Q    if and only if    swap Q  ==  P
  </pre>
  From this rule and the previous equalities it follows that
  <pre data-v-fe51c94a>        swap &lt; ==   >                  swap &lt;=  ==  >=
          swap swons  ==  cons            swap swoncat  ==  concat
  </pre><p data-v-fe51c94a>
    A binary function <code data-v-fe51c94a>f(x,y)</code> is <em data-v-fe51c94a>commutative</em> if it is its own
    converse - if for all <code data-v-fe51c94a>x</code> and <code data-v-fe51c94a>y</code><pre data-v-fe51c94a>        f(x,y)  =  f(y,x)
  </pre>
  For example, addition of numbers is commutative, for all integers
  <code data-v-fe51c94a>x</code> and <code data-v-fe51c94a>y</code><pre data-v-fe51c94a>        i + j  =  j + i
  </pre>
  In Joy the <code data-v-fe51c94a>swap</code> operator can express that a function is commutative.
  <pre data-v-fe51c94a>        swap +  ==  +                   swap *  ==  *
          swap and  ==  and               swap or  ==  or
          swap max  ==  max               swap min  ==  min
  </pre>
  Two sorted sequences can be combined with the <kbd data-v-fe51c94a>merge</kbd> operator to
  form one new sorted sequence. Unlike
  <kbd data-v-fe51c94a>concat</kbd>enation, merging is commutative:
  <pre data-v-fe51c94a>        swap merge  ==  merge
  </pre><p data-v-fe51c94a>
    A function which yields a truth value is often called a
    <em data-v-fe51c94a>predicate</em>. Commutative predicates are often called
    <em data-v-fe51c94a>symmetric</em>. For example, the <em data-v-fe51c94a>identity relation</em><code data-v-fe51c94a> = </code>, a binary predicate, is commutative or symmetric. Another is the
    <kbd data-v-fe51c94a>equal</kbd> predicate which tests lists for identity, including sublists and
    their sublists. In conventional notation, for all integers or lists <code data-v-fe51c94a>x</code>  and <code data-v-fe51c94a>y</code><pre data-v-fe51c94a>        (i = j)  =  (j = i)        equal(x,y)  =  equal(y,x)
  </pre>
  Turning these concepts on themselves, the converse relation is symmetric:
  for all functions <code data-v-fe51c94a>f</code> and <code data-v-fe51c94a>g</code><pre data-v-fe51c94a>        (g is the converse of f)  =  (f is the converse of g)
  </pre>
  The same is not true for the inverse relation. The <code data-v-fe51c94a>swap</code> operator
  can express that a binary predicate is <em data-v-fe51c94a>symmetric</em>. The following express
  that <code data-v-fe51c94a> = </code> and <code data-v-fe51c94a>equal</code> are symmetric:
  <pre data-v-fe51c94a>        swap =   ==   =                 swap equal  ==  equal
  </pre>
  With <code data-v-fe51c94a>swap</code> one can express that elements are <em data-v-fe51c94a>left
  unit</em> elements for binary operations. In the case of operations such as addition
  and the Boolean operations this already follows from their commutativity. On the
  other hand, concatenation of strings or lists is not commutative, but the empty string
  and the empty list are both right and left unit elements for concatenation. They
  are also both right unit elements for <kbd data-v-fe51c94a>merge</kbd>.
  <pre data-v-fe51c94a>        0 swap +  ==  id                1 swap *  ==  id
          false swap or  == id            {} swap or  ==  id
          true swap and  ==  id
          "" swap concat  ==  id          [] swap concat  ==  id
          "" swap merge  ==  id           [] swap merge  ==  id
  </pre><p data-v-fe51c94a>
    Some operators leave two elements on top of the stack, and two such operator may
    be related in the sense that they just leave the elements in a different order.
    This can also be expressed by
    <code data-v-fe51c94a>swap</code>:
  <pre data-v-fe51c94a>        uncons swap  ==  unswons        unswons swap  ==  uncons
  </pre>
  There is even one operator which is related to itself in this way, and that
  is <code data-v-fe51c94a>dup</code>:
  <pre data-v-fe51c94a>        dup swap  ==  dup
  </pre><p data-v-fe51c94a>
    Two operators related to <code data-v-fe51c94a>swap</code> are <kbd data-v-fe51c94a>rollup</kbd> and
    <kbd data-v-fe51c94a>rolldown</kbd>. The <code data-v-fe51c94a>rollup</code> operator moves the third and second
    element on the stack into second and first position, and it moves the original
    first element into third position. The
    <code data-v-fe51c94a>rolldown</code> operator moves the second and first element on the stack
    into third and second position, and it moves the original third element into first
    position. They can express laws such as
  <pre data-v-fe51c94a>        rolldown  concat  concat   ==   concat swoncat
          rollup  swoncat  concat   ==   swoncat  swoncat
          rollup  merge  merge   ==   merge merge
  </pre>
  Their arities are expressed by
  <pre data-v-fe51c94a>        swap  pop  pop   ==   pop  pop
          rollup  pop  pop  pop   ==   pop  pop  pop
          rolldown  pop  pop  pop   ==   pop  pop  pop
  </pre><h2 data-v-fe51c94a>Associativity</h2><p data-v-fe51c94a>
    This section illustrates the use of the <code data-v-fe51c94a>dip</code> combinator in Joy algebra.
  <p data-v-fe51c94a>
    The three previous sections have shown how a few Joy operations can express a variety
    of well-known laws. In the sections to follow more difficult Joy concepts will
    be needed. These resemble higher order functions, but like everything else in Joy
    they really are just functions from stacks to stacks. They differ from what are
    called the operators in that they expect on top of the stack not just a passive
    datum, but a quoted program which they execute. In accordance with an older terminology
    they are here called <em data-v-fe51c94a>combinator</em>s.
  <p data-v-fe51c94a>
    One of these is the <kbd data-v-fe51c94a>dip</kbd> combinator. It expects a quoted program on the
    top of the stack, and below at least one value of any type. During execution it
    removes the program and the value from the stack and saves them. Then it executes
    the program on the remainder of the stack. Finally it restores the saved value
    to the top of the stack. In most applications the program will be pushed just before
    the combinator is to be applied. The combinator is useful for doing something to
    the stack without disturbing the top value.
  <p data-v-fe51c94a>
    Here is an example:
  <pre data-v-fe51c94a>        1 2 3 4 + * 5  ==  1 14 5
          1 2 3 4 5 [+ *] dip  ==  1 14 5
  </pre>
  In the first line on the left the 3 and the 4 are immediately added, the result
  is multiplied by the 2 to give 14, and then the 5 is pushed on top. In the second
  line the 5 is pushed immediately after the 4, and consequently it is not possible
  to add the 3 and 4 without popping the 5 first. So, the program <code data-v-fe51c94a>[+ *]</code>is pushed and then executed by <code data-v-fe51c94a>dip</code>. The results are the same as those
  in the two (identical) right sides.
  <p data-v-fe51c94a>
    A binary function <code data-v-fe51c94a>f(x,y)</code> is said to be
    <em data-v-fe51c94a>associative</em> if the result of applying it twice to three values is independent
    of the order of application:
  <pre data-v-fe51c94a>        f(x,f(y,z))  =  f(f(x,y),z)
  </pre>
  For example, addition of numbers is associative:
  <pre data-v-fe51c94a>        i + (j + k)  =  (i + j) + k
  </pre>
  If <code data-v-fe51c94a>g(x,y)</code> is the converse of an associative
  <code data-v-fe51c94a>f(x,y)</code>, then <code data-v-fe51c94a>g(x,y)</code> is also associative.
  <p data-v-fe51c94a>
    In Joy the <code data-v-fe51c94a>dip</code> combinator can be used to express associativity:
  <pre data-v-fe51c94a>        [+] dip +  ==  + +              [*] dip *  ==  * *
          [and] dip and  ==  and and      [or] dip or  ==  or or
          [max] dip max  ==  max max      [min] dip min  ==  min min
          [concat] dip concat  ==  concat concat
          [swoncat] dip swoncat  ==  swoncat swoncat
          [merge] dip merge  ==  merge merge
  </pre><p data-v-fe51c94a>
    The following law expresses that the <code data-v-fe51c94a>dip</code> combinator leaves one value
    unchanged:
  <pre data-v-fe51c94a>        dip  pop   ==   [pop]  dip  i
  </pre><h2 data-v-fe51c94a>Homomorphisms, De Morgan and distribution</h2>
  This section illustrates the use of the <code data-v-fe51c94a>app2</code> combinator in Joy algebra.
  <p data-v-fe51c94a>
    The <kbd data-v-fe51c94a>app2</kbd> combinator expects a quoted program on top of the stack, and
    below that two data parameters. As with all combinators, the program will be executed,
    in this case twice. In case the program computes a unary function, the effect is
    to replace the two data parameters by two corresponding values of that function.
    The two evaluations could be done in parallel. The more general case where the
    program does not denote a unary function is described further down.
  <p data-v-fe51c94a>
    Let <code data-v-fe51c94a>f(x1,x2)</code> be a binary function defined on a type
    <code data-v-fe51c94a>X</code>, and let <code data-v-fe51c94a>g(y1,y2)</code> be a binary function defined on a
    type <code data-v-fe51c94a>Y</code>. Let <code data-v-fe51c94a>h(x)</code> be a function from <code data-v-fe51c94a>X</code> to
    <code data-v-fe51c94a>Y</code>. Then <code data-v-fe51c94a>h(x)</code> is a
    <em data-v-fe51c94a>homomorphism</em> from <code data-v-fe51c94a>X</code> and its binary function to
    <code data-v-fe51c94a>Y</code> and its binary function when the following holds for all <code data-v-fe51c94a>x1</code>  and <code data-v-fe51c94a>x2</code>:
  <pre data-v-fe51c94a>        h(f(x1,x2)  =  g(h(x1),h(x2))
  </pre>
  One example is the logarithm function which maps logarithms of products onto
  sums of logarithms. Two other examples are the doubling function which maps integers
  with addition into even integers with addition, and the squaring function which maps
  naturals with multiplication into square naturals with multiplication and the
  <kbd data-v-fe51c94a>size</kbd> (or length) of string function which maps the size of concatenations
  onto sums of sizes. The <em data-v-fe51c94a>De Morgan</em> laws are another example.
  <pre data-v-fe51c94a>        log(x * y)  =  log(x) + log(y)
          double(x + y)  =  double(x) + double(y)
          square(x * y)  =  square(x) * square(y)
          size(concat(x,y))  =  size(x) + size(y)
          not(p and q)  =  not p or not q
          not(p or q)  =  not p and not q
  </pre><p data-v-fe51c94a>
    In Joy the <code data-v-fe51c94a>app2</code> combinator can be used to express
    <em data-v-fe51c94a>homomorphism</em> laws, and these all take the form:
  <pre data-v-fe51c94a>        f  h   ==   [h]  app2  g
  </pre>
  Some such laws are
  <pre data-v-fe51c94a>        +  double   ==   [double]  app2  +
          *  square   ==   [square]  app2  *
          max  succ   ==   [succ]  app2  max
          concat  size   ==   [size]  app2  +
          concat  sum   ==   [sum]  app2  +
          concat  product   ==   [product]  app2  *
          concat  charset   ==   [charset]  app2  or
  </pre>
  In the above, <kbd data-v-fe51c94a>charset</kbd> transforms a string of characters into a
  set of characters, and the <code data-v-fe51c94a>or</code> operator computes set union in this case.
  Another homomorphism is the <kbd data-v-fe51c94a>sort</kbd> operator which maps unordered lists under
  concatenation onto ordered lists under a binary <kbd data-v-fe51c94a>merge</kbd> operator which preseves
  ordering:
  <pre data-v-fe51c94a>        concat  sort   ==   [sort]  app2  merge
  </pre><p data-v-fe51c94a>
    The <code data-v-fe51c94a>app2</code> combinator can also be used to express the familiar De Morgan
    laws for Boolean algebra and a (perhaps surprising) isomorphic pair of laws for
    strings or lists:
  <pre data-v-fe51c94a>        and not  ==  [not] app2 or
          or not  ==  [not] app2 and
          concat reverse  ==  [reverse] app2 swoncat
          swoncat reverse  ==  [reverse] app2 concat
  </pre><p data-v-fe51c94a>
    Laws like the above generalise to <em data-v-fe51c94a>distribution</em> laws. In these the unary
    function is replaced by a new binary function, and for each element in the domain
    a unary function can be defined from the new binary function by letting one parameter
    be the given element. It is useful to distinguish <em data-v-fe51c94a>right distribution</em> and
    <em data-v-fe51c94a>left
    distribution</em>.
  <p data-v-fe51c94a>
    A binary function <code data-v-fe51c94a>f(x,y)</code> distributes from the right over another binary
    function <code data-v-fe51c94a>g(x,y)</code> if the following holds:
  <pre data-v-fe51c94a>        f(g(x,y),z)  =  g(f(x,z),f(y,z))
  </pre>
  In arithmetic we have the familiar example of multiplication distributing
  from the right over addition. In Boolean algebra the conjunction and disjunction
  operators distribute from the right over
  <em data-v-fe51c94a> each other</em>. Here is the arithmetic law:
  <pre data-v-fe51c94a>        (i + j) * k  =  (i * k) + (j * k)
  </pre><p data-v-fe51c94a>
    The <code data-v-fe51c94a>app2</code> combinator can also express <em data-v-fe51c94a>right
    distribution</em> laws. In each case there are three data parameters on the stack,
    and the two ways of applying two functions are equivalent. The one way is to apply
    the one function to the second and third parameters (using the <code data-v-fe51c94a>dip</code>  combinator) and then to apply the distributing function to the result and the first
    parameters. The other way is to use the first parameter and the distributing function
    to make a <em data-v-fe51c94a>constructed program</em> that computes a unary function, use <code data-v-fe51c94a>app2</code>  to compute its values for the second and third data parameters and to combine the
    two values with the other function.
  <pre data-v-fe51c94a>        [+] dip *  ==  [*] cons app2 +
          [and] dip or  ==  [or] cons app2 and
          [or] dip and  ==  [and] cons app2 or
  </pre><p data-v-fe51c94a>
    A binary function <code data-v-fe51c94a>f(x,y)</code> distributes from the left over another binary
    function <code data-v-fe51c94a>g(x,y)</code> if the following holds:
  <pre data-v-fe51c94a>        f(x,g(y,z))  =  g(f(x,z),f(y,z))
  </pre>
  In arithmetic multiplication also distributes from the left over addition:
  <pre data-v-fe51c94a>        i * (j + k)  =  i * j + i * k
  </pre>
  The <code data-v-fe51c94a>app2</code> combinator can also be applied to a quoted program which
  does not compute a unary function, but accesses data elements further down in the
  stack. In the examples below, these elements have to be explicitly deleted later
  on, by <code data-v-fe51c94a>[pop]
  dip</code>. It can be used to express <em data-v-fe51c94a>left distribution</em> laws.
  <pre data-v-fe51c94a>        + *  ==  [*] app2 + [pop] dip
          or and  ==  [and] app2 or [pop] dip
          and or  ==  [or] app2 and [pop] dip
  </pre><p data-v-fe51c94a>
    Apart from <code data-v-fe51c94a>app2</code> there are similar combinators
    <kbd data-v-fe51c94a>app1</kbd> and <kbd data-v-fe51c94a>app3</kbd>. Each expects a program
    <code data-v-fe51c94a>[P]</code> on top of the stack and below that 1, 2 or 3 further parameters
    and produces 1, 2 or 3 values. Some pertinent laws are
  <pre data-v-fe51c94a>        [succ]  app1  ==  succ            [not]  app1  ==  not
          [pop]  dip  app1   ==   app2  pop
          [swap]  dip  app2   ==   app2  swap
          [dup]  dip  app2   ==   app1  dup
  </pre>
  The arities of these combinators are expressed by
  <pre data-v-fe51c94a>        app1  pop   ==   pop  pop
          app2  pop  pop   ==   pop  pop  pop
          app3  pop  pop  pop   ==   pop  pop  pop  pop
  </pre><p data-v-fe51c94a>
    There is a sense in which one might say that an integer has two parts: a sign and
    an absolute value. When the two parts are multiplied, the result is the same as
    the original. In the same way, a non-empty list has two parts, its first and its
    rest. When the first is consed into the rest, the result is the same as the original
    list. In conventional notation this might be expressed as
  <pre data-v-fe51c94a>        sign(x) * abs(x)  =  x
          cons(first(x),rest(x))  =  x
  </pre>
  The same may be expressed in Joy notation using the <code data-v-fe51c94a>dip</code> combinator:
  <pre data-v-fe51c94a>        dup [sign] dip abs *  ==  id
          dup [first] dip rest cons  ==  id
  </pre><p data-v-fe51c94a>
    The laws look somewhat cleaner when expressed in terms of another combinator. The
    <kbd data-v-fe51c94a>cleave</kbd> combinator expects two programs and below that another item.
    It applies both programs to produce two results, for example
  <pre data-v-fe51c94a>        5  [pred]  [dup *]  cleave   ==   4  25
  </pre>
  The earlier laws about parts and wholes can then be expressed like this:
  <pre data-v-fe51c94a>        [sign]  [abs]  cleave  *   ==   id
          [first]  [rest]  cleave  cons   ==  id
  </pre><p data-v-fe51c94a>
    The combinator <kbd data-v-fe51c94a>split</kbd> applied to a list and a test predicate produces
    two lists, those members of the original list which pass the test and those with
    fail. For any predicate, a list will have two parts which can be merged to reconstitute
    the original list. In Joy notation:
  <pre data-v-fe51c94a>        [sort] dip split merge   ==   pop  sort
  </pre>
  The law cannot be expressed in conventional notation because
  <code data-v-fe51c94a>split</code> produces two results.
  <h2 data-v-fe51c94a>The LIST functor and its natural transformations</h2>
  This section uses several concepts from category theory. The following brief sketch
  is unavoidably superficial, for a proper exposition see <a href="refs.html#{Rydeheard85}" data-v-fe51c94a>{Rydeheard85}</a><a href="refs.html#{Poigne92}" data-v-fe51c94a>{Poigne92}</a>. For excellent short introductions
  for computer science see <a href="refs.html#{Tennent91}" data-v-fe51c94a>{Tennent91}</a> and
  <a href="refs.html#{Walters91}" data-v-fe51c94a>{Walters91}</a>. Another short introduction with
  an extensive bibliography is
  <a href="refs.html#{Pierce91}" data-v-fe51c94a>{Pierce91}</a>.
  <p data-v-fe51c94a>
    A <em data-v-fe51c94a>category</em> consists of a collection of <em data-v-fe51c94a>object</em>s and for any two
    objects a collection of <em data-v-fe51c94a>morphism</em>s, each having the one object as their
    <em data-v-fe51c94a>source</em> and the other object as their
    <em data-v-fe51c94a>target</em>. In many categories the objects are just sets, or they are sets
    with structure - algebras. Then the morphisms are unary functions from sets to
    sets, or they are homomorphisms from algebras to algebras. For any object the morphisms
    must include an
    <em data-v-fe51c94a>identity morphism</em> with that object as source and target. Often there will
    be other morphisms with that object as source and target. For any object and two
    morphisms having a given object as target and source respectively, there must be
    a composite morphism having as source the source of the one component and as target
    the target of the other.
  <p data-v-fe51c94a>
    This composition of morphisms must be associative, with identity morphisms as left
    and right unit elements. These requirements are satisfied for categories of sets
    and functions and for categories of algebras and homomorphisms. But there are many
    categories that are quite different. One kind of example are <em data-v-fe51c94a>monoid</em>s:
    an associative binary operation over a set which includes a left and right unit
    element. Here the category consists of just one object (which is of no interest),
    but many morphisms, the elements of the monoid. There are many other kinds of categories
    which are different again.
  <p data-v-fe51c94a>
    Categories deal with two sorts of things, objects and morphisms. So they are two-sorted
    algebras. Between categories there are morphisms called <em data-v-fe51c94a>functor</em>s. These
    take objects and morphims of one category into objects and morphisms of another
    category. In computer science the most familiar functors are the <em data-v-fe51c94a>type constructor</em>s.
    They take integers, characters, truth values and so on into
    <code data-v-fe51c94a>LIST</code>s of integers, <code data-v-fe51c94a>LIST</code>s of characters,
    <code data-v-fe51c94a>SET</code>s of integers and so on. The functors must <em data-v-fe51c94a>
    also</em> take integer functions such as squaring into corresponding functions on
    <code data-v-fe51c94a>LIST</code>s or <code data-v-fe51c94a>SET</code>s of integers.
  <p data-v-fe51c94a>
    In computing circles the corresponding functions are usually written
    <code data-v-fe51c94a>map(square,L)</code>, for a list <code data-v-fe51c94a>L</code>. In category theory the same
    symbol is used for objects and morphisms, so the examples are written <code data-v-fe51c94a>LIST(integer)</code>  and
    <code data-v-fe51c94a>LIST(square)</code>. In Joy there is no explicit type notation at all, and
    <kbd data-v-fe51c94a>map</kbd> is just one of many combinators. Programs to compute the list of
    squares of a given list can be written in either of these two ways:
  <pre data-v-fe51c94a>        [square]  map                   [dup *]  map
  </pre><p data-v-fe51c94a>
    Between any two functors <code data-v-fe51c94a>F</code> and <code data-v-fe51c94a>G</code> there can be functions
    called <em data-v-fe51c94a>natural transformation</em>s. These take as arguments the values of
    <code data-v-fe51c94a>F</code> and <code data-v-fe51c94a>G</code> at their objects. A function <code data-v-fe51c94a>n</code> is
    natural if for all morhisms
    <code data-v-fe51c94a>m</code> in the domains of <code data-v-fe51c94a>F</code> and <code data-v-fe51c94a>G</code> the following
    holds for all <code data-v-fe51c94a>x</code>:
  <pre data-v-fe51c94a>        n(F(m)(x))  =  G(m)(n(x))
  </pre>
  Initially we shall only be concerned with the case where
  <code data-v-fe51c94a>F</code> and <code data-v-fe51c94a>G</code> are the same functor
  <code data-v-fe51c94a>LIST</code>. Then an example of a natural transformation from lists to lists
  is the <kbd data-v-fe51c94a>reverse</kbd> function: for all functions
  <code data-v-fe51c94a>f</code> and lists <code data-v-fe51c94a>L</code><pre data-v-fe51c94a>        reverse(LIST(f)(L)  =  LIST(f)(reverse(L))
  </pre>
  or in conventional notation
  <pre data-v-fe51c94a>        reverse(map(f,L))  =  map(f,reverse(L))
  </pre>
  In Joy algebra the naturality of <code data-v-fe51c94a>reverse</code> is expressed by
  <pre data-v-fe51c94a>        [reverse]  dip  map   ==   map  reverse
  </pre><p data-v-fe51c94a>
    In computer science natural transformations are often called
    <em data-v-fe51c94a>polymorphic</em> functions, in the case of lists they are independent of the
    type of the elements of the lists. Four other naturality laws, expressed in conventional
    notation:
  <pre data-v-fe51c94a>        map(f,rest(L))  =  rest(map(f,L))
          f(first(L))  =  first(map(f,L))
          map(f,concat(L1,L2))  =  concat(map(f,L1),map(f,L2))
          map(f,cons(x,[]))  =  cons(f(x),[])
          map(f,unitlist(x))  =  unitlist(f(x))
  </pre>
  The last two laws of course say the same thing. In Joy these would be expressed
  by
  <pre data-v-fe51c94a>        [rest]  dip  map   ==   map  rest
          [first]  dip  i   ==   map  first
          [concat]  dip  map   ==   [map]  cons  app2  concat
          [[] cons] dip map   ==   i [] cons
          [unitlist] dip map   ==   i  unitlist
  </pre>
  Note that in the third equation on the right the <code data-v-fe51c94a>app2</code> combinator
  has to use a <em data-v-fe51c94a>constructed program</em>. The last two laws again say the same thing.
  <p data-v-fe51c94a>
    Somewhat more difficult is the naturality of <kbd data-v-fe51c94a>cons</kbd>. In conventional notation
    this is expressed by
  <pre data-v-fe51c94a>        map(f,cons(x,L))  =  cons(f(x),map(f,L))
  </pre>
  and in Joy notation by
  <pre data-v-fe51c94a>        [cons]  dip  map   ==   dup  [dip]  dip  map  cons
  </pre>
  This is so complex that a step-by-step verification is called for. Let <code data-v-fe51c94a>L</code>and <code data-v-fe51c94a>x</code> be the list and the additional member. Let <code data-v-fe51c94a>[F]</code> be
  a program which computes the function
  <code data-v-fe51c94a>f</code>. Let <code data-v-fe51c94a>x'</code> be the result of applying
  <code data-v-fe51c94a>f</code> to <code data-v-fe51c94a>x</code>, and let <code data-v-fe51c94a>L'</code> be the result of applying
  <code data-v-fe51c94a>f</code> to all members of <code data-v-fe51c94a>L</code>. The proof of the equivalence of
  the LHS and the RHS consists in showing that both reduce to the same program. For
  the LHS we have:
  <pre data-v-fe51c94a>        x  L  [F]  [cons]  dip  map                             LHS
      ==  x  L  cons  [F]  map                                    (dip)
      ==  [x L]  [F]  map                                         (cons)
      ==  [x' L']                                                 (map)
  </pre>
  For the RHS:
  <pre data-v-fe51c94a>        x  L  [F]  dup  [dip]  dip  map  cons                   RHS
      ==  x  L  [F]  [F]  [dip]  dip  map  cons                   (dup)
      ==  x  L  [F]  dip  [F]  map  cons                          (dip)
      ==  x'  L  [F]  map  cons                                   (dip)
      ==  x'  L' cons                                             (map)
      ==  [x' L']                                                 (cons)
  </pre>
  The two sides reduce to the same program, so they denote the same function.
  <p data-v-fe51c94a>
    A similar equation is the following:
  <pre data-v-fe51c94a>        map   ==   [uncons]  dip  dup  [dip]  dip  map  cons
  </pre>
  But note that this is not suitable as a definition, since the RHS only applies
  to non-empty lists. The following is a suitable recursive definition:
  <pre data-v-fe51c94a>        map   ==   [ pop null ]
                     [ pop ]
                     [ [uncons]  dip  dup  [dip]  dip  map  cons ]
                     ifte
  </pre><p data-v-fe51c94a>
    The fact that <code data-v-fe51c94a>map</code> does not change the number of elements in a list
    is expressed in conventional notation by
  <pre data-v-fe51c94a>        size(map(f,L))  =  size(L)
  </pre>
  and in Joy notation by
  <pre data-v-fe51c94a>        map  size   ==   pop  size
  </pre><p data-v-fe51c94a>
    An important combinator for any aggregate is <kbd data-v-fe51c94a>filter</kbd>, which expects an
    aggregate and below that a quotation which implememnts a predicate. It returns
    an aggregate of the same type as the parameter containing only those members for
    which the predicate yielded
    <code data-v-fe51c94a>true</code>. Given two aggregates, it does not matter whether they are first
    combined and then filtered, or first filtered separately and then combined. For
    sequences the law is this:
  <pre data-v-fe51c94a>        [concat] dip filter  ==  [filter] cons app2 concat
  </pre>
  For sets the combining operator has to be <code data-v-fe51c94a>or</code> instead of
  <code data-v-fe51c94a>concat</code>.
  <p data-v-fe51c94a>
    Another law concerns passing an aggregate first through one filter and then passing
    the result through another filter. Passing the aggregate through the conjunction
    of these filters produces the same result. The <kbd data-v-fe51c94a>conjoin</kbd> operator takes
    two quoted predicates and returns one quoted predicate which is their conjunction.
  <pre data-v-fe51c94a>        [filter] dip filter  ==  conjoin filter
  </pre><p data-v-fe51c94a>
    The following laws concern the <code data-v-fe51c94a>sum</code>s and
    <code data-v-fe51c94a>product</code>s of lists of integers:
  <pre data-v-fe51c94a>        cons  sum   ==   sum  +         sum   ==   uncons  sum  +
          cons product  ==  product *     product  ==  uncons product *
  </pre>
  (Only the equations on the left could be expressed in conventional notation.)
  <p data-v-fe51c94a>
    This holds:
  <pre data-v-fe51c94a>        P  ==  uncons Q   iff   cons P  == Q
  </pre><h2 data-v-fe51c94a>Other functors and their natural transformations</h2>
  As indicated in the previous section, apart from <code data-v-fe51c94a>LIST</code> there are other
  functors such as <code data-v-fe51c94a>SET</code>. So there is the type <code data-v-fe51c94a>SET(integer)</code>,
  the function <code data-v-fe51c94a>SET(square)</code> which maps a set of integers into the set of
  their squares, and similarly for other integer functions. Much of what was said about
  lists and their natural transformations has counterparts for sets and their natural
  transformations. In Joy there are several implementations of <em data-v-fe51c94a>set type</em>s.
  The simplest is in terms of bitstrings with potential elements <code data-v-fe51c94a>0</code> ..
  <code data-v-fe51c94a>31</code>, such sets are written in curly braces, as in <code data-v-fe51c94a>{1 3 5}</code>.
  Values of this type can be manipulated by the combinator
  <code data-v-fe51c94a>map</code> and the operators <code data-v-fe51c94a>first</code>,
  <code data-v-fe51c94a>rest</code> and <code data-v-fe51c94a>cons</code>. Instead of the operator
  <code data-v-fe51c94a>concat</code> the set union operator <kbd data-v-fe51c94a>or</kbd> applies. The naturality
  of these operators is expressed by
  <pre data-v-fe51c94a>        [rest]  dip  map   ==   map  rest
          [first]  dip  map   ==   map  first
          [or]  dip  map   ==   [map]  cons  app2  or
          [{} cons]  dip  map   ==   i  {}  cons
          [cons]  dip  map   ==   dup  [dip]  dip  map  cons
  </pre><p data-v-fe51c94a>
    Now we have two functors, <code data-v-fe51c94a>LIST</code> and <code data-v-fe51c94a>SET</code>. Lists have order
    and may have repetitions, sets have neither. A useful function from lists to sets
    is the function <kbd data-v-fe51c94a>elements</kbd> which removes order and repetitions. For example,
    in Joy notation
  <pre data-v-fe51c94a>        [ 3 1 5 1 ]  elements   ==   { 1 3 5 }
  </pre>
  It makes no difference whether the set of elements of a list is taken first
  and then the set is mapped through a function, or whether the list is first mapped
  through the same function and then the set of elements is taken. This is the naturality
  of the
  <code data-v-fe51c94a>elements</code> function, expressed by
  <pre data-v-fe51c94a>        [elements]  dip  map   ==   map  elements
  </pre>
  For example:
  <pre data-v-fe51c94a>        [ 3 1 5 1 ]  [dup *]  [elements]  dip  map
      ==  [ 3 1 5 1 ]  elements  [dup *]  map
      ==  { 1 3 5 }  [dup *]  map
      ==  { 1 9 25 }
  </pre>
  and
  <pre data-v-fe51c94a>        [ 3 1 5 1 ]  [dup *]  map  elements
      ==  [ 9 1 25 1 ]  elements
      ==  { 1 9 25 }
  </pre><p data-v-fe51c94a>
    Halfway between lists and sets are multisets or <em data-v-fe51c94a>bag</em>s; these have no order
    but may have repetitions. A <code data-v-fe51c94a>BAG</code> functor would be similar to <code data-v-fe51c94a>LIST</code>  and <code data-v-fe51c94a>SET</code>, and there would be natural transformations from bags to bags,
    from lists to bags, and from bags to sets. Currently Joy does not have an implementation
    of bags.
  <p data-v-fe51c94a>
    A list can have as its members other lists, for example lists of integers. Formally
    these are of type
    <code data-v-fe51c94a>LIST(LIST(integer))</code>. This uses the <code data-v-fe51c94a>LIST</code> functor composed
    with itself: <code data-v-fe51c94a>LIST</code> °
    <code data-v-fe51c94a>LIST</code>. Such a list can be mapped through a function by mapping each
    sublist, for example
  <pre data-v-fe51c94a>        [[1 2 3][4 5]]  [[dup *] map]  map   ==   [[1 4 9][16 25]]
  </pre>
  Here the second <code data-v-fe51c94a>map</code> is applied to the whole list, the first or
  inner <code data-v-fe51c94a>map</code> is applied to the sublists. Alternatively a combinator <kbd data-v-fe51c94a>mmap</kbd>can be defined by
  <pre data-v-fe51c94a>        mmap   ==   [map]  cons  map
  </pre>
  and then one can write
  <pre data-v-fe51c94a>        [[1 2 3][4 5]]  [dup *]  mmap  ==  [[1 4 9][16 25]]
  </pre><p data-v-fe51c94a>
    Whereas a list is one-dimensional, a <em data-v-fe51c94a>matrix</em> is two-dimensional. Matrices
    can be implemented as lists of lists, and the sublists can be interpreted either
    as the rows or the columns. One important operation on matrices is the interchange
    of rows and columns. The <kbd data-v-fe51c94a>transpose</kbd> operator does just that:
  <pre data-v-fe51c94a>        [[1 2][3 4]]  transpose   ==   [[1 3][2 4]]
  </pre>
  Transposition is another polymorphic function or natural transformation for
  matrices. It does not matter whether a matric is first transposed and then mapped
  elementwise through a function, or whether it is first mapped and then transposed.
  <pre data-v-fe51c94a>        [transpose]  dip  mmap   ==   mmap  transpose
  </pre><p data-v-fe51c94a>
    The operator <kbd data-v-fe51c94a>zip</kbd> will transform two lists of the same length into a
    list of pairs, for example
  <pre data-v-fe51c94a>        [1 2 3]  [4 5 6]  zip   ==   [[1 4][2 5][3 6]]
  </pre>
  The <code data-v-fe51c94a>zip</code> operator can be defined by
  <pre data-v-fe51c94a>        zip   ==   []  cons  cons  transpose
  </pre>
  The <code data-v-fe51c94a>zip</code> function is natural, <code data-v-fe51c94a>zip</code>ping the two lists
  and then <code data-v-fe51c94a>mmap</code>ing has the same effect as
  <code data-v-fe51c94a>map</code>ping and then <code data-v-fe51c94a>zip</code>ping:
  <pre data-v-fe51c94a>        [zip]  dip  mmap   ==   [map]  app2  zip
  </pre><p data-v-fe51c94a>
    A similar naturality law holds for the <kbd data-v-fe51c94a>cartproduct</kbd> operator which produces
    the <em data-v-fe51c94a>cartesian product</em> of two aggregates which do not have to be of the
    same type:
  <pre data-v-fe51c94a>        [cartproduct] dip  mmap   ==   [map] app2  cartproduct
  </pre><p data-v-fe51c94a>
    Another useful datatype is that of <em data-v-fe51c94a>tree</em>s, also called
    <em data-v-fe51c94a>recursive list</em>s. A tree of integers is either an integer or a list of
    trees of integer. A <em data-v-fe51c94a>proper tree</em> is a list of trees. The type gives rise
    to a functor <code data-v-fe51c94a>TREE</code>, with the data type <code data-v-fe51c94a>TREE(integer)</code> and
    mapping functions such as
    <code data-v-fe51c94a>TREE(square)</code>. In Joy the combinator for tree mapping is
    <kbd data-v-fe51c94a>treemap</kbd>. Most of the operations on lists also apply to proper trees.
    Reversal can be done by <code data-v-fe51c94a>reverse</code> just at the top level, or by <kbd data-v-fe51c94a>treereverse</kbd>  all the way down into all sublists. Some naturality laws are:
  <pre data-v-fe51c94a>        [reverse]  dip  treemap   ==   treemap  reverse
          [treereverse]  dip  treemap   ==   treemap  treereverse
          [rest]  dip  treemap   ==   treemap  rest
          [first]  dip  i   ==   treemap  first
          [[] cons]  dip  treemap   ==   treemap  []  cons
  </pre><p data-v-fe51c94a>
    Proper trees can be <kbd data-v-fe51c94a>treeflatten</kbd>ed to form a one-level list. For example
  <pre data-v-fe51c94a>        [ [1 [2 3] [] 4] [5] ]  treeflatten   ==   [ 1 2 3 4 5 ]
  </pre>
  The <code data-v-fe51c94a>treeflatten</code>ing function is a natural transformation between
  the <code data-v-fe51c94a>TREE</code> and <code data-v-fe51c94a>LIST</code> functors, the order of treeflattening
  and mapping does not matter:
  <pre data-v-fe51c94a>        [treeflatten]  dip  map   ==   treemap  treeflatten
  </pre>
  The following also holds:
  <pre data-v-fe51c94a>        treereverse  treeflatten   ==   treeflatten  reverse
  </pre><p data-v-fe51c94a>
    A <em data-v-fe51c94a>bare tree</em> is either the empty list <code data-v-fe51c94a>[]</code> or it is a list of
    bare trees. Formally there is a functor
    <code data-v-fe51c94a>BARETREE</code>, and for (degenerate) functions which can only take <code data-v-fe51c94a>[]</code>  as parameters <code data-v-fe51c94a>BARETREE(f)</code> maps bare trees with contained <code data-v-fe51c94a>[]</code>  into trees. Proper trees can also be <kbd data-v-fe51c94a>strip</kbd>ped of their leaves to form
    a bare tree:
  <pre data-v-fe51c94a>        [ [1 [2 3] [] 4] [5] ]  strip   ==   [ [ [] [] ] [] ]
  </pre>
  The <code data-v-fe51c94a>strip</code> function commutes with <code data-v-fe51c94a>reverse</code> and
  <code data-v-fe51c94a>treereverse</code>:
  <pre data-v-fe51c94a>        reverse  strip   ==   strip  reverse
          treereverse  strip   ==   strip  treereverse
  </pre>
  Once stripped, there is nothing for <code data-v-fe51c94a>treemap</code> to do:
  <pre data-v-fe51c94a>        [strip]  dip  treemap   ==   treemap  strip   ==   pop strip
  </pre><h2 data-v-fe51c94a>The LIST monad</h2>
  This section gives a superficial sketch of monads, another useful concept from category
  theory. For a fuller exposition see
  <a href="refs.html#{Arbib-Manes75}" data-v-fe51c94a>{Arbib-Manes75}</a>,
  <a href="refs.html#{Asperti-Longo91}" data-v-fe51c94a>{Asperti-Longo91}</a> and especially
  <a href="refs.html#{Wadler92}" data-v-fe51c94a>{Wadler92}</a>.
  <p data-v-fe51c94a>
    A <em data-v-fe51c94a>monad</em><code data-v-fe51c94a>M</code> over a category consists of a functor from the
    category to itself, and two natural transformations. The first transformation <code data-v-fe51c94a>joinM</code>  takes as argument an object in the target of the square of the functor and gives
    as value an object in the target of the functor. The second transformation
    <code data-v-fe51c94a>unitM</code> takes as argument an object in the category and gives as value
    an object in the target of the functor. The two transformations must satisfy two
    laws which are expressed in terms of two variants obtained by applying the functor
    to the two transformations:
  <p data-v-fe51c94a>
    From the first transformation one can define a variant by applying the functor to
    it. This variant is again a natural transformation, it takes as argument an object
    in the target of the cube of the functor and gives as value an object in the target
    of the square of the functor. The first transformation or its variant may be composed
    with the first transformation. The two compositions are again natural transformations,
    they take as argument an object in the cube of the functor and give as value an
    object in the target of the functor. The first defining law for monads is that
    these two compositions must be identical.
  <p data-v-fe51c94a>
    Similarly, from the second transformation one can define a variant by applying the
    functor to it. This variant is again a natural transformation, it takes as argument
    and value objects in the target of the functor. The second transformation or its
    variant may be composed with the first transformation. The two compositions take
    as argument an value objects in the target of the functor. The second defining
    law for monads is that these two compositions must both be equal to the identity
    function.
  <p data-v-fe51c94a>
    The above will now be illustrated with the <em data-v-fe51c94a>LIST monad</em>. Its functor is
    the <code data-v-fe51c94a>LIST</code> functor. Its first natural transformation is usually called
    <kbd data-v-fe51c94a>flatten</kbd>, which concatenates a two-level list to produce a single-level
    list. Its second natural transformation is the unary <kbd data-v-fe51c94a>unitlist</kbd> operation
    which takes any argument to produce its singleton list. Here are two examples:
  <pre data-v-fe51c94a>        [[1 2 3] [peter paul]] flatten  ==  [1 2 3 peter paul]
          [[1 2 3] [peter paul]] unitlist  ==  [[[1 2 3] [peter paul]]]
  </pre>
  The two required variants are obtained by applying the
  <code data-v-fe51c94a>LIST</code> functor, as <code data-v-fe51c94a>map</code>.
  <p data-v-fe51c94a>
    The variant of the <code data-v-fe51c94a>flatten</code> operator is the polymorphic operator
  <pre data-v-fe51c94a>        [flatten]  map
  </pre>
  which takes a list of (lists of lists) as argument and concatenates the (list
  of lists) but leaves the outer level list structure intact. This is an example:
  <pre data-v-fe51c94a>        [[[1 2] [3]] [[a] [b]]]  [flatten] map  ==  [[1 2 3] [a b]]
  </pre>
  The first monad law can now be written in Joy notation. It says that there
  are two equivalent ways of flattening a list of lists of lists to produce a list:
  <pre data-v-fe51c94a>        [flatten]  map  flatten   ==   flatten  flatten
  </pre><p data-v-fe51c94a>
    The variant of <code data-v-fe51c94a>unitlist</code> is the polymorphic operator
  <pre data-v-fe51c94a>        [unitlist] map
  </pre>
  which takes a list of elements and produces the list of their unitlists. An
  example is
  <pre data-v-fe51c94a>        [1 2 [3 4]]  [unitlist] map   ==   [[1] [2] [[3 4]]]
  </pre>
  The second monad law can now be written in Joy as
  <pre data-v-fe51c94a>        [unitlist] map  flatten   ==   id   ==   unitlist  flatten
  </pre><p data-v-fe51c94a>
    As natural transformations both <code data-v-fe51c94a>flatten</code> and
    <code data-v-fe51c94a>unitlist</code> interact with the <code data-v-fe51c94a>LIST</code> functor operating (as
    <code data-v-fe51c94a>map</code>) on arbitrary functions. There are two further laws that arise.
    Because these two laws are more general than the preceding ones, they are also
    more useful:
  <p data-v-fe51c94a>
    A list of lists can be mapped at the second level through an arbitrary function using
    the <code data-v-fe51c94a>mmap</code> combinator, producing another list of lists. That can then
    be <code data-v-fe51c94a>flatten</code>ed to produce a single level list. The same original list
    of list can first be
    <code data-v-fe51c94a>flatten</code>ed to produce a single level list which can then be mapped
    at the top level using <code data-v-fe51c94a>map</code>. The two results are the same, and in Joy
    this is expressed as
  <pre data-v-fe51c94a>        mmap  flatten   ==   [flatten] dip  map
  </pre><p data-v-fe51c94a>
    A function may be applied to an argument of any type, and then the
    <code data-v-fe51c94a>unitlist</code> can be taken. Alternatively the
    <code data-v-fe51c94a>unitlist</code> can be taken first and then the result can be
    <code data-v-fe51c94a>map</code>ped through the function. That the results are the same can be
    written in Joy as
  <pre data-v-fe51c94a>        i  unitlist   ==   [unitlist] dip  map
  </pre><p data-v-fe51c94a><a href="refs.html#{Wadler92}" data-v-fe51c94a>{Wadler92}</a> shows that in any monad it is possible
    to define another natural transformation, <em data-v-fe51c94a>monadic composition</em> which simultaneously
    resembles function application and function composition. For the <code data-v-fe51c94a>LIST</code>  monad it takes as one of its arguments a list and as the other argument a function
    which yields a list as value. The result is again a list. In Joy it might be defined
    by
  <pre data-v-fe51c94a>        bind   ==   map  flatten
  </pre>
  It satisfies the following laws:
  <pre data-v-fe51c94a>        [unitlist] dip  bind   ==   i
          [unitlist] bind   ==   id
          [K [H] bind] bind  ==  [K] bind  [H] bind
  </pre>
  The first two laws say that <code data-v-fe51c94a>unitlist</code> is a left and right identity
  for <code data-v-fe51c94a>bind</code>, the third says that <code data-v-fe51c94a>bind</code> is associative. The
  third law is here expressed with program variables <code data-v-fe51c94a>K</code> and <code data-v-fe51c94a>H</code>.
  Alternatively it is expressed by
  <pre data-v-fe51c94a>        [bind] cons  concat  bind   ==   [bind] dip  bind
  </pre>
  Wadler makes extensive use of many <code data-v-fe51c94a>bind</code>-like functions for monads
  other than the <code data-v-fe51c94a>LIST</code> monad.
  <p data-v-fe51c94a>
    A very general theory of lists, without the use of category theory, is given in
    <a href="refs.html#{Bird86}" data-v-fe51c94a>{Bird86}</a>. A very readable introduction to the
    <code data-v-fe51c94a>LIST</code> functor can be found in <a href="refs.html#{Spivey89}" data-v-fe51c94a>{Spivey89}</a>.
    The theory of lists is generalised by <a href="refs.html#{Malcolm89}" data-v-fe51c94a>{Malcolm89}</a>    to what have been called rose trees. <a href="refs.html#{Meijer-etal91}" data-v-fe51c94a>{Meijer-etal91}</a>    give a comprehensive collection of laws of functional programming using very
    general functional forms for lists and other data types. <a href="refs.html#{Bird-deMoor92}" data-v-fe51c94a>{Bird-deMoor92}</a>    use categories, homomorphisms and algebraic techniques to solve sophisticated
    optimisation problems in functional programming. It appears that most, and perhaps
    even all, of the contributions in the above papers can be translated into Joy
    notation.
  <hr data-v-fe51c94a></article></div></main><footer data-v-c785faa8><p data-v-c785faa8><a href="https://github.com/joy-language/joy-lang.org" data-v-c785faa8>GitHub</a></footer></div></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{},{}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.10669f42b2e188f55eb1.js"></script><script defer src="/_nuxt/layouts/default.29c0e08e13310e3682fc.js"></script><script defer src="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js"></script><script defer src="/_nuxt/pages/papers-on-joy/the-algebra-of-joy.7f385b55e84045676f24.js"></script><script defer src="/_nuxt/vendor.230cb916d1973aa790f3.js"></script><script defer src="/_nuxt/app.0a856c7cf6fb3e349fa2.js"></script>
  

