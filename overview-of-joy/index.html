<!DOCTYPE html>
<html data-n-head="" data-n-head-ssr>
  <head>
    <meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1" name="viewport"><meta data-n-head="true" content="Joy Programming Language" name="description" data-hid="description"><title data-n-head="true">Joy language</title><link href="https://fonts.googleapis.com/css?family=Fira+Sans:200,500|Roboto:400|Roboto+Mono:400" rel="stylesheet" data-n-head="true"><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/favicon.ico?" rel="shortcut icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.10669f42b2e188f55eb1.js" rel="preload" as="script"><link href="/_nuxt/vendor.230cb916d1973aa790f3.js" rel="preload" as="script"><link href="/_nuxt/app.0a856c7cf6fb3e349fa2.js" rel="preload" as="script"><link href="/_nuxt/layouts/default.29c0e08e13310e3682fc.js" rel="preload" as="script"><link href="/_nuxt/pages/overview-of-joy.8733ad0cbce5d065d604.js" rel="preload" as="script"><link href="/_nuxt/pages/papers-on-joy/survey-of-reproducing-programs.ed8409adcfb2bdec6eeb.js" rel="prefetch"><link href="/_nuxt/pages/libraries-and-c-sources.d2ffa370ff989df9d359.js" rel="prefetch"><link href="/_nuxt/pages/index.73b5e04f9a3fcda5b5fe.js" rel="prefetch"><link href="/_nuxt/pages/about.a3431c5910b96e7d0298.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-algebra-of-joy.7f385b55e84045676f24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-annoying-quadratic-formula.a3d9ef30d4f74df89dfd.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/church-arithmetic-and-church-logic-with-brent-kirby.e11588a1a251690d41af.js" rel="prefetch"><link href="/_nuxt/pages/rationale-for-joy.3e067852511f512169f0.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/tutorial-on-joy.9a4df70c3d63708c2b23.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/miscellaneous-miniature-implementations-of-joy.417498df53623dd27f3a.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/fast-small-truth-tables.9b1b75741215fa7afac3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy.cad646018fcc11e7f563.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/programming-in-joy.d4bc3bc57b9855085dc1.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-matrix-multiplication-programs.8e00ebe2e6e430523681.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/imperative-thinking-for-joy-programs.223ec58c271bc7112421.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/design-of-a-joy-interpreter-written-in-joy.eaa748fa0ea2130e1164.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/joy-compared-with-other-functional-languages.e9b1e34a3b81758a64f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/recursion-theory-and-joy.7d268252a6e6c71fa9f2.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/nested-recursion-and-a-new-recursion-combinator.d40eac9bf6ad0e5cac92.js" rel="prefetch"><link href="/_nuxt/pages/faq.9ffdbd52d27b2df75f94.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/mathematical-foundations-of-joy.4f0b584e560cf803bb24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/floy-a-flat-concatenative-subset-of-joy.9162d7b51e29e1b5b1b9.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/html-manual.e3473b0453170639a088.js" rel="prefetch"><link href="/_nuxt/pages/faq-part-2.9630745e3aaebc47633f.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/lazy-lists-as-reproducing-programs.9516d2d5134cfed90ce3.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/the-current-implementation.e033c23017443bc35c24.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/a-rewriting-system-for-joy.4157d6f1ef190fb675ea.js" rel="prefetch"><link href="/_nuxt/pages/papers-on-joy/atomic-programs-of-joy.f2cb1414ae2b6ed9401e.js" rel="prefetch"><link href="/_nuxt/pages/c-sources/prospectus-for-john-cowans-joy1.cb4661329c1ed2df6752.js" rel="prefetch"><style data-vue-ssr-id="d505b096:0">html{font-family:Roboto,Arial,sans-serif;margin:0;font-weight:400;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;-webkit-box-sizing:border-box;box-sizing:border-box}body{margin:0;height:100%}:after,:before,:not(pre){-webkit-box-sizing:border-box;box-sizing:border-box;margin:0}.wrapper{min-height:calc(100vh - 102px)}a{color:#3273dc;text-decoration:none}a:hover{text-decoration:underline}</style><style data-vue-ssr-id="6cc65792:0">nav[data-v-251e63b6]{background-color:#000}ul[data-v-251e63b6]{list-style-type:none;padding:0;margin:0}li[data-v-251e63b6]{-webkit-transition:all .2s ease-out;transition:all .2s ease-out;display:inline-block;padding:0;cursor:pointer}li[data-v-251e63b6]:hover{-webkit-transform:scale(1.04);transform:scale(1.04);background-color:#fff;color:#000}li a[data-v-251e63b6]{display:block;padding:15px 25px;text-decoration:none;color:#fff;text-align:center}li:hover a[data-v-251e63b6]{color:#000}.nuxt-link-exact-active[data-v-251e63b6]{text-decoration:overline}</style><style data-vue-ssr-id="59b3c72e:0">main[data-v-b86d256e]{margin-top:25px;padding-left:12vw;padding-right:12vw}p[data-v-b86d256e]{margin-top:16px}h2[data-v-b86d256e]{margin-top:16px;margin-bottom:16px}pre[data-v-b86d256e]{margin:auto}code[data-v-b86d256e],pre[data-v-b86d256e]{font-family:Roboto Mono,monospace}</style><style data-vue-ssr-id="ca9343dc:0">footer[data-v-c785faa8]{padding:11px 20px 0;height:52px}p[data-v-c785faa8]{-webkit-transition:all .1s ease-in;transition:all .1s ease-in;font-size:15px;float:right;margin:0 16px}a[data-v-c785faa8]{color:#000;text-decoration:none}p[data-v-c785faa8]:hover{-webkit-transform:scale(.94);transform:scale(.94);color:#000;-webkit-text-decoration:#3273dc overline;text-decoration:#3273dc overline}</style>
  </head>
  <body data-n-head="">
    <div id="__nuxt" data-server-rendered="true"><div id="__layout"><div class="container" lang="en"><nav data-v-251e63b6 role="navigation"><ul data-v-251e63b6><li data-v-251e63b6><a href="/" data-v-251e63b6 class="nuxt-link-active">Home</a><li data-v-251e63b6><a href="/papers-on-joy" data-v-251e63b6>Papers</a><li data-v-251e63b6><a href="/libraries-and-c-sources" data-v-251e63b6>Libraries/C sources</a><li data-v-251e63b6><a href="/about" data-v-251e63b6>About</a></ul></nav><main data-v-b86d256e><title data-v-b86d256e>Overview of the language JOY</title><h1 data-v-b86d256e>Overview of the language JOY</h1>
  Joy is a functional programming language which is significantly
  different from other programming languages of that kind.  This paper
  provides an overview of most of its practical and theoretical aspects.
  <p data-v-b86d256e>
    To add two integers, say 2 and 3, and to write their sum, you type the
    program
  <pre data-v-b86d256e>        2  3  +
  </pre>
  This is how it works internally: the first numeral causes the integer
  2 to be pushed onto a stack.  The second numeral causes the integer 3
  to be pushed on top of that.  Then the addition operator pops the two
  integers off the stack and pushes their sum, 5.
  The system reads inputs like the above and executes them when
  they are terminated by a period <code data-v-b86d256e>"."</code>, like this:
  <pre data-v-b86d256e>        2  3  + .
  </pre>
  In the default mode there is no need for an explicit output instruction,
  so the numeral <code data-v-b86d256e>5</code> is now written to the output file which
  normally is the screen. So, in the default mode the terminating
  <code data-v-b86d256e>"."</code> may be taken to be an instruction to write the
  top element of the stack. In what follows the terminating period will
  not be shown any further.
  <p data-v-b86d256e>
    To compute the square of an integer, it has to be multiplied by
    itself.  To compute the square of the sum of two integers, the sum has
    to be multiplied by itself.  Preferably this should be done without
    computing the sum twice.
    The following is a program to compute the square of the sum of 2 and 3:
  <pre data-v-b86d256e>        2  3  +  dup  *
  </pre>
  After the sum of 2 and 3 has been computed, the stack just contains
  the integer 5.  The <kbd data-v-b86d256e>dup</kbd> operator then pushes another copy
  of the 5 onto the stack.  Then the multiplication operator replaces
  the two integers by their product, which is the square of 5.  The
  square is then written out as 25.  Apart from the <code data-v-b86d256e>dup</code>
  operator there are several others for re-arranging the top of the
  stack.  The <kbd data-v-b86d256e>pop</kbd> operator removes the top element, and the
  <kbd data-v-b86d256e>swap</kbd> operator interchanges the top two elements.
  <p data-v-b86d256e>
    A <em data-v-b86d256e>list</em> of integers is written inside square brackets.  Just
    as integers can be added and otherwise manipulated, so lists can be
    manipulated in various ways.  The following <kbd data-v-b86d256e>concat</kbd>enates
    two lists:
  <pre data-v-b86d256e>        [1 2 3]  [4 5 6 7]  concat
  </pre>
  The two lists are first pushed onto the stack.  Then the
  <code data-v-b86d256e>concat</code> operator pops them off the stack and pushes the
  list <code data-v-b86d256e>[1 2 3 4 5 6 7]</code> onto the stack.  There it may be
  further manipulated or it may be written to the output file.
  <p data-v-b86d256e>
    Joy makes extensive use of <em data-v-b86d256e>combinator</em>s.  These are like
    operators in that they expect something specific on top of the stack.
    But unlike operators they execute what they find on top of the stack,
    and this has to be the <em data-v-b86d256e>quotation</em> of a program, enclosed in
    square brackets.  One of these is a combinator for <kbd data-v-b86d256e>map</kbd>ping
    elements of one list via a function to another list.  Consider the
    program
  <pre data-v-b86d256e>        [1 2 3 4]  [dup *]  map
  </pre>
  It first pushes the list of integers and then the quoted program onto
  the stack.  The <code data-v-b86d256e>map</code> combinator then removes the list and
  the quotation and constructs another list by applying the program to
  each member of the given list.  The result is the list <code data-v-b86d256e>[1 4 9
  16]</code> which is left on top of the stack.
  <p data-v-b86d256e>
    In <em data-v-b86d256e>definition</em>s of new functions no formal parameters are
    used, and hence there is no substitution of actual parameters for
    formal parameters.  After the following definition
  <pre data-v-b86d256e>        square   ==   dup  *
  </pre>
  the symbol <code data-v-b86d256e>square</code> can be used in place of <code data-v-b86d256e> dup *
  </code>.
  <p data-v-b86d256e>
    As in other programming languages, definitions may be recursive, for
    example in the definition of the factorial function.  That definition
    uses a certain recursive pattern that is useful elsewhere.  In Joy
    there is a combinator for <em data-v-b86d256e>primitive recursion</em> which has this
    pattern built in and thus avoids the need for a definition.  The
    <kbd data-v-b86d256e>primrec</kbd> combinator expects two quoted programs in addition
    to a data parameter.  For an integer data parameter it works like
    this: If the data parameter is zero, then the first quotation has to
    produce the value to be returned.  If the data parameter is positive
    then the second has to combine the data parameter with the result of
    applying the function to its predecessor.  For the factorial function
    the required quoted programs are very simple:
  <pre data-v-b86d256e>        [1]  [*]  primrec
  </pre>
  computes the factorial recursively.  There is no need for any
  definition.
  For example, the following program computes the factorial of
  <code data-v-b86d256e>5</code>:
  <pre data-v-b86d256e>        5  [1]  [*]  primrec
  </pre>
  It first pushes the number <code data-v-b86d256e>5</code> and then it pushes the two
  short quoted programs.  At this point the stack contains three
  elements.  Then the <code data-v-b86d256e>primrec</code> combinator is executed.  It
  pops the two quotations off the stack and saves them elsewhere.  Then
  <code data-v-b86d256e>primrec</code> tests whether the top element on the stack
  (initially the <code data-v-b86d256e>5</code>) is equal to zero.  If it is, it pops it
  off and executes one of the quotations, the <code data-v-b86d256e>[1]</code> which
  leaves <code data-v-b86d256e>1</code> on the stack as the result.  Otherwise it pushes
  a decremented copy of the top element and recurses. On the way back
  from the recursion it uses the other quotation, <code data-v-b86d256e>[*]</code>, to
  multiply what is now a factorial on top of the stack by the second
  element on the stack.  When all is done, the stack contains
  <code data-v-b86d256e>120</code>, the factorial of <code data-v-b86d256e>5</code>.
  <p data-v-b86d256e>
    As may be seen from this program, the usual branching of recursive
    definitions is built into the combinator.  The <code data-v-b86d256e>primrec</code>
    combinator can be used with many other quotation parameters to compute
    quite different functions.  It can also be used with data types other
    than integers.
    Joy has many more combinators which can be used to calculate many
    functions without forcing the user to give recursive or non-recursive
    definitions.  Some of the combinators are more data-specific than
    <code data-v-b86d256e>primrec</code>, and others are far more general.
  <p data-v-b86d256e>
    Joy programs are built from smaller programs by just two operations:
    <em data-v-b86d256e>concatenation</em> and <em data-v-b86d256e>quotation</em>.
    Concatenation is a binary operation, and since it is associative it is
    best written in infix notation and hence no parentheses are required.
    Since concatenation is the only binary operation of its kind, in Joy
    it is best written without an explicit symbol.
    Quotation is a unary operation which takes as its operand a program.
    In Joy the quotation of a program is written by enclosing it in square
    brackets.  Ultimately all programs are built from atomic programs
    which do not have any parts.
    The semantics of Joy has to explain what the atomic programs mean, how
    the meaning of a concatenated program depends on the meaning of its
    parts, and what the meaning of a quoted program is.  Moreover, it has
    to explain under what conditions it is possible to replace a part by
    an equivalent part while retaining the meaning of the whole program.
  <p data-v-b86d256e>
    Joy programs denote functions which take one argument and yield one
    value.  The argument and the value are <em data-v-b86d256e>state</em>s consisting of
    at least three components.  The principal component is a
    <em data-v-b86d256e>stack</em>, and the other components are not needed here.  Much of
    the detail of the semantics of Joy depends on specific properties of
    programs.  However, central to the semantics of Joy is the following:
    The concatenation of two programs denotes
    the composition of the functions denoted by the two programs.
    Function composition is associative, and hence denotation maps the
    associative syntactic operation of program concatenation onto the
    associative semantic operation of function composition.  The quotation
    of a program denotes a function which takes any state as argument and
    yields as value the same state except that the quotation is pushed
    onto the stack.
    One part of a concatenation may be replaced by another part denoting
    the same function while retaining the denotation of the whole
    concatenation.
    One quoted program may be replaced by another denoting the same
    function only in a context where the quoted program will be dequoted
    by being executed.  Such contexts are provided by the
    <em data-v-b86d256e>combinator</em>s of Joy.  These denote functions which behave like
    higher order functions in other languages.
  <p data-v-b86d256e>
    The above may be summarised as follows: Let <code data-v-b86d256e>P</code>,
    <code data-v-b86d256e>Q1</code>, <code data-v-b86d256e>Q2</code> and <code data-v-b86d256e>R</code> be programs, and
    let <code data-v-b86d256e>C</code> be a combinator.  Then this principle holds:
  <pre data-v-b86d256e>        IF          Q1      ==      Q2
          THEN     P  Q1  R   ==   P  Q2  R
          AND        [Q1] C   ==     [Q2] C
  </pre>
  The principle is the prime rule of inference for the <em data-v-b86d256e>algebra of
  Joy</em> which deals with the equivalence of Joy programs, and hence
  with the identity of functions denoted by such programs.  A few laws
  in the algebra can be expressed without combinators, but most require
  one or more combinators for their expression.
  <p data-v-b86d256e>
    Joy programs denote functions which take <em data-v-b86d256e>state</em>s as arguments
    and as values.  Programs are built from atomic programs which also
    denote functions which take states as arguments and as values.
    The meaning of compound programs has to be given in terms of the
    meanings of atomic programs.  It is useful to classify atomic programs
    into categories depending on what kind of function they denote.  A
    coarse classification distinguishes just three, called
  <ol data-v-b86d256e><li data-v-b86d256e>the <em data-v-b86d256e>literal</em>s,
    <li data-v-b86d256e>the <em data-v-b86d256e>operator</em>s and 
    <li data-v-b86d256e>the <em data-v-b86d256e>combinator</em>s.
    </ol><p data-v-b86d256e>
    Firstly, the <em data-v-b86d256e>literal</em> atomic programs are those which look
    like constants in conventional languages.  They comprise literal
    numbers (or, more correctly, numerals) such as integers, and other
    literals of type character, string, truth value and set.  Literals do
    not denote numbers, characters, strings and so on, but they denote
    functions which take one state as argument and yield as value another
    state which is like the argument state except that the value of the
    literal has been pushed onto the stack component.
  <p data-v-b86d256e>
    Secondly, the <em data-v-b86d256e>operator</em> atoms are those which look like <em data-v-b86d256e>
    n</em>-ary operators in other languages.  They include the operations
    such as for addition and the other arithmetical operations, and for
    the various operations on other types.  Like all programs, operators
    denote functions from states to states, but the functions are not
    defined on all states.  An <em data-v-b86d256e> n</em>-ary operator (such as the
    binary addition operator) denotes a function which is defined only on
    states whose stack component has <em data-v-b86d256e> n</em> items (such as two
    integers) on top.
    The function yields as value another state which is like the argument
    state except that the <em data-v-b86d256e> n</em> items on the stack have been
    replaced by the result (such as the sum).
    Also included as operators are those atoms denoting mere structural
    functions of the stack component such as <code data-v-b86d256e>dup</code>,
    <code data-v-b86d256e>swap</code> and <code data-v-b86d256e>pop</code>, and those that involve input
    and output such as <code data-v-b86d256e>get</code> and <code data-v-b86d256e>put</code>.
  <p data-v-b86d256e>
    Thirdly, the <em data-v-b86d256e>combinator</em> atoms are like operators in that they
    require the top of the stack to contain certain items.  But unlike
    operators, they do not treat these items as passive data.  Instead
    they execute these items - and hence those items must be quoted
    programs.  So, combinators also denote functions which are defined
    only on states having the appropriate number of quoted programs on top
    of the stack.  They yield as values another state which depends on the
    argument state, including the quoted programs, and on the combinator
    itself.
  <p data-v-b86d256e>
    Literals, operators and combinators can be concatenated to form
    <em data-v-b86d256e>program</em>s.  These may then be enclosed in square brackets to
    form literal <em data-v-b86d256e>quotation</em>s.  Such literals are not atomic, but
    if they occur in a program they are treated just like other literals:
    they cause the quoted program to be pushed onto the stack.  So,
    literal quotations denote functions which take any stack as argument
    and yield as value another stack which is like the argument stack
    except that it has the quotation pushed on top.  Quotations on top of
    the stack can be treated like other values, they can be manipulated,
    taken apart and combined, but they can also be executed by
    combinators.  If a quotation contains only literals, then it is a
    <em data-v-b86d256e>list</em>.  The component literals do not have to be of the same
    type, and they may include further quotations.  If a list is executed
    by a combinator, then its components are pushed onto the stack.
  <p data-v-b86d256e>
    Concatenation of Joy programs denote the composition of the functions
    which the concatenated parts denote.  Hence if <code data-v-b86d256e> Q1 </code> and
    <code data-v-b86d256e> Q2 </code> are programs which denote the same function and
    <code data-v-b86d256e> P </code> and <code data-v-b86d256e> R </code> are other programs, then the two
    concatenations <code data-v-b86d256e> P Q1 R </code> and <code data-v-b86d256e> P Q2 R </code> also
    denote the same function.  In other words, programs <code data-v-b86d256e> Q1 </code>
    and <code data-v-b86d256e> Q2 </code> can replace each other in concatenations.  This
    can serve as a rule of inference for <em data-v-b86d256e>rewriting</em>.
    As premises one needs axioms such as in the first three lines below,
    and definitions such as in the fourth line:
  <pre data-v-b86d256e>(+)                2  3  +   ==   5
  (dup)              5  dup   ==   5  5
  (*)                5  5  *   ==   25
  (def square)       square  ==  dup *
  </pre>
  A derivation using the above axioms and the definition looks like this:
  <pre data-v-b86d256e>                   2  3  +  square
             ==      5  square                               (+)
             ==      5  dup  *                               (def square)
             ==      5  5  *                                 (dup)
             ==      25                                      (*)
  </pre>
  The comments in the right margin explain how a line was obtained from
  the previous line.  The derivation shows that the expressions in the
  first line and the last line denote the same function, or that the
  function in the first line is identical with the function in the last
  line.
  <p data-v-b86d256e>
    Consider the following equations in infix notation:The first says that
    multiplying a number <code data-v-b86d256e>x</code> by 2 gives the same result as
    adding it to itself.  The second says that the <kbd data-v-b86d256e>size</kbd> of a
    <kbd data-v-b86d256e>reverse</kbd>d list is the same as the <code data-v-b86d256e>size</code> of the
    original list.
  <pre data-v-b86d256e>        2 * x  =  x + x                 size(reverse(x))  =  size(x)
  </pre>
  In Joy the same equations would be written, <em data-v-b86d256e> without
  variables</em>, like this:
  <pre data-v-b86d256e>        2  *   ==   dup  +              reverse  size   ==   size
  </pre><p data-v-b86d256e>
    Other equivalences express algebraic properties of various operations.
    For example, the predecessor <kbd data-v-b86d256e>pred</kbd> of the successor
    <kbd data-v-b86d256e>succ</kbd> of a number is just the number itself.  The
    conjunction <kbd data-v-b86d256e>and</kbd> of a truth value with itself gives just the
    truth value.  The less than relation <code data-v-b86d256e>&lt;</code> is the converse of
    the greater than relation <code data-v-b86d256e>></code>.  Inserting a number with
    <kbd data-v-b86d256e>cons</kbd> into a list of numbers and then taking the
    <kbd data-v-b86d256e>sum</kbd> of that gives the same result as first taking the sum
    of the list and then adding the other number.
    In conventional notation these are expressed by
  <pre data-v-b86d256e>        pred(succ(x))  =  x             x and x  =  x
          x &lt; y  =  y > x                 sum(cons(x,y))  =  x + sum(y)
  </pre>
  In Joy these are expressed <em data-v-b86d256e> without variables</em><pre data-v-b86d256e>        succ  pred   ==   id            dup  and   ==   id
          &lt;   ==   swap >                 cons  sum   ==   sum  +
  </pre>
  Some properties of operations have to be expressed by combinators.
  One of these is the <kbd data-v-b86d256e>dip</kbd> combinator which expects a program
  on top of the stack and below that another value.  It saves the value,
  executes the program on the remainder of the stack and then restores
  the saved value.
  <p data-v-b86d256e>
    In the first example below, the <code data-v-b86d256e>dip</code> combinator is used to
    express the associativity of addition.  Another combinator is the
    <kbd data-v-b86d256e>app2</kbd> combinator which expects a program on top of the stack
    and below that two values.  It applies the program to the two values.
  <p data-v-b86d256e>
    In the second example below it expresses one of the De Morgan laws.
    In the third example it expresses that the <kbd data-v-b86d256e>size</kbd> of two
    lists <kbd data-v-b86d256e>concat</kbd>enated is the sum of the <code data-v-b86d256e>size</code>s of
    the two concatenands.
  <p data-v-b86d256e>
    The last example uses both combinators to express that multiplication
    distributes (from the right) over addition.  (Note that the program
    parameter for <code data-v-b86d256e>app2</code> is first constructed from the
    multiplicand and <code data-v-b86d256e>*</code>.)
  <pre data-v-b86d256e>        [+]  dip  +   ==   +  +
          and  not   ==   [not]  app2  or
          concat  size   ==   [size]  app2  +
          [+]  dip  *   ==   [*]  cons  app2  +
  </pre><p data-v-b86d256e>
    A deep result in the theory of computability concerns the elimination
    of recursive definitions.  To use the stock example, the
    <em data-v-b86d256e>factorial</em> function can be <em data-v-b86d256e> defined</em> recursively in
    Joy by
  <pre data-v-b86d256e>        factorial  ==
              [0 =] [pop 1] [dup 1 - factorial *] ifte
  </pre>
  The definition is then <em data-v-b86d256e> used</em> in programs like this:
  <pre data-v-b86d256e>        5
          factorial
  </pre>
  Because in Joy programs can be manipulated as data, the factorial
  function can also be computed recursively without a recursive
  definition, as follows:
  <pre data-v-b86d256e>        5
          [ [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte ]
          [dup cons] swap concat dup cons i
  </pre>
  The second line in this program does much the same as the body of the
  definition of factorial, but it is a quoted program.  The third line
  first transforms this into another longer quoted program which
  performs "anonymous" recursion, and then the final <kbd data-v-b86d256e>i</kbd>
  combinator essentially dequotes this program causing its execution.
  <p data-v-b86d256e>
    The third line implements Joy's counterpart of the <em data-v-b86d256e>Y</em>
    combinator of the lambda calculus.  Exactly the same line can be used
    to cause anonymous recursion of other functions which are normally
    defined recursively.
  <p data-v-b86d256e>
    Joy has other combinators which make recursive execution of programs
    more succinct.  (Of course it is also possible in Joy to compute the
    factorial function more efficiently with iteration instead of
    recursion.)
  <p data-v-b86d256e>
    Since Joy is very different from familiar programming languages, it
    takes a while to become used to writing programs in Joy.  One way to
    start the learning process is by way of writing some simple generally
    useful library programs.  In an implementation these may be part of an
    actual library, or they may be built into the language.
  <p data-v-b86d256e>
    Some general <em data-v-b86d256e>utility program</em>s include operators for
    manipulating the Joy stack just below the top element, further
    operators for manipulating aggregate values, and a few output
    programs.
  <p data-v-b86d256e>
    Generally useful are the <em data-v-b86d256e>stack type</em> and the <em data-v-b86d256e>queue
    type</em>.  Values and operators of these two types are easily
    implemented as Joy lists and list operators.
  <p data-v-b86d256e>
    Another collection of useful operators take an aggregate as parameter
    and produce a list of subaggregates.  These operators are
    <em data-v-b86d256e>polymorphic</em> in the sense that the aggregate parameter can be
    a (small) set, a string, or a list.  One such operator can take a set
    as parameter and produces a list of its subsets.  All of these
    operators are definable without recursion by using the
    <kbd data-v-b86d256e>linrec</kbd> combinator.
  <p data-v-b86d256e>
    Some <em data-v-b86d256e>arithmetic operators</em> are often used to illustrate
    recursive definitions, although it is well known that iterative
    execution is more efficient.  In particular the use of
    <em data-v-b86d256e>accumulating parameter</em>s can often replace recursion.  This is
    easily done in Joy using various iteration combinators.
  <p data-v-b86d256e>
    Values of <em data-v-b86d256e>sequence type</em>s, such as strings and lists, can be
    <em data-v-b86d256e>sort</em>ed, and sorted sequences can be <em data-v-b86d256e>merge</em>d.
    Programs for doing this are easily written in Joy without recursive
    definitions but using appropriate combinators instead.
  <p data-v-b86d256e>
    Joy's inbuilt datatype of sets is implemented just as bitstrings, and
    hence it is limited to small sets of small numbers.  The more useful
    <em data-v-b86d256e>big set type</em>, which allows large sets of elements of any
    type, can be implemented in any language which has lists.  It is
    simple to do in Joy, and the usual set-theoretic operations are easily
    provided.  A similar implementation can be used for the <em data-v-b86d256e>dictionary
    type</em>, which uses lookup tables for finite functions.
  <p data-v-b86d256e>
    Also useful is the <em data-v-b86d256e>tree type</em>, of lists, or lists of lists, or
    lists of lists of lists ...  of elements other than lists.
  <p data-v-b86d256e>
    A <em data-v-b86d256e>rewriting system</em> consists of a set of syntactic rules for
    performing replacements on certain suitable entities.  The best known
    such system is the one we learnt at school for evaluating arithmetic
    expressions.  Any programming language can be given a rewriting
    system, but for Joy it is particularly simple.  The basic binary
    rewriting relation will be written in infix notation as
    "<code data-v-b86d256e>-></code>", pronounced "can be rewritten as".  The following
    are some sample rules for the <code data-v-b86d256e>+</code> and <code data-v-b86d256e>&lt;</code>
    operators and for the <kbd data-v-b86d256e>dip</kbd> combinator.
  <pre data-v-b86d256e>        2  3  +   ->   5
          2  3  &lt;   ->   true
          a  [P]  dip   ->   P  a
  </pre>
  In the last example, <code data-v-b86d256e>P</code> is any program and <code data-v-b86d256e>a</code>
  is any literal (such as a number) or a program whose net effect is to
  push exactly one item onto the stack.  The rewriting relation is
  extended to allow rewriting in appropriate contexts, further extended
  to accomodate several rewriting steps, and finally extended to become
  a congruence relation, an equivalence relation compatible with program
  concatenation.  This congruence relation between programs is
  essentially the same as the identity relation in the algebra of of
  functions which the programs denote.  Although Joy functions take a
  stack as argument and value, in the rewrite rules the stack is never
  mentioned.
  <p data-v-b86d256e>
    The following are rewriting rules for arithmetic expressions in four
    different notations: infix, functional, prefix and postfix:
  <pre data-v-b86d256e>        2 + 3  ->  5                    +(2,3)  ->  5
          + 2 3  ->  5                    2 3 +  ->  5
  </pre>
  In each case on the left the operands are <code data-v-b86d256e>2</code> and
  <code data-v-b86d256e>3</code>, and the operator or <em data-v-b86d256e>constructor</em> is
  <code data-v-b86d256e>+</code>, so they all refer to the same arithmetic term.  Since
  Joy uses postfix notation, it might be thought that one should attempt
  a term rewriting system with rules just like the second one in the
  last line.  That would treat the short program <code data-v-b86d256e>2 3 +</code> as
  being composed of two operands and an operator or constructor.  It
  would also treat the gap between <code data-v-b86d256e>2</code> and <code data-v-b86d256e>3</code> as
  quite different from the gap between <code data-v-b86d256e>3</code> and
  <code data-v-b86d256e>+</code>.  The difference would be explained away as a syntactic
  coincidence due to the choice of notation.  Apart from <code data-v-b86d256e>+</code>
  there would be very many term constructors.
  <p data-v-b86d256e>
    However, Joy has operators for manipulating the top few elements of
    the stack, such as <kbd data-v-b86d256e>swap</kbd>, <kbd data-v-b86d256e>dup</kbd> and <kbd data-v-b86d256e>pop</kbd>.
    These are also found in the language <em data-v-b86d256e>Forth</em>.  These operators
    take a stack as argument and yield a stack as value, and their
    presence forces all other operators to be of the same type.  For
    example, the following is a rewrite rule for <kbd data-v-b86d256e>swap</kbd>:
  <pre data-v-b86d256e>        a  b  swap   ->   b  a
  </pre>
  Unlike Forth, Joy also has quotations and combinators.  These features
  also force the conclusion that the appropriate rewriting system is a
  string rewriting system.  Consider the following four programs:
  <pre data-v-b86d256e>        [2] [3 +] b                     [2] [3 +] concat i
          [2 3] [+] b                     [2 3] [+] concat i
  </pre>
  They all eventually have to reduce to <code data-v-b86d256e>5</code>, just like the
  earlier Joy program <code data-v-b86d256e>2 3 +</code>.  It suggests that in the
  latter the gaps have to be treated in the same way, the program is a
  concatenation of three atomic symbols, and it denotes the composition
  of three functions.  So, at least for Joy programs without quotations
  and combinators, the appropriate system is a string rewriting system.
  Such a system is equivalent to a term rewriting system with a
  <em data-v-b86d256e>concatenation constructor</em> for programs as the only
  constructor.  To handle combinators, a <em data-v-b86d256e>quotation constructor</em>
  has to be introduced as a second constructor.
  <p data-v-b86d256e>
    The best known functional languages are the <em data-v-b86d256e>lambda calculus</em>
    and, based on it, the programming languages LISP and its descendants.
    All of them rely heavily on two operations, abstraction and
    application, which are in some sense inverses of each other.
    Abstraction binds free variables in an expression, and it yields a
    function which is a first class value.
  <p data-v-b86d256e>
    The bound variables are the formal parameters of the function, and,
    importantly, they are named.  Application of an abstracted function to
    some actual parameters can be understood as resulting in a
    substitution of actual for formal parameters and then evaluation of
    the modified expression.  More efficiently application can be
    implemented using an <em data-v-b86d256e>environment</em> of name-value pairs.  The
    lambda calculus does not need definitions, but all functional
    programming languages allow them as a matter of convenience.
    Definitions also use named formal parameters, and in applications
    these have to be substituted or an environment has to be maintained.
  <p data-v-b86d256e>
    Two other functional languages are the <em data-v-b86d256e>combinatory logic</em> of
    Curry and the <em data-v-b86d256e>FP</em> language of Backus.
    They are not based on the lambda calculus, they eliminate abstraction
    completely and hence do not have to deal with substitution and
    environments.  As a result these languages can be manipulated using
    simple algebraic techniques.  But like the lambda calculus and the
    languages derived from it, both are based on the application of
    functions to arguments.  However, application does not have attractive
    algebraic properties, and hence there is no theoretical reason for
    preferring one concrete notation over another.  
  <p data-v-b86d256e>
    The languages of <em data-v-b86d256e>category</em> theory comprises another group of
    functional languages.  Whereas the other functional languages use
    function application, these use function composition.  No high level
    programming language has been based on this formalism, but it has been
    used as a low level machine language as a target for compilation from
    a (typed) lambda calculus source.  Joy is a high level programming
    language which resembles the categorical languages more than it
    resembles any of the other functional languages.
  <p data-v-b86d256e>
    The prototype implementation is written in (K&R) C; it uses a
    simple stop-copy heap management.
  </main><footer data-v-c785faa8><p data-v-c785faa8><a href="https://github.com/joy-language/joy-lang.org" data-v-c785faa8>GitHub</a></footer></div></div></div><script type="text/javascript">window.__NUXT__={layout:"default",data:[{}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.10669f42b2e188f55eb1.js"></script><script defer src="/_nuxt/layouts/default.29c0e08e13310e3682fc.js"></script><script defer src="/_nuxt/pages/overview-of-joy.8733ad0cbce5d065d604.js"></script><script defer src="/_nuxt/vendor.230cb916d1973aa790f3.js"></script><script defer src="/_nuxt/app.0a856c7cf6fb3e349fa2.js"></script>
  

