webpackJsonp([25],{C7fs:function(e,n,t){var o=t("Ye6l");"string"==typeof o&&(o=[[e.i,o,""]]),o.locals&&(e.exports=o.locals);t("rjj0")("9fbece12",o,!1,{sourceMap:!1})},Sljb:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o=t("nA6b"),a=!1;var i=function(e){a||t("C7fs")},r=t("VU/8")(null,o.a,!1,i,"data-v-1ebc7d28",null);r.options.__file="pages/faq-part-2.vue",n.default=r.exports},Ye6l:function(e,n,t){(e.exports=t("FZ+f")(!1)).push([e.i,"main[data-v-1ebc7d28]{margin-top:25px;padding-left:12vw;padding-right:12vw}p[data-v-1ebc7d28]{margin-top:16px}h2[data-v-1ebc7d28]{margin-top:16px;margin-bottom:16px}pre[data-v-1ebc7d28]{margin:auto}code[data-v-1ebc7d28],pre[data-v-1ebc7d28]{font-family:Roboto Mono,monospace}",""])},nA6b:function(e,n,t){"use strict";var o=function(){var e=this.$createElement;this._self._c;return this._m(0)};o._withStripped=!0;var a={render:o,staticRenderFns:[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("main",[e._v("\n  Contents:\n  "),t("ol",[t("li",[e._v('"Why is == an infix operator ?"\n    ')]),t("li",[e._v('"But why can\'t definitions be entered at run-time ?"\n    ')]),t("li",[e._v('"What happens if one takes the first of [dup *] ?"\n    ')]),t("li",[e._v('"Why does Joy have all those recursion combinators ?"\n    ')]),t("li",[e._v('"So why don\'t other languages have recursion combinators ?"\n    ')]),t("li",[e._v('"Are there any higher order combinators ?\n    ')])]),t("h2",[e._v('1. "Why is == an infix operator ?"')]),e._v("\n  In Joy almost all operators are written in postfix order,\n  after their operands.\n  One exception seems to be the == operator in definitions.\n  Why should == be treated differently from the others?\n  "),t("p",[e._v('\n    In just about all programming languages a program consists of a number\n    of definitions of procedures or functions.\n    Among them is one, called "main" in C, or an anonymous one in Pascal,\n    which is the starting point.\n    The same pattern occurs in grammars, which consist of definitions\n    of non-terminals, including one that is called "start" or whatever.\n    The pattern is also used in most macro expanders\n    in which a collection of macro definitions is processed.\n  ')]),t("p",[e._v("\n    Any one of the definitions consists of two parts:\n    1) a name, and 2) a body obeying a syntax very specific to the language.\n    In procedural languages like C or Pascal the body is a\n    statement sequence.\n    In functional languages the body is an applicative expression.\n    In grammars the body is a regular expression over terminals\n    and non-terminals.\n    In macro expanders the body consists of literal text.\n    In each case the body may contain calls to items defined elsewhere.\n  ")]),t("p",[e._v("\n    A definition contains a body as a part.\n    The body must satisfy certain syntactic rules,\n    and so must the whole definition.\n    But in all cases the syntax for a whole definition is different\n    from that of its largest part, the body.\n    In procedural languages the body is a statement sequence,\n    but a definition is not.\n    In functional languages a body is an applicative expression,\n    but a definition is not.\n    In grammars a body is a regular expression,\n    but a definition is not.\n    In macro expanders a body is just text, but a definition is not.\n    Lisp looks like an exception,\n    because both bodies and definitions are symbolic expressions,\n    written in a minimal syntax.\n    But there are restrictions on definitions that are not imposed on bodies.\n  ")]),t("p",[e._v("\n    Definitions and bodies play very different roles.\n    The difference is most conspicuous in fully compiled implementations.\n    During compilation definitions produce entries in a symbol table,\n    and the bodies are translated into directly executable machine language,\n    but the bodies are not executed.\n    The resulting compiled program contains no trace of the\n    symbol table (except when it has been compiled for a run with\n    a symbolic debugger).When the compiled program is run,\n    a new structure appaears, typically at least a run-time stack,\n    which did not exist during compilation.\n    Now the body of the main program and any other called bodies\n    can be executed.\n  ")]),t("p",[e._v("\n    The compilation stage need not translate bodies into directly\n    executable machine language.\n    The target language is some idealised machine language which needs\n    to be interpreted.\n    When such a program is run,\n    there will be a run-time stack and in addition a software interpreter.\n    (The portable Pascal implementation P4 works like this.)\n  ")]),t("p",[e._v("\n    Even if the compiler and the interpreter are in the same program,\n    there still are these two stages:\n    1) reading a program, processing definitions and compiling bodies\n    into some internal form, and\n    2) running a program by interpreting the internal form.\n    When the program is run, the symbol table is still there,\n    but no new definitions are entered.\n    The run-time stack and other structures are present during reading,\n    but only used now when the translated bodies are executed by\n    the interpreter.\n  ")]),t("p",[e._v("\n    Numerous variations are possible,\n    but the difference between the two stages is always present.\n    So there is no reason to use the same syntax for definitions and bodies.\n    The same applies to Joy.\n  ")]),t("p",[e._v("\n    The syntax for definitions in Joy is"),t("br")]),t("pre",[e._v("        name   ==   body\n  ")]),e._v('\n  where the body is a concatenative expression.\n  The symbol "==" could even be left out altogether.\n  A definition sequence consists of\n  one or more definitions separated by semicolons.\n  Importantly, unlike "==", the semicolon could not be left out.\n  Definition sequences are headed by "LIBRA" or "DEFINE"\n  and terminated by a period.\n  But none of the the symbols\n  "LIBRA", "DEFINE", "==", ";" and "."\n  denote run-time operations like "+", "cons" or "map" do.\n  The same is true for\n  "HIDE", "IN" and "END" in local definitions.\n  '),t("p",[e._v('\n    So, "==" is not a postfix operator\n    because it is not a run-time operator\n    any more that the other symbols used in definitions.\n  ')]),t("h2",[e._v('2. "But why can\'t definitions be entered at run-time ?"')]),e._v("\n  This question is very different from the preceding one.\n  Whatever the syntax of definitions, it would be possible to\n  allow definitions to be entered at run-time.\n  But it may well be a bad idea.\n  "),t("p",[e._v("\n    For the sake of having a concrete example, consider the ordinary\n    definition\n  ")]),t("pre",[e._v(" cube   ==   dup  dup  *  *\n  ")]),e._v('\n  that is normally processed at compile-time.\n  If such a definition is to be entered into the symbol table\n  at run-time, then the two parts must be available:\n  1) the name "cube", and 2) the body "dup dup * *".\n  Clearly none of the following will do\n  '),t("pre",[e._v(" cube   ==   dup  dup  *  *\n    cube  dup  dup  *  *   ==\n    cube  [dup dup * *]   DEF\n  ")]),e._v('\n  because the initial occurence of "cube" will at run-time\n  produce a call to that function which has not yet been defined.\n  So the name of the function being defined has to be expressed\n  in a way that prevents a call and instead produces an entry into\n  the symbol table.\n  Furthermore, the two occurrences of "dup" and of "*"\n  in the first two candidates\n  also have to be prevented from producing a call,\n  as indeed they are in the third candidate.\n  '),t("p",[e._v("\n    This suggest the other notation"),t("br")]),t("pre",[e._v(' "cube"  [dup dup * *]  DEF\n  ')]),e._v('\n  In other words, "DEF" would expect a string and a quotation\n  on top ot the stack, it would pop these off and enter the definition.\n  In that case the following would produce the same result:\n  '),t("pre",[e._v(' "uc"  reverse  "xbe"  rest  concat  [dup dup * *]  DEF\n  ')]),e._v("\n  However it is dubious whether such freedom to construct names\n  by string manipulation can do anything but obfuscate a program.\n  Other possibilities are these:\n  "),t("pre",[e._v(" [cube]  first  [dup dup * *]  DEF1\n    [cube  dup dup * *]  DEF2\n  ")]),e._v("\n  In both cases the new symmbol being defined occurs\n  inside a quotation so it is not being executed.\n  In the first case the symbol even ends up on the Joy stack\n  just on its own, but again it is not executed.\n  The two styles are essentially equivalent,\n  although DEF1 and DEF2 have different expectations as to\n  what has to be on top of the stack.\n  Their equivalence can be seen by the mutual\n  definitions - ordinary definitions, that is -\n  "),t("pre",[e._v(" DEF1   ==     cons  DEF2\n    DEF2   ==   uncons  DEF1\n  ")]),e._v("\n  Both styles lend themselves to program manipulation\n  before the definitions are entered, for example\n  "),t("pre",[e._v(" [cube]  first  [* * dup dup]  reverse  DEF1\n    [* *]  [dup dup]  concat  [cube]  swoncat  DEF2\n  ")]),e._v('\n  Note that this is quite different from the construction\n  of quotations\n  that is often used in Joy  before the quotations are\n  processed by a combinator.\n  For example, it is now possible to initialise\n  a definition, say of "current-item", by\n  '),t("pre",[e._v(" [current-item  1]   DEF2\n  ")]),e._v("\n  and to update it with, say an increment of 3, by\n  "),t("pre",[e._v(" current-item  3  +  []  cons  [current-item]  swoncat  DEF2\n  ")]),e._v('\n  This means that the name "current-item" is actually\n  the name of a variable which can be updated in all manners\n  of ways.\n  Hence the language would have assignment statements\n  (with a terrible syntax).\n  But assignment statements are what Joy and all purely functional\n  languages try to avoid.\n  '),t("p",[e._v("\n    In the above example, current-item is an integer variable.\n    Clearly one could have string or set or list variables, too.\n    One could also have operator variables,\n    or combinator variables,\n    or quotation variables,\n    or variables that start their life as integer variables\n    and then become all sorts of other kinds of variables.\n    So, allowing definitions to be entered at run-time\n    would open all the possibilities of programs that\n    constantly modify themselves.\n    But it is widely agreed that this is a bad idea.\n  ")]),t("h2",[e._v('3. "What happens if one takes the first of [dup *] ?"')]),e._v("\n  Or what happens if I take the second of [dup *] ?\n  The usual list operations "),t("em",[e._v("concat")]),e._v(" and "),t("em",[e._v("rest")]),e._v(" applied to a\n  quotation obviously leave a quotation on top of the stack.\n  But list operations like\n  "),t("em",[e._v("first")]),e._v(", "),t("em",[e._v("second")]),e._v(", "),t("em",[e._v("uncons")]),e._v(" and "),t("em",[e._v("unswons")]),e._v("\n  seem to leave an unadorned and unquoted\n  operator (or combinator) on the stack:\n  "),t("pre",[e._v(" [dup *]  first   ==>   dup\n    [dup *]  second  ==>   *\n    [dup *]  uncons  ==>   dup  [*]\n  ")]),e._v("\n  Does this make any sense at all? What can one do with such\n  an unadorned unquoted operator?\n  "),t("p",[e._v("\n    There are many things one can do with an unadorned operator.\n    Like any other item on the stack, it can be "),t("em",[e._v("pop")]),e._v("ped,\n    "),t("em",[e._v("swap")]),e._v("ped or "),t("em",[e._v("dup")]),e._v("ed. It can be printed\n    either by an explicit "),t("em",[e._v("put")]),e._v(" or, if the "),t("em",[e._v("setautoput")]),e._v("\n    flag is set to 1 or 2, automatically after the execution\n    of the current program.\n    Of course it can also be read back.\n    What is written or read is of course the sequence of 3 characters,\n    d-u-p, in the first case.\n    More interestingly, the unadorned operator can be made part of\n    another quotation, as in\n  ")]),t("pre",[e._v(" [dup *]  first  []  cons   ==>   [dup]\n  ")]),e._v("\n  The resulting quotation [dup] can become a parameter for\n  a combinator, for example the i-combinator which will just\n  execute what is inside the quotation.\n  So we have\n  "),t("pre",[e._v(" [dup *]  first  []  cons  i    ==    dup\n  ")]),e._v("\n  If the operator or combinator is not a primitive,\n  but defined by the user,\n  then one can get the body of its definitions as a quotation.\n  For example, in the current implementation\n  "),t("em",[e._v("first")]),e._v(" is a primitive, but "),t("em",[e._v("second")]),e._v(" is\n  defined in the initial library inilib.joy:\n  "),t("pre",[e._v(" second   ==   rest  first\n  ")]),e._v("\n  The body of that definition is accessible by"),t("br"),t("pre",[e._v(" [second]  first  body\n  ")]),e._v("\n  which will leave the quotation  [rest first] on top of the stack.\n  "),t("h2",[e._v('4. "Why does Joy have all those recursion combinators?"')]),t("p",[e._v("\n    A: In the 70's it was recognised that programs using structured IFs\n    and WHILEs are easier to get right and easier to read than programs\n    which use GOTOs and in which the pattern of the flow of control\n    has to be inferred by laborious analysis. One reason for adding\n    CASE, REPEAT and FOR was that they make programs even more\n    explicit and easier to understand. \n  ")]),t("p",[e._v("\n    In the functional languages which use lists a lot much of list\n    processing falls into a few recursion patterns which are often\n    abstracted as combinators such as map, filter and fold, and\n    also a few variants such as zipwith. Programs which use these\n    combinators by name are easier to write and easier to read than\n    programs in which the pattern of recursion on lists has to\n    be inferred.\n  ")]),t("p",[e._v("\n    Joy takes this idea a step further by combinators for recursion\n    patterns that are independent of any particular datatype such\n    as lists above. For linear recursion there is the combinator\n    linrec, its special case tailrec, and even more special case\n    while. There is also the more flexible condlinrec. For binary\n    recursion there is the combinator binrec, but so far no more\n    special or more flexible versions. For recursion with arbitrary\n    n-ary branching there is the combinator genrec, so far with\n    no variants. For recursion on trees of any type other than lists\n    there are several combinators. For nested recursion (as in the\n    Ackermann function) there will soon be two combinators nestrec\n    and condnestrec. So far there are no combinators for mutual\n    recursion. All these combinators are more intuitive and descriptive\n    than the well-known \"paradoxical\" all-purpose recursion combinators\n    (Curry's) Y and (Turing's) T which are frequently defined but\n    never used because they are all-purpose and hence not descriptive.\n  ")]),t("p",[e._v('\n    Of course the execution of programs without explicit GOTOs typically\n    involves its use internally. Similarly, the execution of programs\n    with recursion combinators but without explicit recursion typically\n    involves its use internally. But programs using combinators are\n    easier to write and read than ones using explicit recursion and\n    in which the pattern of all, not just list, recursions has to be\n    inferred. So, if you like, "Recursion considered harmful".\n  ')]),t("p",[e._v("\n    As a bonus, at least for the current implementation, programs\n    using recursion combinators are more efficient than programs\n    using explicit recursion.\n  ")]),t("h2",[e._v('5. "So why don\'t other languages have recursion combinators ?"')]),e._v("\n  A: For several, mostly independent reasons:\n  "),t("p",[e._v("\n    1. Joy combinators take quotations as arguments. Other languages\n    would have to use lambda abstractions instead. But many have no\n    way of capturing the current environments.\n  ")]),t("p",[e._v('\n    2. Apart from this, many languages could not even define a lambda\n    counterpart of Joy\'s simple i combinator - the "dequotation combinator". \n    This rules out most mainstream languages. Some counterpart might be\n    definable in the Lisps, ML, Haskell and Prolog/\n  ')]),t("p",[e._v('\n    3. Again indpendently, there will be a problem about Joy\'s simple\n    branching combinator ifte. With "eager" evaluation it is not\n    possible to define an ordinary function for branching, as Eva Lou\n    Ator will tell you, in SICP p 23. Branching has to be done with\n    "special forms" cond or if. To define them one needs delayed\n    evaluation or macros. Since the recursion combinators all\n    involve branching they need the same.\n  ')]),t("p",[e._v("\n    4. The next hurdle concerns the number of extra parameters\n    apart from the quotation parameters for combinators. In Joy\n    all parameters, including extra ones just sit on the\n    stack. A different language might do one of the following:\n    (a) Have several versions of combinators for each possible\n    number of extra parameters. (b) If possible, use whatever\n    facility the language has for optional parameters, and put\n    the extras there. (c) Rewrite all functions including combinators\n    as taking a stack (a list) as their sole parameter.\n  ")]),t("p",[e._v("\n    5. Some languages are strongly statically typed, perhaps\n    in a polymorphic way. Finite unions can then solve the\n    problem that combinators are supposed to take as parameters\n    functions of all sorts of base types but also lists of\n    these and lists of lists of base types and so on. But I don't\n    know whether this can handle lists of mixtures of lists of\n    mixtures when the entire mix is unknowable at compile time.\n  ")]),t("p",[e._v("\n    There are languages in which the Y or T combinators can \n    be defined, or at least collections of variants for different\n    number of parameters of the recursing function. Presumably\n    using similar techniques it is possible to define\n    in these languages counterparts\n    of the recursion combinators of Joy. But I have never seen\n    such definitions, and hence never their routine use.\n  ")]),t("h2",[e._v("6. Are there any higher order combinators ? ")]),t("p",[e._v("\n    Combinators take functions as parameters, so combinators are\n    second order functions. Are there any second order combinators,\n    functions which take first order combinators as parameters -\n    in other words third order functions? Are there any functions\n    that take as parameters functions which take as parameters functions?\n  ")]),t("p",[e._v("\n    The quick answer is NO, it stops at second order functions.\n  ")]),t("p",[e._v("\n    The more considered answer is that combinators do not take\n    functions as parameters but they take quoted programs as parameters.\n    It is indeed possible to write programs with combinators\n    which take quoted programs as parameters, where the quoted\n    program, when executed, will execute another combinator\n    taking as parameter another quoted program as parameter, and so on.\n    But such apparent higher order examples are just higher order\n    "),t("strong",[e._v("uses")]),e._v(" of the combinator, they are not examples\n    of higher order combinators.\n  ")]),t("p",[e._v("\n    The following are some examples, all involving the simple\n    i combinators. All just compute the same squaring function.\n    The examples are here grouped according whether the "),t("strong",[e._v("use")]),e._v("\n    of the right-most i combinator is first order, second order or\n    third order.\n  ")]),t("pre",[e._v("first order use          second order use         third order use\n    [dup *]       i\n   [[dup *] i]    i         [dup *]    [i] i              \n  [[[dup *] i] i] i        [[dup *] i] [i] i        [dup *] [i] [i] i       \n  ")]),t("p",[e._v("\n    A less contrived example is the following, used to compute the\n    list comprising the successor, the double and the square\n    of a given number, for example 7.\n  ")]),t("pre",[e._v("    7   [[succ] [2 *] [dup *]]   [i]   map     ==>     [8 14 49]\n  ")]),e._v("\n  The map combinator is mostly "),t("strong",[e._v("used")]),e._v(" with a quotation\n  parameter that computes a first order function, but as this\n  example shows, the quotation can also be a combinator.\n  As a final example, here is the ifte combinator used to\n  branch depending on whether the second item on the stack\n  is a leaf (not a list), or a list.\n  In the first case the top quotation will be called with\n  the i combinator, and in the second case with the map combinator:\n  "),t("pre",[e._v("        [pop leaf]  [i]  [map]  ifte\n  ")]),e._v("\n  No Joy example is known where a combinator can "),t("strong",[e._v("only")]),e._v("\n  be used with quoted combinators as parameters.\n  (This includes, for example, the operations in Church arithmetic.)\n  "),t("p",[e._v("\n    [MYNOTES: higher-order-combs continuations oo mess-pass lazy\n    need-stack why-postix reflective get-put-funct cat-theory]\n  ")])])}]};n.a=a}});