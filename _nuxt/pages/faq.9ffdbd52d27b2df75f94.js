webpackJsonp([21],{ADdD:function(e,n,t){(e.exports=t("FZ+f")(!1)).push([e.i,"main[data-v-52f8ff2d]{margin-top:25px;padding-left:12vw;padding-right:12vw}p[data-v-52f8ff2d]{margin-top:16px}h2[data-v-52f8ff2d]{margin-top:16px;margin-bottom:16px}pre[data-v-52f8ff2d]{margin:auto}code[data-v-52f8ff2d],pre[data-v-52f8ff2d]{font-family:Roboto Mono,monospace}",""])},NAEW:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a=t("eCIQ"),i=!1;var o=function(e){i||t("qvDp")},s=t("VU/8")(null,a.a,!1,o,"data-v-52f8ff2d",null);s.options.__file="pages/faq.vue",n.default=s.exports},eCIQ:function(e,n,t){"use strict";var a=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("main",[e._v("\n  Contents:\n  "),e._m(0),t("h2",[e._v('"What is a functional language ?"')]),e._v("\n  The programs of functional languages are expressions, and\n  computation proceeds by evaluating expressions.\n  Functional languages differ from mainstream imperative languages\n  (C, C++, Pascal, Ada) in one respect:\n  imperative languages have assignment statements,\n  which are commands to change the state, a collection\n  of assignable variables.\n  Functional languages have no state and hence no assignment statements.\n  "),t("p",[e._v("\n    One of the simplest functional languages is the one we encountered\n    in primary school, the language of arithmetical expressions.\n    We learnt how to do evaluations such as the following:\n  ")]),t("pre",[e._v("   (2 + 3)  *  (7 - 4)\n         5     *  (7 - 4)\n         5     *     3\n         15\n  ")]),e._v("\n  Note that the evaluation steps in the second and third line\n  could have been interchanged or even done in parallel.\n  In contrast, in imperative languages it is not always possible\n  to execute assignment statements in arbitrary order.\n  "),t("p",[e._v("\n    Expressions need not be numerical, subexpressions can be of\n    different types, and the operations can be unary.\n    In the following the only operand is a list of numbers,\n    here writen inside square brackets.\n  ")]),t("pre",[e._v("(1)    square(  size(  rest( [11 22 33] ) ) )\n      square(  size(  [22 33]            ) )\n      square(  2                           )\n      4\n  ")]),e._v("\n  This will serve as the running example in most of the remaining\n  sections.\n  "),t("h2",[e._v('"What really is expression evaluation ?"')]),e._v("\n  In the previous section the first example was a numerical expression:"),t("br"),t("pre",[e._v("   (2 + 3)  *  (7 - 4)\n  ")]),e._v('\n  The whole expression, the two parenthesised subexpressions, the four\n  single digit numerals and the final two digit end result - all of them\n  denote numbers.\n  The three symbols "+", "*" and "-" are infix operators which denote binary\n  functions from two numbers to give a result number.\n  '),e._m(1),t("pre",[e._v("(1)    square(  size(  rest( [11 22 33] ) ) )\n  ")]),e._v('\n  the symbol "[11 22 33]" denotes\n  a list of three elements which happen to be numbers.\n  The symbol "rest" denotes a unary function from lists to lists,\n  the symbol "size" denotes a unary function from lists to numbers,\n  and "square" denotes a unary function from numbers to numbers.\n  '),t("p",[e._v("\n    In both examples all lines of the evaluation denote the same number,\n    the end results 15 and 4 respectively.\n    Alternatively we say that all lines have the same value.\n    So, single symbols denote all sorts of things, numbers, lists and\n    various functions.\n    Expressions always denote, or have, values.\n  ")]),t("p",[e._v("\n    Denotations and values are semantic notions, and so is evaluation,\n    the end result of the process of finding the value.\n    By that we mean finding an expression that does not contain function\n    or operator symbols, but has the same value.\n    Typically, though by no means always, the final expression is shorter\n    than the original.\n  ")]),t("p",[e._v("\n    The actual evaluation process, however, is purely syntactic,\n    it is just a matter of rewriting the given expression in accordance\n    with certain rules.\n    The rewriting rules are essentially derived from the semantics,\n    but using the rules is a purely syntactic process.\n    One can do it without knowing what the symbols mean,\n    even without understanding the difference between a symbol\n    and what it denotes.\n    Most of us understood the difference between a numeral and a number\n    only when we encountered notations to bases other than ten.\n    (I am told that one textbook says that computers use\n    hexadecimal numbers as addresses, which is nonsense.)\n  ")]),t("p",[e._v('\n    The difference between a symbol and what it denotes will become\n    important in what follows.\n    This is because in Joy many symbols look more or less familiar,\n    but there is an important difference between what they denote conventionally\n    and what they denote in Joy.\n    One can learn to program in Joy barely noticing the difference,\n    but there is a deep shift in denotation.\n    Some people might speak of a "paradigm shift",\n    but I would be reluctant to use the term here.\n  ')]),t("h2",[e._v('"What is an applicative functional language ?"')]),e._v('\n  All but the simplest functional languages at least internally use\n  a binary application operator which here will be written with an\n  explicit infix symbol "@".\n  An expression of the form "f @ x" is to be read as "the function f\n  applied to the argument x".\n  The value of that expression is exactly the same as the value of "f(x)".\n  The evaluation of the running example now looks like this:\n  '),t("pre",[e._v("(2)    square  @  (size  @  (rest  @  [11 22 33]) )\n      square  @  (size  @  [22 33]               )\n      square  @  2\n      4\n  ")]),t("p",[e._v('\n    Application is a second order function because one of its arguments,\n    the one written on the left, is itself a function.\n    The reason for hiding the explicit symbol "@" externally\n    is that it just adds to the syntactic complexity.\n    The reason for introducing application internaly will be explained\n    in Section 4.\n  ')]),t("p",[e._v("\n    The best known applicative functional languages are:\n  ")]),e._m(2),e._v("\n  Lisp, Scheme and ML are actually impure functional languages\n  because they have assignment statements.\n  "),t("h2",[e._v('"Do functional languages need function application ?"')]),e._v('\n  Because applicative functional languages have the higher order\n  application function, it is possible to define other higher order\n  functions.\n  One example is the composition function,\n  a binary operation on unary functions.\n  Notationally it is often written in infix,\n  using a small circle, or "o", or ".", as here.\n  The definition is\n  '),t("pre",[e._v("   (f . g)  @  x   ==   f  @  (g  @  x)\n  ")]),e._v('\n  Since the "f" and the "g" appear in the same order on the left\n  side as in the applicative expression on the right,\n  this is sometimes called "applictive order" notation for composition.\n  '),t("p",[e._v("\n    The functions in the running examples are all unary,\n    so it can be written in two ways:\n  ")]),t("pre",[e._v("   (square  .  (size  .  rest))   @   [11 22 33]\n      ((square  .  size)  .  rest)   @   [11 22 33]\n  ")]),e._v("\n  Function composition is in fact associative, and hence the two\n  have the same value. So the running example might as well be written\n  without the inner parentheses as\n  "),t("pre",[e._v("(3)    (square  .  size  .  rest)   @   [11 22 33]\n  ")]),e._v('\n  The change to function composition has eliminated the first two\n  occurrences of "@" in (2) of the previous section.\n  '),t("p",[e._v('\n    Application is not associative,\n    and apart from being a function it has no formal properties at all.\n    Could the last application "@" also be eliminated and turned into\n    composition?\n    Clearly not, because "[11 22 33]" does not denote a unary function.\n    Therefore it seems that functional languages need application.\n  ')]),t("h2",[e._v('"What might a compositional functional language be ?"')]),e._v('\n  Suppose the expression "[11 22 33]" could denote a unary function,\n  just as "square", "size" and "rest" do.\n  Then the running example  would be written\n  '),t("pre",[e._v("(4)    square  .  size  .  rest  .  [11 22 33]\n  ")]),e._v("\n  The entire composition would have to be applied to a suitable\n  suppressed argument.\n  "),t("p",[e._v('\n    One suitable argument is a stack which is initially empty.\n    Then "[11 22 33]" denotes not a list but a stack function which\n    pushes a list. Similarly "square", "size" and "rest" would denote\n    stack functions which replace the top element of the stack.\n    The previous result, "4", denotes not a number but a stack\n    function which pushes a number.\n    Then all five symbols denote unary functions from stacks to stacks.\n    What normally are binary operators "+" and "*" for addition and\n    multiplication now also denote unary stack functions,\n    they replace the top two elements of the stack by a single one.\n    The idea is simple enough, and it is one of the key features of Joy.\n  ')]),t("p",[e._v('\n    An alternative for function composition would use a reverse notation.\n    It is sometimes defined using an infix operator, say ";",\n    instead of the previous ".":\n  ')]),t("pre",[e._v("   (f ; g)  @  x   ==   g  @  (f  @  x)\n  ")]),e._v('\n  This is is known as "diagrammatic order" notation for composition.\n  Then the running example would be written\n  '),t("pre",[e._v("(5)    [11 22 33]  ;  rest  ;  size  ;  square\n  ")]),e._v("\n  One advantage of this notation is that the order in the notation\n  reflects the order of the execution.\n  "),e._m(3),t("h2",[e._v('"What is a concatenative functional language ?"')]),e._v("\n  An applicative functional language is based on the higher order\n  function of application.\n  A compositional functional language is based on the higher order\n  function of composition.\n  Either kind of language might have other kinds of higher order functions.\n  "),e._m(4),t("pre",[e._v("   [1 2 3]  map  square\n  ")]),e._v('\n  where "map" is an  infix operator just like ";".\n  Now "[1 2 3]" and "square" denote unary stack functions, and the two are\n  transformed by the higher order mapping function into another\n  unary stack function, the one denoted by "[1 4 9]".\n  '),t("p",[e._v('\n    With two distinct infix operators ";" and "map",\n    there arises the possibility of expressions containing both.\n    Typically it will be necessary to use parentheses too, as in\n    the following:\n  ')]),t("pre",[e._v(" ([1 2 3]  ;  rest)  map  square\n    ([1 2 3]  map  square)  ;  rest\n  ")]),e._v('\n  It so happens that the two expressions denote the same function,\n  the one denoted by "[4 9]".\n  '),t("p",[e._v('\n    Functional languages need the mapping function and several others,\n    especially a conditional, or "if-then-else" of some kind.\n    However, if a compositional language has no other function operator,\n    then there is no point in ever writing the ";".\n    The running example would now be written as\n  ')]),t("pre",[e._v("(6)    [11 22 33]   rest   size   square\n  ")]),e._v("\n  Now the concatenation of any consecutive two or three or all four\n  of the parts of (6) denote the composition of the stack functions\n  tht the parts denote.\n  This is a desirable consequence.\n  But it must not come at the price of not being able to express\n  other higher order functions such as the mapping function or\n  the conditional or the many others that a mature language needs.\n  The topic is resumed in section 10.\n  "),e._m(5),t("h2",[e._v('"Why distinguish between postfix and concatenative notation ?"')]),e._v("\n  The running example (6) looks just like postfix notation:\n  the operand is [11 22 33]  and there are three unary operators.\n  Similarly the first example in section 1 could be written\n  in postfix as\n  "),t("pre",[e._v("   2   3   +   4   7   -   *\n  ")]),e._v("\n  with four number operands and three binary operators.\n  Just as in the evaluation of the original infix expression,\n  the addition and the subtraction could be done in any order,\n  even simultaneously.\n  Just as in the original infix expression,\n  the whole expression, the two subexpressions, the four single\n  digit numerals - all of them denote numbers.\n  "),t("p",[e._v('\n    The expression is also correct concatenative notation\n    (though not in compositional languages that use ";").\n    So what is the difference?\n    Consider some consecutive parts such as\n  ')]),t("pre",[e._v(" + 3  +        +  4        3  +  4        7  -  *\n  ")]),e._v("\n  These do not denote numbers, they are not postfix expressions.\n  However, they are perfectly correct concatenative expressions,\n  each denoting, as always, unary functions from stacks to stacks.\n  "),e._m(6),t("pre",[e._v("(7)    [11 22 33]   rest   size   dup   *\n  ")]),e._v("\n  The duplication operator only makes sense in compositional\n  languages that use a stack (or perhaps something similar),\n  and hence also in concatenative languages.\n  Two others are for "),t("b",[e._v("pop")]),e._v("ping off the top element of the\n  stack and for "),t("b",[e._v("swap")]),e._v("ping the top two elements.\n  "),e._m(7),t("h2",[e._v('"What is an environment ?"')]),e._v("\n  The squaring function can be defined in just about any programming\n  language.\n  In infix notation the external definition might look similar to this:\n  "),t("pre",[e._v("   square(x)   ==   x  *  x\n  ")]),e._v("\n  Internally, and possibly externally too, the definition would be"),t("br"),t("pre",[e._v("   square   ==   Lx :  x * x\n  ")]),e._v('\n  where "Lx" is sometimes written "\\x" or "lambda x" or "fun x".\n  The expression on the right side of the definition then is to be read as\n  "the function of one argument x which yields the value x * x".\n  An expression like that is known as a '),t("b",[e._v("lambda abstraction")]),e._v(".\n  "),e._m(8),t("pre",[e._v("         square  @  2\n      (Lx : x * x)  @  2\n            2 * 2\n        4\n  ")]),e._v('\n  In the second line "square" is being replaced by its definition.\n  This sets up an environment in which x = 2,\n  in which the formal parameter x has been given the value of the\n  actual parameter 2.\n  An environment is a collection of associations of formal and actual\n  parameters.\n  In all but the simplest cases the environment will contain several such\n  associations.\n  In the third line this environment is used to replace the formal\n  parameter x by the actual parameter 2.\n  All this is completely hidden from the user when the\n  first style of definition is used.\n  '),t("p",[e._v("\n    The two operations of lambda abstraction and application are\n    complementary.\n    They form the heart of the lambda calculus which\n    underlies all the mainstream functional languages.\n  ")]),t("h2",[e._v('"Is an environment needed ?"')]),e._v("\n  The previous definitions of the squaring function\n  as a lambda abstraction might be written in postfix or concatenative\n  notation as\n  "),t("pre",[e._v("   square   ==   Lx :  x  x  *\n      square   ==   Ls :  x  dup  *\n  ")]),e._v('\n  For a compostional (and hence for concatenative) language\n  the right hand side has to be read as\n  "the stack function for stacks in which there is a top element x\n  and which for stacks without that top element yields the same\n  result as x dup *".\n  But one might also write without the explicit lambda abstraction as'),t("br"),t("pre",[e._v("   x  square   ==   x  x  *\n      x  square   ==   x  dup  *\n  ")]),t("p",[e._v('\n    In the last of these both sides start with the formal paramater x,\n    and otherwise there are no further occurrences of x on either side.\n    Would it be possible for the two occurrences on the left and right\n    to "cancel out", so to speak?\n    Yes indeed, and now the definition looks loke this:\n  ')]),t("pre",[e._v("   square   ==   dup  *\n  ")]),e._m(9),t("pre",[e._v("(8)    [11 22 33]   rest   size   square\n          [22 33]   size   square\n                 2   square\n                 2   dup   *\n                 2   2   *\n                 4\n  ")]),e._v("\n  Note how in line four the substitution of the right hand side of\n  the definition is a simple textual substitution.\n  "),e._m(10),t("h2",[e._v('"What about second order functions in a concatenative language ?"')]),e._v("\n  A concatenative language has an all but invisible second order\n  function of function composition.\n  In section 6 it was emphasised that there are many other second\n  order functions that have to be fitted into the concatenative model.\n  One of the second order functions mentioned there was the mapping function.\n  The list [1 2 3] can be mapped by the squaring function to yield the\n  list [1 4 9].\n  In concatenative syntax one can use either of these:\n  "),t("pre",[e._v("   [1 2 3]   [square]   map\n      [1 2 3]   [dup  *]   map\n  ")]),e._v('\n  Both lines are concatenations of three parts:\n  (a) "[1 2 3]" which denotes a stack function to push a list,\n  (b) "[square]" or "[dup *]" which denotes a stack function to\n  push a "quoted" program without executing it, and\n  (c) "map" which denotes a stack function to use the program\n  from (b) on each member of the list from (a) to produce a list\n  of the same size.\n  Note that the second version was obtained from the first by\n  simple textual substitution in accordance with the definition\n  of "square".\n  '),t("p",[e._v("\n    The map function in Joy does all the work of a second order function,\n    but actually it is a first order stack funnction like all others in Joy.\n    It expects a stack whose top two elements are a list and a quoted program\n    and it leaves behind a new list.\n    The program is protected from execution by being enclosed in\n    square brackets, and in this form it is called a quotation.\n  ")]),t("p",[e._v("\n    Because the mapping function is only first order,\n    it is possible to write\n  ")]),t("pre",[e._v(" [1 2 3]    [ [dup *] [dup dup * *] ]    [map]    map\n  ")]),e._v("\n  which leaves [ [1 4 9] [1 8 27] ] on top of the stack,\n  and below that the original [1 2 3].\n  "),t("p",[e._v('\n    Another common word for higher order function\n    is "combinator", but in Joy it is used for what are really\n    first order functions.\n    Apart from "map", Joy has a large number of combinators,\n    and in programming they are used more often that in other\n    languages.\n  ')]),t("h2",[e._v('"What is the difference between a list and a quotation ?"')]),e._v("\n  Lists and quotations use square brackets to enclose something -\n  or possibly nothing.\n  Isn't that confusing? \n  Would it not be better to use a different notation for the two?\n  "),t("p",[e._v("\n    Lists are passive data structures that can be manipulated\n    for eample by the rest operation.\n    There are quite a few other well known list manipulation\n    operations for building up lists, combining lists, and for\n    taking them apart.\n  ")]),t("p",[e._v("\n    Quotations are potentially active programs that can be passed\n    as parameters to be eventually activated by combinators such as map.\n    There are many other combinators in Joy.\n    Some of them are similar to well known counterparts\n    in other languages.\n    But many of them are unique to Joy and do not make much sense elsewhere.\n  ")]),t("p",[e._v("\n    So, why use the same notation for lists and quotations?\n    The reason is that fundamentally they really are the same.\n  ")]),e._m(11),t("pre",[e._v("   [1 2 3]   [4 5]   map\n  ")]),e._v("\n  The first list is used as the passive data structure,\n  and at the very least its size, 3, determines the size\n  of the result list of the program.\n  The second list is the quotation.\n  When activated by the map combinator three times,\n  it will ignore the three arguments 1 or 2 or 3,\n  and in each case simply push 4 and 5 on top.\n  Whatever is on top will be the element of the result list,\n  and that is the same on all three occasions.\n  So the result list is [5 5 5].\n  "),t("p",[e._v("\n    On the other hand, and more usefully,\n    any list processing operation can be used on quotations.\n    Consider\n  ")]),t("pre",[e._v("   [1 2 3]   [dup * dup *]   map\n  ")]),e._v("\n  which will compute the fourth powers of the elements of the list.\n  Removing the first two parts of the quotation first,\n  "),t("pre",[e._v("   [1 2 3]   [dup * dup *]   rest  rest  map\n  ")]),e._v("\n  will compute the second powers of the elements of the list.\n  "),t("p",[e._v("\n    Instead of taking a quotation apart, with the rest operation,\n    a more likely scenario is that a quotation is first constructed,\n    possibly in several steps, and then used by a combinator.\n    Many Joy programs do just that.\n  ")]),e._m(12),t("pre",[e._v(" [dup *]  map      [square]  map\n  ")]),e._v("\n  because the quotations compute the same function.\n  At the same time, of course,\n  "),t("pre",[e._v(" [dup *]  size     [square]  size\n  ")]),e._v("\n  give different results, 2 and 1, because as lists they are different.\n  "),t("p",[e._v("\n    So it is useful to speak of lists as passive data structures\n    and quotations as inactive programs that might be activated\n    by a combinator.\n  ")]),t("h2",[e._v('"So, what is Joy ?"')]),e._v("\n  What are the essentials of Joy?\n  "),e._m(13),t("p",[e._v("\n    Apart from what is in this FAQ, what else does Joy have?\n  ")]),e._m(14),t("p",[e._v("\n    How does one think about Joy programs?\n    There are three useful styles:\n  ")]),e._m(15),e._v("\n  The three explicit or conscious ways of thinking will,\n  after some exposure and experience,\n  merge into a single unified unconscious whole.\n  "),t("p",[e._v("\n    Any questions?\n  ")]),t("ul",[e._m(16),t("li",[e._v("\n      Maybe\n      "),t("nuxt-link",{attrs:{to:"faq-part-2"}},[e._v("\n        Further Frequently Asked Questions about Joy\n      ")]),t("br")],1)])])};a._withStripped=!0;var i={render:a,staticRenderFns:[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ol",[t("li",[e._v('"What is a functional language ?"')]),t("li",[e._v('"What really is expression evaluation ?"')]),t("li",[e._v('"What is an applicative functional language ?"')]),t("li",[e._v('"Do functional languages need function application ?"')]),t("li",[e._v('"What might a compositional functional language be ?"')]),t("li",[e._v('"What is a concatenative functional language ?"')]),t("li",[e._v('"Why distinguish between postfix and concatenative notation ?"')]),t("li",[e._v('"What is an environment ?"')]),t("li",[e._v('"Is an environment needed ?"')]),t("li",[e._v('"What about second order functions in a concatenative language ?"')]),t("li",[e._v('"What is the difference between a list and a quotation ?"')]),t("li",[e._v('"So, what is Joy ?"')]),t("li",[e._v('"Where can I find out more about Joy ?"')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("\n    In the second example:"),n("br")])},function(){var e=this.$createElement,n=this._self._c||e;return n("ul",[n("li",[this._v('Lisp and Scheme (dynamic typing, strict of "eager")')]),n("li",[this._v('ML (static typing, strict or "eager")')]),n("li",[this._v('Erlang (optional static typing, strict or "eager")')]),n("li",[this._v('Miranda and Haskell (static typing, nonstrict or "lazy")')])])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v('\n    Any functional language which completely replaces\n    application, by explicit or implicit "@",\n    by composition, with explicit or implicit "." or ";",\n    might be called a '),n("b",[this._v("compositional")]),this._v(" functional language.\n  ")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("\n    Here is an example: the squaring function can be "),n("b",[this._v("map")]),this._v("ped over the\n    elements of a list [1 2 3] to yield the result [1 4 9].\n    In a compositional language one might write\n  ")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("\n    A language in which the concatenation of programs denote\n    the composition of functions has been called a "),n("b",[this._v("concatenative")]),this._v("\n    language.\n    I first heard this terminology from Billy Tanksley.\n  ")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("\n    The difference between postfix notation and concatenative notation\n    becomes even more obvious in the following.\n    The square of a number is just the number multiplied with\n    a "),n("b",[this._v("dup")]),this._v('licate of itself.\n    Let "dup" denote a stack function which '),n("b",[this._v("dup")]),this._v("licates\n    the top element of the stack.\n    So the running example might be written as\n  ")])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("p",[e._v("\n    Postfix notation is used in some pocket calculators.\n    Concatenative notation is used in Forth, Postscript and Joy.\n    The unix utility "),t("b",[e._v("dc")]),e._v(" (which similates a "),t("b",[e._v("d")]),e._v("esk\n    "),t("b",[e._v("c")]),e._v("alculator) is often described as using postfix,\n    but the presence of a duplication operator d actually\n    makes it concatenative.\n    The two other stack manipulators are easily defined in "),t("b",[e._v("dc")]),e._v(".\n  ")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("\n    Such a definition would be used as in the evaluation"),n("br")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("\n    The full evaluation of the running example now looks like this:"),n("br")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("\n    The mainstream imperative languages have a "),n("b",[this._v("state")]),this._v(" of associations\n    between assignable variables and their current values.\n    The values are changed by assignments during the run of the\n    program.\n    These languages also have an environment of formal / actual\n    parameter associations that are set up by calls of defined\n    functions or procedures.\n    Purely functional languages have no state,\n    but at least the mainstream applicative functional languages\n    invariably have an environment.\n    Compositional functional languages and hence concatenative\n    functional languages have no state and need no environment.\n    The concatenative language Joy has neither.\n  ")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("\n    On the one hand consider the program"),n("br")])},function(){var e=this.$createElement,n=this._self._c||e;return n("p",[this._v("\n    The following two programs compute the same function:"),n("br")])},function(){var e=this.$createElement,n=this._self._c||e;return n("ol",[n("li",[this._v("Joy is a purely functional language, so there is no state\n      and hence no assignment.\n    ")]),n("li",[this._v("Joy programs denote unary functions from stacks to stacks.")]),n("li",[this._v("Joy uses concatenative notation, so the concatenation\n      of programs denotes the composition of the functions which the\n      programs denote.\n    ")]),n("li",[this._v("Definitions do not use formal parameters, so there is no\n      environment of associations.\n    ")]),n("li",[this._v("Combinators do the work of higher order functions,\n      they take quoted programs as parameters.\n    ")]),n("li",[this._v("Lists are a special case of quotations, and both can be\n      manipulated in the same way. So, as in Lisp, program = data.\n    ")])])},function(){var e=this.$createElement,n=this._self._c||e;return n("ol",[n("li",[this._v("Atomic data: logical values, characters, integers, floats,\n      files.\n    ")]),n("li",[this._v("Aggregate data: strings (of characters), sets of numbers (0...31),\n      Quotations or lists (of anything, even recursively)\n    ")]),n("li",[this._v("Operations on data elements, and polymorphic operations on aggregates.")]),n("li",[this._v("Many combinators, including some polymorphic ones for aggregates,\n      and many for common recursion patterns.\n    ")]),n("li",[this._v("Several standard libraries, with varying specialisation.")])])},function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ol",[t("li",[e._v("\n      Imperative: programs are commands to modify the stack.\n      "),t("ul",[t("li",[e._v('e.g. "5" means: push the number 5 !\n        ')]),t("li",[e._v('e.g. "+" means: add the top two numbers !\n        ')])])]),t("li",[e._v("\n      Semantic: programs denote unary functions from stacks to stacks.\n      "),t("ul",[t("li",[e._v('e.g. "5" denotes the functions which yields a new stack\n          with the number 5 on top.\n        ')]),t("li",[e._v('e.g. "+" denotes the function which yields a new stack\n          with the top two numbers replaced by their sum.\n        ')])])]),t("li",[e._v("\n      Syntactic: programs are mere text to be evaluated by rewriting.\n      "),t("ul",[t("li",[e._v('e.g. "5" can be only be part of an expression to be rewritten\n        ')]),t("li",[e._v('e.g. "+" is used in rewriting, so "5 3 +" is rewritten "8"\n        ')])])])])},function(){var e=this.$createElement,n=this._self._c||e;return n("li",[this._v("🡥 "),n("a",{attrs:{href:"http://www.cs.nott.ac.uk/~pszgmh//faq.html",target:"_blank"}},[this._v("\n      FAQ for comp.lang.functional")]),this._v(" Functional languages in general\n    ")])}]};n.a=i},qvDp:function(e,n,t){var a=t("ADdD");"string"==typeof a&&(a=[[e.i,a,""]]),a.locals&&(e.exports=a.locals);t("rjj0")("005f175e",a,!1,{sourceMap:!1})}});