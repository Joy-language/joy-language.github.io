webpackJsonp([9],{FruD:function(e,t,n){(e.exports=n("FZ+f")(!1)).push([e.i,"main[data-v-b86d256e]{margin-top:25px;padding-left:12vw;padding-right:12vw}p[data-v-b86d256e]{margin-top:16px}h2[data-v-b86d256e]{margin-top:16px;margin-bottom:16px}pre[data-v-b86d256e]{margin:auto}code[data-v-b86d256e],pre[data-v-b86d256e]{font-family:Roboto Mono,monospace}",""])},Gv36:function(e,t,n){var o=n("FruD");"string"==typeof o&&(o=[[e.i,o,""]]),o.locals&&(e.exports=o.locals);n("rjj0")("59b3c72e",o,!1,{sourceMap:!1})},Pa8b:function(e,t,n){"use strict";var o=function(){var e=this.$createElement;this._self._c;return this._m(0)};o._withStripped=!0;var a={render:o,staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("main",[n("title",[e._v("Overview of the language JOY")]),n("h1",[e._v("Overview of the language JOY")]),e._v("\n  Joy is a functional programming language which is significantly\n  different from other programming languages of that kind.  This paper\n  provides an overview of most of its practical and theoretical aspects.\n  "),n("p",[e._v("\n    To add two integers, say 2 and 3, and to write their sum, you type the\n    program\n  ")]),n("pre",[e._v("        2  3  +\n  ")]),e._v("\n  This is how it works internally: the first numeral causes the integer\n  2 to be pushed onto a stack.  The second numeral causes the integer 3\n  to be pushed on top of that.  Then the addition operator pops the two\n  integers off the stack and pushes their sum, 5.\n  The system reads inputs like the above and executes them when\n  they are terminated by a period "),n("code",[e._v('"."')]),e._v(", like this:\n  "),n("pre",[e._v("        2  3  + .\n  ")]),e._v("\n  In the default mode there is no need for an explicit output instruction,\n  so the numeral "),n("code",[e._v("5")]),e._v(" is now written to the output file which\n  normally is the screen. So, in the default mode the terminating\n  "),n("code",[e._v('"."')]),e._v(" may be taken to be an instruction to write the\n  top element of the stack. In what follows the terminating period will\n  not be shown any further.\n  "),n("p",[e._v("\n    To compute the square of an integer, it has to be multiplied by\n    itself.  To compute the square of the sum of two integers, the sum has\n    to be multiplied by itself.  Preferably this should be done without\n    computing the sum twice.\n    The following is a program to compute the square of the sum of 2 and 3:\n  ")]),n("pre",[e._v("        2  3  +  dup  *\n  ")]),e._v("\n  After the sum of 2 and 3 has been computed, the stack just contains\n  the integer 5.  The "),n("kbd",[e._v("dup")]),e._v(" operator then pushes another copy\n  of the 5 onto the stack.  Then the multiplication operator replaces\n  the two integers by their product, which is the square of 5.  The\n  square is then written out as 25.  Apart from the "),n("code",[e._v("dup")]),e._v("\n  operator there are several others for re-arranging the top of the\n  stack.  The "),n("kbd",[e._v("pop")]),e._v(" operator removes the top element, and the\n  "),n("kbd",[e._v("swap")]),e._v(" operator interchanges the top two elements.\n  "),n("p",[e._v("\n    A "),n("em",[e._v("list")]),e._v(" of integers is written inside square brackets.  Just\n    as integers can be added and otherwise manipulated, so lists can be\n    manipulated in various ways.  The following "),n("kbd",[e._v("concat")]),e._v("enates\n    two lists:\n  ")]),n("pre",[e._v("        [1 2 3]  [4 5 6 7]  concat\n  ")]),e._v("\n  The two lists are first pushed onto the stack.  Then the\n  "),n("code",[e._v("concat")]),e._v(" operator pops them off the stack and pushes the\n  list "),n("code",[e._v("[1 2 3 4 5 6 7]")]),e._v(" onto the stack.  There it may be\n  further manipulated or it may be written to the output file.\n  "),n("p",[e._v("\n    Joy makes extensive use of "),n("em",[e._v("combinator")]),e._v("s.  These are like\n    operators in that they expect something specific on top of the stack.\n    But unlike operators they execute what they find on top of the stack,\n    and this has to be the "),n("em",[e._v("quotation")]),e._v(" of a program, enclosed in\n    square brackets.  One of these is a combinator for "),n("kbd",[e._v("map")]),e._v("ping\n    elements of one list via a function to another list.  Consider the\n    program\n  ")]),n("pre",[e._v("        [1 2 3 4]  [dup *]  map\n  ")]),e._v("\n  It first pushes the list of integers and then the quoted program onto\n  the stack.  The "),n("code",[e._v("map")]),e._v(" combinator then removes the list and\n  the quotation and constructs another list by applying the program to\n  each member of the given list.  The result is the list "),n("code",[e._v("[1 4 9\n  16]")]),e._v(" which is left on top of the stack.\n  "),n("p",[e._v("\n    In "),n("em",[e._v("definition")]),e._v("s of new functions no formal parameters are\n    used, and hence there is no substitution of actual parameters for\n    formal parameters.  After the following definition\n  ")]),n("pre",[e._v("        square   ==   dup  *\n  ")]),e._v("\n  the symbol "),n("code",[e._v("square")]),e._v(" can be used in place of "),n("code",[e._v(" dup *\n  ")]),e._v(".\n  "),n("p",[e._v("\n    As in other programming languages, definitions may be recursive, for\n    example in the definition of the factorial function.  That definition\n    uses a certain recursive pattern that is useful elsewhere.  In Joy\n    there is a combinator for "),n("em",[e._v("primitive recursion")]),e._v(" which has this\n    pattern built in and thus avoids the need for a definition.  The\n    "),n("kbd",[e._v("primrec")]),e._v(" combinator expects two quoted programs in addition\n    to a data parameter.  For an integer data parameter it works like\n    this: If the data parameter is zero, then the first quotation has to\n    produce the value to be returned.  If the data parameter is positive\n    then the second has to combine the data parameter with the result of\n    applying the function to its predecessor.  For the factorial function\n    the required quoted programs are very simple:\n  ")]),n("pre",[e._v("        [1]  [*]  primrec\n  ")]),e._v("\n  computes the factorial recursively.  There is no need for any\n  definition.\n  For example, the following program computes the factorial of\n  "),n("code",[e._v("5")]),e._v(":\n  "),n("pre",[e._v("        5  [1]  [*]  primrec\n  ")]),e._v("\n  It first pushes the number "),n("code",[e._v("5")]),e._v(" and then it pushes the two\n  short quoted programs.  At this point the stack contains three\n  elements.  Then the "),n("code",[e._v("primrec")]),e._v(" combinator is executed.  It\n  pops the two quotations off the stack and saves them elsewhere.  Then\n  "),n("code",[e._v("primrec")]),e._v(" tests whether the top element on the stack\n  (initially the "),n("code",[e._v("5")]),e._v(") is equal to zero.  If it is, it pops it\n  off and executes one of the quotations, the "),n("code",[e._v("[1]")]),e._v(" which\n  leaves "),n("code",[e._v("1")]),e._v(" on the stack as the result.  Otherwise it pushes\n  a decremented copy of the top element and recurses. On the way back\n  from the recursion it uses the other quotation, "),n("code",[e._v("[*]")]),e._v(", to\n  multiply what is now a factorial on top of the stack by the second\n  element on the stack.  When all is done, the stack contains\n  "),n("code",[e._v("120")]),e._v(", the factorial of "),n("code",[e._v("5")]),e._v(".\n  "),n("p",[e._v("\n    As may be seen from this program, the usual branching of recursive\n    definitions is built into the combinator.  The "),n("code",[e._v("primrec")]),e._v("\n    combinator can be used with many other quotation parameters to compute\n    quite different functions.  It can also be used with data types other\n    than integers.\n    Joy has many more combinators which can be used to calculate many\n    functions without forcing the user to give recursive or non-recursive\n    definitions.  Some of the combinators are more data-specific than\n    "),n("code",[e._v("primrec")]),e._v(", and others are far more general.\n  ")]),n("p",[e._v("\n    Joy programs are built from smaller programs by just two operations:\n    "),n("em",[e._v("concatenation")]),e._v(" and "),n("em",[e._v("quotation")]),e._v(".\n    Concatenation is a binary operation, and since it is associative it is\n    best written in infix notation and hence no parentheses are required.\n    Since concatenation is the only binary operation of its kind, in Joy\n    it is best written without an explicit symbol.\n    Quotation is a unary operation which takes as its operand a program.\n    In Joy the quotation of a program is written by enclosing it in square\n    brackets.  Ultimately all programs are built from atomic programs\n    which do not have any parts.\n    The semantics of Joy has to explain what the atomic programs mean, how\n    the meaning of a concatenated program depends on the meaning of its\n    parts, and what the meaning of a quoted program is.  Moreover, it has\n    to explain under what conditions it is possible to replace a part by\n    an equivalent part while retaining the meaning of the whole program.\n  ")]),n("p",[e._v("\n    Joy programs denote functions which take one argument and yield one\n    value.  The argument and the value are "),n("em",[e._v("state")]),e._v("s consisting of\n    at least three components.  The principal component is a\n    "),n("em",[e._v("stack")]),e._v(", and the other components are not needed here.  Much of\n    the detail of the semantics of Joy depends on specific properties of\n    programs.  However, central to the semantics of Joy is the following:\n    The concatenation of two programs denotes\n    the composition of the functions denoted by the two programs.\n    Function composition is associative, and hence denotation maps the\n    associative syntactic operation of program concatenation onto the\n    associative semantic operation of function composition.  The quotation\n    of a program denotes a function which takes any state as argument and\n    yields as value the same state except that the quotation is pushed\n    onto the stack.\n    One part of a concatenation may be replaced by another part denoting\n    the same function while retaining the denotation of the whole\n    concatenation.\n    One quoted program may be replaced by another denoting the same\n    function only in a context where the quoted program will be dequoted\n    by being executed.  Such contexts are provided by the\n    "),n("em",[e._v("combinator")]),e._v("s of Joy.  These denote functions which behave like\n    higher order functions in other languages.\n  ")]),n("p",[e._v("\n    The above may be summarised as follows: Let "),n("code",[e._v("P")]),e._v(",\n    "),n("code",[e._v("Q1")]),e._v(", "),n("code",[e._v("Q2")]),e._v(" and "),n("code",[e._v("R")]),e._v(" be programs, and\n    let "),n("code",[e._v("C")]),e._v(" be a combinator.  Then this principle holds:\n  ")]),n("pre",[e._v("        IF          Q1      ==      Q2\n          THEN     P  Q1  R   ==   P  Q2  R\n          AND        [Q1] C   ==     [Q2] C\n  ")]),e._v("\n  The principle is the prime rule of inference for the "),n("em",[e._v("algebra of\n  Joy")]),e._v(" which deals with the equivalence of Joy programs, and hence\n  with the identity of functions denoted by such programs.  A few laws\n  in the algebra can be expressed without combinators, but most require\n  one or more combinators for their expression.\n  "),n("p",[e._v("\n    Joy programs denote functions which take "),n("em",[e._v("state")]),e._v("s as arguments\n    and as values.  Programs are built from atomic programs which also\n    denote functions which take states as arguments and as values.\n    The meaning of compound programs has to be given in terms of the\n    meanings of atomic programs.  It is useful to classify atomic programs\n    into categories depending on what kind of function they denote.  A\n    coarse classification distinguishes just three, called\n  ")]),n("ol",[n("li",[e._v("the "),n("em",[e._v("literal")]),e._v("s,\n    ")]),n("li",[e._v("the "),n("em",[e._v("operator")]),e._v("s and \n    ")]),n("li",[e._v("the "),n("em",[e._v("combinator")]),e._v("s.\n    ")])]),n("p",[e._v("\n    Firstly, the "),n("em",[e._v("literal")]),e._v(" atomic programs are those which look\n    like constants in conventional languages.  They comprise literal\n    numbers (or, more correctly, numerals) such as integers, and other\n    literals of type character, string, truth value and set.  Literals do\n    not denote numbers, characters, strings and so on, but they denote\n    functions which take one state as argument and yield as value another\n    state which is like the argument state except that the value of the\n    literal has been pushed onto the stack component.\n  ")]),n("p",[e._v("\n    Secondly, the "),n("em",[e._v("operator")]),e._v(" atoms are those which look like "),n("em",[e._v("\n    n")]),e._v("-ary operators in other languages.  They include the operations\n    such as for addition and the other arithmetical operations, and for\n    the various operations on other types.  Like all programs, operators\n    denote functions from states to states, but the functions are not\n    defined on all states.  An "),n("em",[e._v(" n")]),e._v("-ary operator (such as the\n    binary addition operator) denotes a function which is defined only on\n    states whose stack component has "),n("em",[e._v(" n")]),e._v(" items (such as two\n    integers) on top.\n    The function yields as value another state which is like the argument\n    state except that the "),n("em",[e._v(" n")]),e._v(" items on the stack have been\n    replaced by the result (such as the sum).\n    Also included as operators are those atoms denoting mere structural\n    functions of the stack component such as "),n("code",[e._v("dup")]),e._v(",\n    "),n("code",[e._v("swap")]),e._v(" and "),n("code",[e._v("pop")]),e._v(", and those that involve input\n    and output such as "),n("code",[e._v("get")]),e._v(" and "),n("code",[e._v("put")]),e._v(".\n  ")]),n("p",[e._v("\n    Thirdly, the "),n("em",[e._v("combinator")]),e._v(" atoms are like operators in that they\n    require the top of the stack to contain certain items.  But unlike\n    operators, they do not treat these items as passive data.  Instead\n    they execute these items - and hence those items must be quoted\n    programs.  So, combinators also denote functions which are defined\n    only on states having the appropriate number of quoted programs on top\n    of the stack.  They yield as values another state which depends on the\n    argument state, including the quoted programs, and on the combinator\n    itself.\n  ")]),n("p",[e._v("\n    Literals, operators and combinators can be concatenated to form\n    "),n("em",[e._v("program")]),e._v("s.  These may then be enclosed in square brackets to\n    form literal "),n("em",[e._v("quotation")]),e._v("s.  Such literals are not atomic, but\n    if they occur in a program they are treated just like other literals:\n    they cause the quoted program to be pushed onto the stack.  So,\n    literal quotations denote functions which take any stack as argument\n    and yield as value another stack which is like the argument stack\n    except that it has the quotation pushed on top.  Quotations on top of\n    the stack can be treated like other values, they can be manipulated,\n    taken apart and combined, but they can also be executed by\n    combinators.  If a quotation contains only literals, then it is a\n    "),n("em",[e._v("list")]),e._v(".  The component literals do not have to be of the same\n    type, and they may include further quotations.  If a list is executed\n    by a combinator, then its components are pushed onto the stack.\n  ")]),n("p",[e._v("\n    Concatenation of Joy programs denote the composition of the functions\n    which the concatenated parts denote.  Hence if "),n("code",[e._v(" Q1 ")]),e._v(" and\n    "),n("code",[e._v(" Q2 ")]),e._v(" are programs which denote the same function and\n    "),n("code",[e._v(" P ")]),e._v(" and "),n("code",[e._v(" R ")]),e._v(" are other programs, then the two\n    concatenations "),n("code",[e._v(" P Q1 R ")]),e._v(" and "),n("code",[e._v(" P Q2 R ")]),e._v(" also\n    denote the same function.  In other words, programs "),n("code",[e._v(" Q1 ")]),e._v("\n    and "),n("code",[e._v(" Q2 ")]),e._v(" can replace each other in concatenations.  This\n    can serve as a rule of inference for "),n("em",[e._v("rewriting")]),e._v(".\n    As premises one needs axioms such as in the first three lines below,\n    and definitions such as in the fourth line:\n  ")]),n("pre",[e._v("(+)                2  3  +   ==   5\n  (dup)              5  dup   ==   5  5\n  (*)                5  5  *   ==   25\n  (def square)       square  ==  dup *\n  ")]),e._v("\n  A derivation using the above axioms and the definition looks like this:\n  "),n("pre",[e._v("                   2  3  +  square\n             ==      5  square                               (+)\n             ==      5  dup  *                               (def square)\n             ==      5  5  *                                 (dup)\n             ==      25                                      (*)\n  ")]),e._v("\n  The comments in the right margin explain how a line was obtained from\n  the previous line.  The derivation shows that the expressions in the\n  first line and the last line denote the same function, or that the\n  function in the first line is identical with the function in the last\n  line.\n  "),n("p",[e._v("\n    Consider the following equations in infix notation:The first says that\n    multiplying a number "),n("code",[e._v("x")]),e._v(" by 2 gives the same result as\n    adding it to itself.  The second says that the "),n("kbd",[e._v("size")]),e._v(" of a\n    "),n("kbd",[e._v("reverse")]),e._v("d list is the same as the "),n("code",[e._v("size")]),e._v(" of the\n    original list.\n  ")]),n("pre",[e._v("        2 * x  =  x + x                 size(reverse(x))  =  size(x)\n  ")]),e._v("\n  In Joy the same equations would be written, "),n("em",[e._v(" without\n  variables")]),e._v(", like this:\n  "),n("pre",[e._v("        2  *   ==   dup  +              reverse  size   ==   size\n  ")]),n("p",[e._v("\n    Other equivalences express algebraic properties of various operations.\n    For example, the predecessor "),n("kbd",[e._v("pred")]),e._v(" of the successor\n    "),n("kbd",[e._v("succ")]),e._v(" of a number is just the number itself.  The\n    conjunction "),n("kbd",[e._v("and")]),e._v(" of a truth value with itself gives just the\n    truth value.  The less than relation "),n("code",[e._v("<")]),e._v(" is the converse of\n    the greater than relation "),n("code",[e._v(">")]),e._v(".  Inserting a number with\n    "),n("kbd",[e._v("cons")]),e._v(" into a list of numbers and then taking the\n    "),n("kbd",[e._v("sum")]),e._v(" of that gives the same result as first taking the sum\n    of the list and then adding the other number.\n    In conventional notation these are expressed by\n  ")]),n("pre",[e._v("        pred(succ(x))  =  x             x and x  =  x\n          x < y  =  y > x                 sum(cons(x,y))  =  x + sum(y)\n  ")]),e._v("\n  In Joy these are expressed "),n("em",[e._v(" without variables")]),n("pre",[e._v("        succ  pred   ==   id            dup  and   ==   id\n          <   ==   swap >                 cons  sum   ==   sum  +\n  ")]),e._v("\n  Some properties of operations have to be expressed by combinators.\n  One of these is the "),n("kbd",[e._v("dip")]),e._v(" combinator which expects a program\n  on top of the stack and below that another value.  It saves the value,\n  executes the program on the remainder of the stack and then restores\n  the saved value.\n  "),n("p",[e._v("\n    In the first example below, the "),n("code",[e._v("dip")]),e._v(" combinator is used to\n    express the associativity of addition.  Another combinator is the\n    "),n("kbd",[e._v("app2")]),e._v(" combinator which expects a program on top of the stack\n    and below that two values.  It applies the program to the two values.\n  ")]),n("p",[e._v("\n    In the second example below it expresses one of the De Morgan laws.\n    In the third example it expresses that the "),n("kbd",[e._v("size")]),e._v(" of two\n    lists "),n("kbd",[e._v("concat")]),e._v("enated is the sum of the "),n("code",[e._v("size")]),e._v("s of\n    the two concatenands.\n  ")]),n("p",[e._v("\n    The last example uses both combinators to express that multiplication\n    distributes (from the right) over addition.  (Note that the program\n    parameter for "),n("code",[e._v("app2")]),e._v(" is first constructed from the\n    multiplicand and "),n("code",[e._v("*")]),e._v(".)\n  ")]),n("pre",[e._v("        [+]  dip  +   ==   +  +\n          and  not   ==   [not]  app2  or\n          concat  size   ==   [size]  app2  +\n          [+]  dip  *   ==   [*]  cons  app2  +\n  ")]),n("p",[e._v("\n    A deep result in the theory of computability concerns the elimination\n    of recursive definitions.  To use the stock example, the\n    "),n("em",[e._v("factorial")]),e._v(" function can be "),n("em",[e._v(" defined")]),e._v(" recursively in\n    Joy by\n  ")]),n("pre",[e._v("        factorial  ==\n              [0 =] [pop 1] [dup 1 - factorial *] ifte\n  ")]),e._v("\n  The definition is then "),n("em",[e._v(" used")]),e._v(" in programs like this:\n  "),n("pre",[e._v("        5\n          factorial\n  ")]),e._v("\n  Because in Joy programs can be manipulated as data, the factorial\n  function can also be computed recursively without a recursive\n  definition, as follows:\n  "),n("pre",[e._v("        5\n          [ [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte ]\n          [dup cons] swap concat dup cons i\n  ")]),e._v('\n  The second line in this program does much the same as the body of the\n  definition of factorial, but it is a quoted program.  The third line\n  first transforms this into another longer quoted program which\n  performs "anonymous" recursion, and then the final '),n("kbd",[e._v("i")]),e._v("\n  combinator essentially dequotes this program causing its execution.\n  "),n("p",[e._v("\n    The third line implements Joy's counterpart of the "),n("em",[e._v("Y")]),e._v("\n    combinator of the lambda calculus.  Exactly the same line can be used\n    to cause anonymous recursion of other functions which are normally\n    defined recursively.\n  ")]),n("p",[e._v("\n    Joy has other combinators which make recursive execution of programs\n    more succinct.  (Of course it is also possible in Joy to compute the\n    factorial function more efficiently with iteration instead of\n    recursion.)\n  ")]),n("p",[e._v("\n    Since Joy is very different from familiar programming languages, it\n    takes a while to become used to writing programs in Joy.  One way to\n    start the learning process is by way of writing some simple generally\n    useful library programs.  In an implementation these may be part of an\n    actual library, or they may be built into the language.\n  ")]),n("p",[e._v("\n    Some general "),n("em",[e._v("utility program")]),e._v("s include operators for\n    manipulating the Joy stack just below the top element, further\n    operators for manipulating aggregate values, and a few output\n    programs.\n  ")]),n("p",[e._v("\n    Generally useful are the "),n("em",[e._v("stack type")]),e._v(" and the "),n("em",[e._v("queue\n    type")]),e._v(".  Values and operators of these two types are easily\n    implemented as Joy lists and list operators.\n  ")]),n("p",[e._v("\n    Another collection of useful operators take an aggregate as parameter\n    and produce a list of subaggregates.  These operators are\n    "),n("em",[e._v("polymorphic")]),e._v(" in the sense that the aggregate parameter can be\n    a (small) set, a string, or a list.  One such operator can take a set\n    as parameter and produces a list of its subsets.  All of these\n    operators are definable without recursion by using the\n    "),n("kbd",[e._v("linrec")]),e._v(" combinator.\n  ")]),n("p",[e._v("\n    Some "),n("em",[e._v("arithmetic operators")]),e._v(" are often used to illustrate\n    recursive definitions, although it is well known that iterative\n    execution is more efficient.  In particular the use of\n    "),n("em",[e._v("accumulating parameter")]),e._v("s can often replace recursion.  This is\n    easily done in Joy using various iteration combinators.\n  ")]),n("p",[e._v("\n    Values of "),n("em",[e._v("sequence type")]),e._v("s, such as strings and lists, can be\n    "),n("em",[e._v("sort")]),e._v("ed, and sorted sequences can be "),n("em",[e._v("merge")]),e._v("d.\n    Programs for doing this are easily written in Joy without recursive\n    definitions but using appropriate combinators instead.\n  ")]),n("p",[e._v("\n    Joy's inbuilt datatype of sets is implemented just as bitstrings, and\n    hence it is limited to small sets of small numbers.  The more useful\n    "),n("em",[e._v("big set type")]),e._v(", which allows large sets of elements of any\n    type, can be implemented in any language which has lists.  It is\n    simple to do in Joy, and the usual set-theoretic operations are easily\n    provided.  A similar implementation can be used for the "),n("em",[e._v("dictionary\n    type")]),e._v(", which uses lookup tables for finite functions.\n  ")]),n("p",[e._v("\n    Also useful is the "),n("em",[e._v("tree type")]),e._v(", of lists, or lists of lists, or\n    lists of lists of lists ...  of elements other than lists.\n  ")]),n("p",[e._v("\n    A "),n("em",[e._v("rewriting system")]),e._v(' consists of a set of syntactic rules for\n    performing replacements on certain suitable entities.  The best known\n    such system is the one we learnt at school for evaluating arithmetic\n    expressions.  Any programming language can be given a rewriting\n    system, but for Joy it is particularly simple.  The basic binary\n    rewriting relation will be written in infix notation as\n    "'),n("code",[e._v("->")]),e._v('", pronounced "can be rewritten as".  The following\n    are some sample rules for the '),n("code",[e._v("+")]),e._v(" and "),n("code",[e._v("<")]),e._v("\n    operators and for the "),n("kbd",[e._v("dip")]),e._v(" combinator.\n  ")]),n("pre",[e._v("        2  3  +   ->   5\n          2  3  <   ->   true\n          a  [P]  dip   ->   P  a\n  ")]),e._v("\n  In the last example, "),n("code",[e._v("P")]),e._v(" is any program and "),n("code",[e._v("a")]),e._v("\n  is any literal (such as a number) or a program whose net effect is to\n  push exactly one item onto the stack.  The rewriting relation is\n  extended to allow rewriting in appropriate contexts, further extended\n  to accomodate several rewriting steps, and finally extended to become\n  a congruence relation, an equivalence relation compatible with program\n  concatenation.  This congruence relation between programs is\n  essentially the same as the identity relation in the algebra of of\n  functions which the programs denote.  Although Joy functions take a\n  stack as argument and value, in the rewrite rules the stack is never\n  mentioned.\n  "),n("p",[e._v("\n    The following are rewriting rules for arithmetic expressions in four\n    different notations: infix, functional, prefix and postfix:\n  ")]),n("pre",[e._v("        2 + 3  ->  5                    +(2,3)  ->  5\n          + 2 3  ->  5                    2 3 +  ->  5\n  ")]),e._v("\n  In each case on the left the operands are "),n("code",[e._v("2")]),e._v(" and\n  "),n("code",[e._v("3")]),e._v(", and the operator or "),n("em",[e._v("constructor")]),e._v(" is\n  "),n("code",[e._v("+")]),e._v(", so they all refer to the same arithmetic term.  Since\n  Joy uses postfix notation, it might be thought that one should attempt\n  a term rewriting system with rules just like the second one in the\n  last line.  That would treat the short program "),n("code",[e._v("2 3 +")]),e._v(" as\n  being composed of two operands and an operator or constructor.  It\n  would also treat the gap between "),n("code",[e._v("2")]),e._v(" and "),n("code",[e._v("3")]),e._v(" as\n  quite different from the gap between "),n("code",[e._v("3")]),e._v(" and\n  "),n("code",[e._v("+")]),e._v(".  The difference would be explained away as a syntactic\n  coincidence due to the choice of notation.  Apart from "),n("code",[e._v("+")]),e._v("\n  there would be very many term constructors.\n  "),n("p",[e._v("\n    However, Joy has operators for manipulating the top few elements of\n    the stack, such as "),n("kbd",[e._v("swap")]),e._v(", "),n("kbd",[e._v("dup")]),e._v(" and "),n("kbd",[e._v("pop")]),e._v(".\n    These are also found in the language "),n("em",[e._v("Forth")]),e._v(".  These operators\n    take a stack as argument and yield a stack as value, and their\n    presence forces all other operators to be of the same type.  For\n    example, the following is a rewrite rule for "),n("kbd",[e._v("swap")]),e._v(":\n  ")]),n("pre",[e._v("        a  b  swap   ->   b  a\n  ")]),e._v("\n  Unlike Forth, Joy also has quotations and combinators.  These features\n  also force the conclusion that the appropriate rewriting system is a\n  string rewriting system.  Consider the following four programs:\n  "),n("pre",[e._v("        [2] [3 +] b                     [2] [3 +] concat i\n          [2 3] [+] b                     [2 3] [+] concat i\n  ")]),e._v("\n  They all eventually have to reduce to "),n("code",[e._v("5")]),e._v(", just like the\n  earlier Joy program "),n("code",[e._v("2 3 +")]),e._v(".  It suggests that in the\n  latter the gaps have to be treated in the same way, the program is a\n  concatenation of three atomic symbols, and it denotes the composition\n  of three functions.  So, at least for Joy programs without quotations\n  and combinators, the appropriate system is a string rewriting system.\n  Such a system is equivalent to a term rewriting system with a\n  "),n("em",[e._v("concatenation constructor")]),e._v(" for programs as the only\n  constructor.  To handle combinators, a "),n("em",[e._v("quotation constructor")]),e._v("\n  has to be introduced as a second constructor.\n  "),n("p",[e._v("\n    The best known functional languages are the "),n("em",[e._v("lambda calculus")]),e._v("\n    and, based on it, the programming languages LISP and its descendants.\n    All of them rely heavily on two operations, abstraction and\n    application, which are in some sense inverses of each other.\n    Abstraction binds free variables in an expression, and it yields a\n    function which is a first class value.\n  ")]),n("p",[e._v("\n    The bound variables are the formal parameters of the function, and,\n    importantly, they are named.  Application of an abstracted function to\n    some actual parameters can be understood as resulting in a\n    substitution of actual for formal parameters and then evaluation of\n    the modified expression.  More efficiently application can be\n    implemented using an "),n("em",[e._v("environment")]),e._v(" of name-value pairs.  The\n    lambda calculus does not need definitions, but all functional\n    programming languages allow them as a matter of convenience.\n    Definitions also use named formal parameters, and in applications\n    these have to be substituted or an environment has to be maintained.\n  ")]),n("p",[e._v("\n    Two other functional languages are the "),n("em",[e._v("combinatory logic")]),e._v(" of\n    Curry and the "),n("em",[e._v("FP")]),e._v(" language of Backus.\n    They are not based on the lambda calculus, they eliminate abstraction\n    completely and hence do not have to deal with substitution and\n    environments.  As a result these languages can be manipulated using\n    simple algebraic techniques.  But like the lambda calculus and the\n    languages derived from it, both are based on the application of\n    functions to arguments.  However, application does not have attractive\n    algebraic properties, and hence there is no theoretical reason for\n    preferring one concrete notation over another.  \n  ")]),n("p",[e._v("\n    The languages of "),n("em",[e._v("category")]),e._v(" theory comprises another group of\n    functional languages.  Whereas the other functional languages use\n    function application, these use function composition.  No high level\n    programming language has been based on this formalism, but it has been\n    used as a low level machine language as a target for compilation from\n    a (typed) lambda calculus source.  Joy is a high level programming\n    language which resembles the categorical languages more than it\n    resembles any of the other functional languages.\n  ")]),n("p",[e._v("\n    The prototype implementation is written in (K&R) C; it uses a\n    simple stop-copy heap management.\n  ")])])}]};t.a=a},"h/sc":function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=n("Pa8b"),a=!1;var i=function(e){a||n("Gv36")},s=n("VU/8")(null,o.a,!1,i,"data-v-b86d256e",null);s.options.__file="pages/overview-of-joy.vue",t.default=s.exports}});