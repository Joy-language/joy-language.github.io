webpackJsonp([16],{"31qd":function(e,t,n){(e.exports=n("FZ+f")(!1)).push([e.i,"p[data-v-72df85dd]{margin-top:16px;margin-bottom:16px}hr[data-v-72df85dd]{margin-bottom:16px}pre[data-v-72df85dd]{margin-bottom:auto}code[data-v-72df85dd],kbd[data-v-72df85dd],pre[data-v-72df85dd]{font-family:Roboto Mono,monospace}",""])},eSrG:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=n("yUy1"),a=!1;var r=function(e){a||n("w71R")},i=n("VU/8")(null,o.a,!1,r,"data-v-72df85dd",null);i.options.__file="pages/papers-on-joy/design-of-a-joy-interpreter-written-in-joy.vue",t.default=i.exports},w71R:function(e,t,n){var o=n("31qd");"string"==typeof o&&(o=[[e.i,o,""]]),o.locals&&(e.exports=o.locals);n("rjj0")("6cb0e0fd",o,!1,{sourceMap:!1})},yUy1:function(e,t,n){"use strict";var o=function(){var e=this.$createElement;this._self._c;return this._m(0)};o._withStripped=!0;var a={render:o,staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("article",[n("i",[e._v(" by Manfred von Thun")]),n("p",[e._v("\n    This short paper contains the design of a Joy interpreter written in Joy itself.\n  ")]),n("p",[e._v("\n    Let L1 and L2 be two languages. An interpreter for language L1 , written in language\n    L2 is a program P which takes as a parameter any program written in L1 and executes\n    it in the same way as a processor for L1 would have. If the two languages are the\n    same language L , such an interpreter is called "),n("em",[e._v("metacircular")]),e._v(". Languages\n    in which "),n("em",[e._v("program = data")]),e._v(" make it particularly easy to write an interpreter\n    in its own language. The best known example is the "),n("em",[e._v("Lisp")]),e._v(" interpreter "),n("code",[e._v("eval")]),e._v(".\n    A metacircular interpreter for Joy can also be written.\n  ")]),n("p",[e._v("\n    The remainder of this paper assumes some familiarity with Joy.\n  ")]),n("h1",[e._v(" A Joy interpreter written in Joy ")]),n("p",[e._v("\n    A Joy interpreter in Joy is a program which expects a quoted program on top of the\n    stack and executes it. The following is the design of Joy interpreter "),n("kbd",[e._v("joy")]),e._v("  written in Joy itself. The first version of the interpreter is merely a reminder\n    that Joy already has a combinator, the "),n("code",[e._v("i")]),e._v(" combinator, which removes\n    a program from the top of the stack and executes it.\n  ")]),n("pre",[e._v(" \n  joy  ==  i \n  ")]),n("p",[e._v("\n    The next version makes explicit the fact that Joy programs are sequences which are\n    executed by "),n("kbd",[e._v("step")]),e._v("ping through the members of the sequence. For each\n    member in the sequence an appropriate action is taken. The "),n("code",[e._v("step")]),e._v(" combinator\n    will indiscriminately leave literals, operators and combinators on top of the stack.\n    But any operators and combinators "),n("em",[e._v("on top of the stack")]),e._v(" cannot actually\n    be executed. However, their "),n("kbd",[e._v("unitlist")]),e._v(" can be executed by the "),n("kbd",[e._v("i")]),e._v("  combinator. So this is the next version of the interpreter:\n  ")]),n("pre",[e._v(" \n  joy  == \n          [ unitlist \n            i ] \n          step \n  ")]),n("p",[e._v("\n    The last interpreter does not actually "),n("em",[e._v("specify")]),e._v(" what is to be done what\n    a particular element of the sequence has appeared on top of the stack. A better\n    one should say things like this for the "),n("em",[e._v("operator")]),e._v("s:\n  ")]),n("pre",[e._v('If the top element is "+" \n      then pop off the "+" and add the two numbers below \n  If the top element is "rest" \n      then pop off the "rest" and take the rest of the aggregate below \n  ')]),e._v("\n  For the "),n("em",[e._v("literal")]),e._v("s it is even simpler:\n  "),n("pre",[e._v("If the top element is any number \n      then leave it there and do not do anything \n  If the top number is any list \n      then leave it there and do not do anything \n  ")]),e._v("\n  Essentially we need a way of examining what is on top of the stack and executing\n  the appropriate action. So in the previous version of the interpreter we must replace\n  the "),n("code",[e._v("unitlist")]),e._v(" by something more specific. It has to consist of several\n  cases, for the various literals, operators and combinators. The "),n("kbd",[e._v("opcase")]),e._v("operator\n  is suitable for just that. It expects any kind of item on top of the stack, and above\n  that a list of cases. Each case is a list consisting of a test item and a (possibly)\n  empty rest. The effect of the "),n("code",[e._v("opcase")]),e._v("operator is to remove the top item\n  and the list of cases, and to leave behind the rest of case for which the item matched\n  the test item. The last case in the list is the default, it does not have a test\n  item. The default is returned if there was no match. For the present design step\n  the default does nothing. The following is what has to replace the "),n("code",[e._v("unitlist")]),e._v("in the interpreter:\n  "),n("pre",[e._v(" \n        [ [ 0 ]                           (* sample number *) \n          [ [] ]                          (* sample list *) \n          [ + pop + ]                     (* addition operator *) \n          [ rest pop rest ]               (* rest operator *) \n          [ ] ]                           (* default, do nothing *) \n        opcase \n  ")]),e._v("\n  It is an easy matter to add the other cases for "),n("em",[e._v("literal")]),e._v("s. They have\n  to be treated just like numbers and list:\n  "),n("pre",[e._v(' \n          [ \'A ]                          (* sample character *) \n          [ true ]                        (* sample truth value *) \n          [ "" ]                          (* sample string *) \n          [ {} ]                          (* sample set *) \n  ')]),e._v("\n  Similarly, other operators have to be added such as\n  "),n("pre",[e._v(" \n          [ swap pop swap ]               (* swap operator *) \n          [ cons pop cons ]               (* cons operator *) \n  ")]),n("p",[e._v("\n    For the combinators it is tempting to treat them just like operators:\n  ")]),n("pre",[e._v(" \n          [ dip pop dip ]                 (* dip combinator - WRONG *) \n          [ map pop map ]                 (* map combinator - WRONG *) \n  ")]),e._v("\n  This will work correctly, but it just uses the Joy system\n  "),n("em",[e._v("inside")]),e._v(" the quoted program that is being called by\n  "),n("code",[e._v("i")]),e._v(" or "),n("code",[e._v("map")]),e._v(". Instead it should use the Joy-in-Joy interpreter\n  that we are writing. To achieve that effect, the program parameter "),n("code",[e._v("[P]")]),e._v("for the combinator has to be replaced by "),n("code",[e._v("[[P] joy]")]),e._v(". For "),n("code",[e._v("i")]),e._v(",\n  "),n("code",[e._v("dip")]),e._v(" and "),n("code",[e._v("map")]),e._v(" and other "),n("em",[e._v("unary combinator")]),e._v("s this is\n  quite easy: after the "),n("code",[e._v("pop")]),e._v(" execute "),n("code",[e._v("[joy] cons")]),e._v(". This gives\n  cases like the following:\n  "),n("pre",[e._v(" \n          [ i    pop [joy] cons  i   ]    (* i combinator *) \n          [ dip  pop [joy] cons  dip ]    (* dip combinator *) \n          [ map  pop [joy] cons  map ]    (* map combinator *) \n  ")]),e._v("\n  The case for the "),n("code",[e._v("i")]),e._v(" combinator is unnecessarily inefficient, it\n  could be optimised to\n  "),n("pre",[e._v(" \n          [ i    pop             joy ]    (* i combinator *) \n  ")]),e._v("\n  However, for uniformity this optimisation will not be used here.\n  "),n("p",[e._v("\n    So that we do not lose track, here is the interpreter as designed so far:\n  ")]),n("pre",[e._v(' \n  joy  ==                                 (* literals *) \n      [ [ [ 0    ] \n          [ []   ] \n          [ true ] \n          [ \'A   ] \n          [ ""   ] \n          [ {}   ] \n                                          (* operators *) \n          [ +             pop     +    ] \n          [ rest          pop     rest ] \n          [ dup           pop     dup  ] \n          [ swap          pop     swap ] \n          [ pop           pop     pop  ] \n          [ -             pop     -    ] \n          [ and           pop     and  ] \n          [ cons          pop     cons ] \n                                          (* unary combinators *) \n          [ i             pop [joy] cons    i      ] \n          [ dip           pop [joy] cons    dip    ] \n          [ map           pop [joy] cons    map    ] \n          [ filter        pop [joy] cons    filter ] \n          [ ] ]                           (* provisional default *) \n        opcase \n        i ] \n      step \n  ')]),n("p",[e._v("\n    The interpreter is getting close to its final shape now, but several things need\n    to be fixed. Obviously the "),n("em",[e._v("binary combinator")]),e._v("s have to be treated in\n    a way that is similar to the unary ones: The two program parameters "),n("code",[e._v("[P]")]),e._v("  and\n    "),n("code",[e._v("[Q]")]),e._v(" have to be replaced by "),n("code",[e._v("[[P] joy]")]),e._v(" and "),n("code",[e._v("[[Q] joy]")]),e._v(".\n    This is best done by using the "),n("kbd",[e._v("app2")]),e._v(" combinator as follows:\n  ")]),n("pre",[e._v(" \n          [[joy] cons]  app2 \n  ")]),e._v("\n  So for the binary combinators the cases look like this:\n  "),n("pre",[e._v(" \n                                          (* binary combinators *) \n          [ branch        pop [[joy] cons] app2   branch ] \n          [ cleave        pop [[joy] cons] app2   cleave ] \n  ")]),e._v("\n  For the "),n("em",[e._v("ternary combinator")]),e._v("s and "),n("em",[e._v("quaternary combinator")]),e._v("s the\n  pattern is much the same, there are now three or four program parameters that need\n  to be modified. This is easily done using the "),n("kbd",[e._v("app3")]),e._v("and "),n("kbd",[e._v("app4")]),e._v("combinators to effect the modification.\n  "),n("pre",[e._v(" \n                                          (* ternary combinators *) \n          [ ifte          pop [[joy] cons] app3   ifte ] \n                                          (* quaternary combinators *) \n          [ linrec        pop [[joy] cons] app4   linrec ] \n          [ binrec        pop [[joy] cons] app4   binrec ] \n  ")]),n("p",[e._v("\n    There are still two major amendments needed for the interpreter. The first concerns\n    user defined symbols as they might occur in the standard library, the personal\n    library or in the preamble to a particular run. All Joy symbols have an internal\n    tag, and the tags differ individually only for the operators and combinators. However,\n    "),n("em",[e._v("all")]),e._v(" numbers have the same internal tag,\n    "),n("em",[e._v("all")]),e._v(" characters have the same tag,\n    "),n("em",[e._v("all")]),e._v(" lists have the same tag and so on. Similarly "),n("em",[e._v("all")]),e._v(" defined\n    symbols have the same tag. The\n    "),n("code",[e._v("opcase")]),e._v(' operator looks at these tags, so all that is needed is one\n    new case for user defined symbols. Just as any number will do as the prototype\n    for numbers, so any user defined symbol will do as the prototype for defined symbols.\n    We might as well choose "joy". When a defined symbol has been encountered, it is\n    necessary to find its definition, which is the program that constitutes the body\n    of that definition. The '),n("kbd",[e._v("body")]),e._v(" operator will find that, it expects a user\n    defined symbol on top of the stack and returns the defining program in quoted form.\n    The Joy interpreter now has to execute this. But it is essential that the Joy interpreter\n    should execute inside that quotation. So it will not do to use the "),n("code",[e._v("i")]),e._v("  combinator, but the "),n("code",[e._v("joy")]),e._v(" interpreter itself has to be used. Hence the\n    case for user defined symbols is just\n  ")]),n("pre",[e._v(" \n          [ joy           body joy ] \n  ")]),e._v("\n  The single most common case will be the call of a defined atom rather than\n  an inbuilt one. To improve efficiency this case (with "),n("code",[e._v("joy")]),e._v(") is placed\n  to the front of the caselist.\n  "),n("p",[e._v("\n    It always possible that the interpreter is used for programs which contain operators\n    or combinators that are part of the language (not used defined) but have not been\n    given cases in the interpreter itself, either intentionally or through neglect.\n    The joy interpreter should be able to perform reasonably for those operators and\n    combinators. So this is where the default clause for the "),n("code",[e._v("opcase")]),e._v("  operator comes in handy. When none of the listed case apply, treat the symbol as\n    we did in the second version of the interpreter: take the "),n("code",[e._v("unitlist")]),e._v("  and use the "),n("code",[e._v("i")]),e._v(" combinator to execute that. Instead of using "),n("code",[e._v("unitlist")]),e._v("  it is better to use its definition "),n("code",[e._v("[] cons")]),e._v(". So the default clause\n    looks like this:\n  ")]),n("pre",[e._v(" \n          [               [] cons i ]     (* default *) \n  ")]),n("p",[e._v("\n    This completes the working design of the interpreter. The following is its structure\n    with the last two additions written out fully:\n  ")]),n("pre",[e._v(" \n  joy  == \n      [ [ [ joy           body joy ]      (* user defined *) \n          ...                             (* literals *) \n          ...                             (* operators *) \n          ...                             (* unary combinators *) \n          ...                             (* binary combinators *) \n          ...                             (* ternary combinators *) \n          ...                             (* quaternary combinators *) \n          [               [] cons i ] ]   (* default *) \n        opcase \n        i ] \n      step \n  ")]),n("p",[e._v("\n    Before we write out a more complete version of the interpreter, it is useful to make\n    a number of changes to the design.\n  ")]),n("p",[e._v("\n    Firstly, the cases for the combinators of various arities contain common code which\n    is repeated again and again. The interpreter becomes more readable if such instances\n    are factored out and defined separately. There are cases for unary, binary, ternary\n    and quaternary combinators, and for each of these the common code will be called\n    "),n("code",[e._v("cr1")]),e._v(", "),n("code",[e._v("cr2")]),e._v(", "),n("code",[e._v("cr3")]),e._v(" and "),n("code",[e._v("cr4")]),e._v(". For\n    uniformity the code for "),n("code",[e._v("cr1")]),e._v(" is assimilated to that of the others,\n    using "),n("kbd",[e._v("app1")]),e._v(". Since they are not likely to be wanted anywhere else, their\n    definitions are given inside a "),n("kbd",[e._v("HIDE")]),e._v(" declaration.\n  ")]),n("p",[e._v("\n    Secondly, it could be useful if the default case does its job not silently but traces\n    out each symbol that it hands over to the Joy system. Such symbols are "),n("code",[e._v("dup")]),e._v("licated\n    and then written out by "),n("kbd",[e._v("put")]),e._v(". This now makes the default case\n  ")]),n("pre",[e._v(" \n          [               dup put [] cons i ] \n  ")]),n("p",[e._v("\n    The interpreter "),n("kbd",[e._v("joy")]),e._v(" now looks like this:\n  ")]),n("pre",[e._v(" \n  HIDE \n    cr1  ==  pop [[joy] cons] app1; \n    cr2  ==  pop [[joy] cons] app2; \n    cr3  ==  pop [[joy] cons] app3; \n    cr4  ==  pop [[joy] cons] app4 \n  IN \n    joy  == \n      [ [ [ joy           body    joy       ] \n          [ []                              ] \n          [ 0                               ] \n          ... \n          [ dup           pop     dup       ] \n          [ +             pop     +         ] \n          [ cons          pop     cons      ] \n          [ put           pop     put       ] \n          ... \n          [ i             cr1     i         ] \n          [ dip           cr1     dip       ] \n          [ map           cr1     map       ] \n          [ filter        cr1     filter    ] \n          [ app1          cr1     app1      ] \n          [ app2          cr1     app2      ] \n          ... \n          [ ifte          cr3     ifte      ] \n          [ linrec        cr4     linrec    ] \n          [ binrec        cr4     binrec    ] \n          ... \n          [               dup put [] cons i ] ] \n        opcase \n        i ] \n      step \n  END \n  ")]),n("p",[e._v("\n    The interpreter has appropriate cases for all literals and for quite a few operators\n    and combinators. Most operators and combinators are still missing and will therefore\n    be handled by the default clause. However, it is straightforward to make the interpreter\n    more comprehensive and even complete.\n  ")]),n("p",[e._v("\n    It is of some interest to write an interpreter that is just adequate to interpret\n    itself and leaves everything else to the default clause. The following is the minimal\n    Joy interpreter "),n("kbd",[e._v("joy0")]),e._v("; for variety it uses the optimisation for the\n    "),n("code",[e._v("i")]),e._v(" combinator mentioned earlier.\n  ")]),n("pre",[e._v(" \n  joy0  == \n      [ [ [ joy0          body            joy0     ] \n          [ []                                     ] \n          [ pop           pop             pop      ] \n          [ cons          pop             cons     ] \n          [ opcase        pop             opcase   ] \n          [ body          pop             body     ] \n          [ i             pop             joy0     ] \n          [ step          pop [joy0] cons step     ] \n          [               [] cons         i        ] ] \n        opcase \n        i ] \n      step \n  ")]),n("p",[e._v("\n    The two versions "),n("kbd",[e._v("joy")]),e._v(" and "),n("kbd",[e._v("joy0")]),e._v(" are in the file\n    "),n("a",{attrs:{href:"jp-joyjoy.joy"}},[e._v(" Joy in Joy ")]),e._v(".\n  ")])])}]};t.a=a}});