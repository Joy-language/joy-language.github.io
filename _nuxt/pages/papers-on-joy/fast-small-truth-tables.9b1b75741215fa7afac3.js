webpackJsonp([11],{"4Mod":function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=t("WEEP"),i=!1;var a=function(n){i||t("Hidn")},s=t("VU/8")(null,o.a,!1,a,"data-v-86a4601c",null);s.options.__file="pages/papers-on-joy/fast-small-truth-tables.vue",e.default=s.exports},Hidn:function(n,e,t){var o=t("SWsH");"string"==typeof o&&(o=[[n.i,o,""]]),o.locals&&(n.exports=o.locals);t("rjj0")("070b65ba",o,!1,{sourceMap:!1})},SWsH:function(n,e,t){(n.exports=t("FZ+f")(!1)).push([n.i,"p[data-v-86a4601c]{margin-top:16px;margin-bottom:16px}hr[data-v-86a4601c]{margin-bottom:16px}pre[data-v-86a4601c]{margin-bottom:auto}code[data-v-86a4601c],kbd[data-v-86a4601c],pre[data-v-86a4601c]{font-family:Roboto Mono,monospace}",""])},WEEP:function(n,e,t){"use strict";var o=function(){var n=this.$createElement;this._self._c;return this._m(0)};o._withStripped=!0;var i={render:o,staticRenderFns:[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("article",[t("p",[t("em",[n._v("Abstract")]),n._v(": This note describes how small Joy sets (of up to 32 members)\n    can be used to encode the lines in a truth table for up to five propositions. This\n    results in a surprisingly simple method of providing truth table tests for the\n    modal status of formulas (or other modal predicates).\n  ")]),t("p",[n._v("\n    Contents:\n  ")]),t("ul",[t("li",[t("a",{attrs:{href:"#TOC-1"}},[n._v("Truthfunctional and set-theoretic operations")])]),t("li",[t("a",{attrs:{href:"#TOC-2"}},[n._v("Set operations in Joy")])]),t("li",[t("a",{attrs:{href:"#TOC-3"}},[n._v("Truth tables for Joy postfix formulas")])]),t("li",[t("a",{attrs:{href:"#TOC-4"}},[n._v("Using minimally parenthesised infix notation")])]),t("li",[t("a",{attrs:{href:"#TOC-5"}},[n._v("Using Cambridge notation")])]),t("li",[t("a",{attrs:{href:"#TOC-6"}},[n._v("Other applications")])])]),t("a",{attrs:{name:"TOC-1"}},[t("h2",[n._v("Truthfunctional and set-theoretic operations")])]),t("p",[n._v("\n    Truth tables are the simplest way to determine the modal status of a formula: if\n    it is true in all lines then it is a tautology, if it is false in all lines then\n    it is a contradiction, and if it is true in some lines and false in others then\n    it is contingent. The truthfunctional connectives are normally taken to operate\n    on the two truth values, true and false. There is an obvious relationship between\n    the connectives in a formula and the set of lines in the truth table in which the\n    formula is true: The set of lines in which the negation of a formula is true is\n    just the set-theoretic complement of the lines in which the formula itself is true,\n    the set of lines in which the conjunction of two formulas is true is just the set-theoretic\n    intersection of the lines in which both component formulas are true, and so on.\n  ")]),t("p",[n._v("\n    Hence, instead of evaluating a formula line by line in the truth table, one could\n    just use the set-theoretic operations to determine the set of lines in which the\n    formula is true. Whether this is efficient depends on the relative speed of the\n    truthfunctional (one-bit) operations and the set-theoretic (many-bit) operations.\n    Most computers now have word-wide Boolean operations and 32 or even more bits per\n    word. and So, set-theoretic operations on sets of up to 32 or even more members\n    are as efficient as are the truthfunctional operations. This can be exploited for\n    truth tables, and it has the potential of improving performance of small truth\n    tables by a factor of up to 32, and even higher for larger size words. With 32\n    bits per word, a single word can codify the set of lines of a truth table generated\n    by five propositions (2^5 = 32).\n  ")]),t("p",[n._v("\n    Of course nothing can escape the eventual exponential explosion. For six propositions\n    the truth table has 2^6 = 64 lines, and, as always, any additional proposition\n    doubles the size. So, a six proposition truth table would need to be encoded in\n    two words, and then it doubles. However, the 32-fold increase in speed will hold\n    no matter how many words are needed for the truth table. Moreover, computers with\n    64-bit words are already becoming more common, and 128-bit words are not far off.\n    Indeed, some machines alredy have 128-bit registers, and a few can operate on several\n    such registers in one cycle.\n  ")]),t("p",[n._v("\n    The rest of this note illustrates the general principle, using just one 32-bit word\n    per truth table, and hence is restricted to a maximum of 5 propositions per table.\n    "),t("a",{attrs:{name:"TOC-2"}})]),t("h2",[t("a",{attrs:{name:"TOC-2"}},[n._v("Set operations in Joy")])]),t("p",[n._v("\n    The language Joy has as small sets of (generallly 32) integers from 0 onwards (generally\n    up to 31). These integers can be taken to be the line numbers of a truth table,\n    starting with line number 0.\n  ")]),t("p",[n._v("\n    What is needed, for each atomic proposition, is the set of line numbers of the lines\n    in which that proposition is true. In the usual way of writing truth tables, these\n    are the five guide columns. In setlib.joy, the standard Joy libray for (small and\n    large) sets, there is a module ss for small (32-bit) sets which contains, among\n    others, just the right definitions for the current purpose. These definitions are\n    here reproduced for convenience:\n  ")]),t("pre",[n._v("    s1  == { 0  2  4  6  8 10 12 14 16 18 20 22 24 26 28 30 };\n      s2  == { 0  1  4  5  8  9 12 13 16 17 20 21 24 25 28 29 };\n      s4  == { 0  1  2  3  8  9 10 11 16 17 18 19 24 25 26 27 };\n      s8  == { 0  1  2  3  4  5  6  7  8 17 18 19 20 21 22 23 };\n      s16 == { 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 };\n  ")]),t("p",[n._v("\n    The names for these sets have been chosen because they are descriptive for general\n    use, but they are not customary in logic. Moreover, since these sets are defined\n    inside a module, they would have to be referenced as ss.s1, ss.s2, ss.s4 and so\n    on. But this is easily overcome by some definitions, chosing p, q, r and so on.\n    Also, it is necessary to load the setlib.joy library:\n  ")]),t("pre",[n._v('"setlib" libload.\n\n  DEFINE\n    p == ss.s1; q == ss.s2; r == ss.s4; s == ss.s8; t == ss.s16.\n  ')]),t("p",[n._v("\n    Joy has the Boolean operators 'and', 'or' and 'not', and they are defined for the\n    two Boolean types of truth values and (small) sets. So these three can already\n    be used for the operations on sets of lines.\n  ")]),t("p",[n._v("\n    But in logic one frequently uses material implication and material equivalence, and\n    these operations will be needed. In the definition below they have been chosen\n    as say, 'imp' and 'iff'. Also, a set of lines represents a tautology if and only\n    if it comprises all lines if and only if it is the universal set. In the definition\n    below the predicate 'tautology' is defined to be true if the complement of the\n    set is empty.\n  ")]),t("pre",[n._v("DEFINE\n    imp == [not] dip or;\n    iff == [imp] [swap imp] cleave and popd;\n    tautology == not null\n  END\n  ")]),t("a",{attrs:{name:"TOC-3"}},[t("h2",[n._v("Truth tables for Joy postfix formulas")])]),t("p",[n._v("\n    No further definitions are needed. The Joy interpreter can now read formulas in Joy\n    postfix notation and determine whether they are tautologies. It does so simply\n    by executing them and then use tre 'tautology' predicate to determine whether what\n    is on top of the stack is the unversal set.\n  ")]),t("pre",[n._v("p q imp p and  q  imp tautology.\n  true\n  p q imp q and  p  imp tautology.\n  false\n  p q or  p r imp  q s imp  and and   r s or   imp  tautology.\n  true\n  p q or  p r imp  q s imp  and and   r s and  imp  tautology.\n  false\n  ")]),t("p",[n._v("\n    A formula that is not a tautology is either contingent or it is a contradiction.\n    It might be useful to have two more predicates for this. But simpler still is to\n    have a function 'modality' which simply determines which of the three possibilities\n    obtains.\n  ")]),t("pre",[n._v('DEFINE\n    modality == \n    [ [ [null] "contradiction" ]\n      [ [not null] "tautology" ]\n      [ "contingent" ] ]\n    cond\n    popd\n  END\n  ')]),n._v("\n  The use of this predicate is illustrated by the following three similar looking\n  stock examples.\n  "),t("pre",[n._v('p p not and   modality.\n  "contradiction"\n  p q not and   modality.\n  "contingent"\n  p p not  or   modality.\n  "tautology"\n  ')]),n._v("\n  Here are some more examples:\n  "),t("br"),t("pre",[n._v('p q imp p and  q  imp modality.\n  "tautology"\n  p q imp p and  q  imp not  modality.\n  "contradiction"\n  p q imp q and  p  imp modality.\n  "contingent"\n  p q imp q and  p  imp not  modality.\n  "contingent"\n  p q imp  p not q imp  iff  modality.\n  "contingent"\n  p q imp  q not p not imp  iff  modality.\n  "tautology"\n  p q or  p r imp  q s imp  and and   r s or   imp  modality.\n  "tautology"\n  p q or  p r imp  q s imp  and and   r s or   imp  not  modality.\n  "contradiction"\n  p q or  p r imp  q s imp  and and   r s and  imp  modality.\n  "contingent"\n  p q or  p r imp  q s imp  and and   r s and  imp  not  modality.\n  "contingent"\n  ')]),t("a",{attrs:{name:"TOC-4"}},[t("h2",[n._v("Using minimally parenthesised infix notation")])]),t("p",[n._v("\n    Reverse Polish notation may be second nature to Joy programmers, but it is not to\n    logicians who would prefer a more familiar notation. The Joy system has a library\n    symlib.joy for symbolic manipulation. It includes many translators from various\n    notations to others. One familiar notation is infix, with precedences for the binary\n    operators to minimise the need for parentheses. The translating function to reverse\n    Polish is called Min2Rev. But the library has to loaded, and it needs to be told\n    which operators are to be used, and what their precedences are:\n  ")]),t("pre",[n._v('"symlib"  libload.\n\n  DEFINE\n    unops == [not];\n    bin3ops == [and];\n    bin2ops == [or];\n    bin1ops == [imp iff];\n  END\n  ')]),n._v("\n  In the following the first item is a Joy tree representing a formula in minimally\n  parenthesised infix notation. This is then translated into a quotation of the same\n  formula in Joy notation. The i combinator then executes the quotation, with the result\n  that the top of the stack is now the set of lines in the truth table in which that\n  formula is true. The tautology predicate then determines whether that set is the\n  set of all lines, just as before.\n  "),t("pre",[n._v("[ [p imp q] and p  imp  q ] Min2Rev i tautology.\n  true\n  [ [p imp q] and q  imp  p ] Min2Rev i tautology.\n  false\n  ")]),n._v("\n  But it is more convenient not to have to specify the translation operator\n  and the i combinator every time:\n  "),t("br"),t("pre",[n._v("DEFINE\n    Mtautology == Min2Rev i tautology;\n    Mmodality  == Min2Rev i modality\n  END\n  ")]),t("pre",[n._v('[ [p imp q] iff [not p or q] ]  Mtautology.\n  true\n  [ [p imp q] iff [not q or p] ]  Mtautology.\n  false\n  [ [p or q] and [p imp r] and [q imp s]  imp  [r or s] ]  Mmodality.\n  "tautology"\n  [ [p imp q] iff [q imp p] ]  Mmodality.\n  "contingent"\n\n  [ [ [p imp q] and [q imp r] and [r imp s] and [s imp t] ]\n    imp [p imp t] ]\n  Mmodality.\n  "tautology"\n\n  [ [[p imp q] and [q imp r] and [s imp r] and [s imp t]]\n    imp  [p imp t] ]\n  Mmodality.\n  "contingent"\n  ')]),t("a",{attrs:{name:"TOC-5"}},[t("h2",[n._v("Using Cambridge notation")])]),t("p",[n._v("\n    In the symlib.joy library there is also a translator from Cambridge (or Lisp) style\n    notation to Joy notation. The translator is called Cam2Rev, and it is useful to\n    define the following operators straight away:\n  ")]),t("pre",[n._v("DEFINE\n    Ctautology == Cam2Rev i tautology;\n    Cmodality  == Cam2Rev i modality\n  END\n  ")]),n._v("\n  Here are a few tests:\n  "),t("br"),t("pre",[n._v('[ iff [not [or p q]]  [and [not p] [not q]] ]  Ctautology.\n  true\n  [ imp [and [imp p q] [imp q r]]  [imp p r] ]  Cmodality.\n  "tautology"\n  [ imp [and [imp p q] [imp r q]]  [imp p r] ]  Cmodality.\n  "contingent"\n  ')]),t("a",{attrs:{name:"TOC-6"}},[t("h2",[n._v("Other applications")])]),t("p",[n._v("\n    Testing whether the modal status of a single formula is not the only thing one might\n    do. Another obvious application would be a fixed database as a premise, and then\n    several queries as conclusions to determine whether certain facts can be deduced\n    from the database. Not so obvious would be a reverse example, which tests, for\n    several inputs, whether a fixed conclusion follows - and even gives advice accordingly.\n  ")]),t("p",[n._v("\n    For the advice to be at all meaningful, the usual single letter atomic formulas are\n    not so intuitive. It is preferable to use multi-letter formulas, and their lines\n    in the truth table now have to be defined as before:\n  ")]),t("pre",[n._v("DEFINE \n\n    raining == ss.s1; windy == ss.s2; cold == ss.s4; \n    hot == ss.s8; humid == ss.s16; \n\n    badweather == \n      [ raining and windy  or  cold and windy  or \n        raining and cold  or  hot and  humid ] \n  END\n  ")]),n._v("\n  Since from inconsistent data anything follows, no advice should be given at\n  all and an appropriate warning should be supplied. Also, a warning should be given\n  if the information was not sufficient to give any kind of advice.\n  "),t("pre",[n._v('DEFINE\n    takeadvice == \n      Min2Rev i \n      [ null ] \n      [ "inconsistent data" ] \n      [ badweather Min2Rev i \n        [ [ [and null] "go out" ] \n          [ [imp not null] "stay home" ] \n          [ "insufficient data" ] ] \n        cond ] \n      ifte \n      popd \n  END \n  ')]),n._v("\n  Finally then, here is the glorious application:\n  "),t("br"),t("pre",[n._v('[ raining and not cold and not [humid or raining] ]    takeadvice. \n  "inconsistent data"\n  [ windy and hot and not [hot and not windy] and not raining ] takeadvice. \n  "insufficient data"\n  [ cold and windy ]            takeadvice. \n  "stay home"\n  [ not [windy or raining or humid] ]       takeadvice. \n  "go out"\n  ')])])}]};e.a=i}});