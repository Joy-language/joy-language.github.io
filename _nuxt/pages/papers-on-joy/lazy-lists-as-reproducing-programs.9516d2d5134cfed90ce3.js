webpackJsonp([26],{K18I:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t("iqqZ"),s=!1;var i=function(e){s||t("rmbb")},o=t("VU/8")(null,r.a,!1,i,"data-v-14d93a50",null);o.options.__file="pages/papers-on-joy/lazy-lists-as-reproducing-programs.vue",n.default=o.exports},iqqZ:function(e,n,t){"use strict";var r=function(){var e=this.$createElement;this._self._c;return this._m(0)};r._withStripped=!0;var s={render:r,staticRenderFns:[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("article",[t("p",[e._v("\n    By Manfred von Thun, 21-MAR-05\n  ")]),t("p",[t("b",[e._v("Abstract:")]),e._v("\n    A program is called reproducing if running it creates another program\n    which in turn is reproducing. The created program need not be identical\n    with the program that created it. A program is called self-reproducing\n    if running it creates another program identical to itself.\n    This note describes how reproducing\n    programs can be used to implement infinite or lazy lists, and\n    how they might be used for other tasks. Importantly, these programs\n    must not be self-reproducing.  \n  ")]),t("p",[t("em",[e._v("Contents:")]),t("br"),t("a",{attrs:{href:"#TOC-1"}},[e._v("Self-reproducing and reproducing programs")]),t("br"),t("a",{attrs:{href:"#TOC-2"}},[e._v("Streams or infinite lists or lazy lists")]),t("br"),t("a",{attrs:{href:"#TOC-3"}},[e._v("Conventional lazy lists in Joy")]),t("br"),t("a",{attrs:{href:"#TOC-4"}},[e._v("Reproducing programs as lazy lists in Joy")]),t("br"),t("a",{attrs:{href:"#TOC-5"}},[e._v("Other reproducing programs")]),t("br"),t("a",{attrs:{href:"#TOC-6"}},[e._v("Concluding remarks")]),t("br"),t("a",{attrs:{name:"TOC-1"}})]),t("h2",[t("a",{attrs:{name:"TOC-1"}},[e._v("Self-reproducing and reproducing programs")])]),t("p",[e._v('\n    In the programming world there has been a veritable industry for writing\n    what are called self-reproducing programs. These are program which, when\n    run, create a copy of themselves. Following terminology introduced by\n    Hofstadter (19XX), these programs are often called Quines. A web search\n    for "Quine" will find examples in many languages. Many of the examples are\n    quite complex because the implementation language is not very suitable for\n    the task. Other examples can be surprisingly compact. \n  ')]),t("p",[e._v("\n    In Joy a self-reproducing program is a quoted program [P] such that\n    executing it with the i-combinator produces that very same program: \n  ")]),t("pre",[e._v(" \n          [P] i  ==  [P]\n  ")]),e._v("\n  The simplest program that satisfies this equation is [[dup cons] dup\n  cons]. The Joy page "),t("a",{attrs:{href:"joy/j05cmp.html"}},[e._v("\n  Recursion Theory")]),e._v(" has some discussion of this program and its relation\n  to the y-combinator for recursion. Also included are two variant programs\n  which on each execution by i create a program that is different from the\n  one that created it: \n  "),t("pre",[e._v(" \n          [[false [not] infra dup rest cons] [not] infra dup rest cons]\n          [[0 [1 +] infra dup rest cons] [1 +] infra dup rest cons]\n  ")]),e._v("\n  On successive executions by i the first quoted program produces others in\n  which the initial false oscillates between true, false, true.., and the\n  second quoted program produces others in which the initial 0 is\n  incremented to 1, 2, 3.. for every execution. Programs like these are\n  reproducing but not self-reproducing. Examples in other languages abound. \n  "),t("p",[e._v("\n    The two Joy programs above are mere curiosities. But they suggest variants\n    which promise useful programming techniques. One such technique is for\n    implementing infinite lists or streams. A computer implementation must of\n    course use a finite representation, so their evaluation is demand driven\n    or lazy: expressions are only evaluated when their value is needed.\n    Consequently they are also known as lazy lists. The next section describes\n    a conventional approach to their implementation, and the one following\n    that gives a conventional implementation in Joy. Then there is a section\n    that uses reproducing programs for implementing lazy lists in Joy. The\n    final section outlines some other possible uses of reproducing programs\n    in Joy. \n    "),t("a",{attrs:{name:"TOC-2"}})]),t("h2",[t("a",{attrs:{name:"TOC-2"}},[e._v("Streams or infinite lists or lazy lists")])]),t("p",[e._v("\n    A list or vector or sequence is essentially a function which takes natural\n    numbers as arguments and returns some value which may be a number or\n    anything else. The function need not be defined for arguments, but if it\n    is defined for some number then it is also defined for all its\n    predecessors. So the function may be defined for all natural numbers and\n    hence is infinite, or it may be defined only for an initial segment and\n    hence be finite. If the function is defined nowhere, then the list is\n    empty. \n  ")]),t("p",[e._v("\n    Finite sequences are normally implemented extensionally: the names of the\n    members are given extensionally and in their order, and they constitute\n    the successive values of the function which the sequence implements. This\n    method is not possibble for infinite sequences, so they have to be\n    implemented intensionally: some program has to be provided that can be\n    used to compute the members. Of course that program has to be finite. \n  ")]),t("p",[e._v("\n    There are many useful operations on sequences, and for an implementationn\n    some of these have to be chosen as primitives. Unfortunately what is\n    efficient in one implementation tends to be inefficient in the other. If\n    the implementation uses arrays of consecutive memory locations, then\n    indexing is particularly efficient. If the implementation uses linked\n    structures, then the first and rest operations are particularly\n    effficient. \n  ")]),t("p",[e._v("\n    For infinite sequences a finite program or specification has to be found,\n    and the choice depends on which access requirements dominate. For\n    efficient random access the implementation must use an ordinary function,\n    defined for all natural numbers. But for efficient sequential access\n    another implementation recommends itself. This will be the case when the\n    function f(n+1) is most readily computed from g(f(n)), where g(x) is\n    particularly efficient to compute. For example, the powers of 2 (1 2 4 8\n    ..), the n-th can be doubled to give the next power, and the doubling\n    function is easier to compute than exponentiation.  Similarly, in the\n    sequence of primes (2 3 5 7 11 ..) the n-th can be used as a starting\n    point in searching for the next prime. An implementation should provide a\n    function to find the first of the sequence and a function to compute the\n    rest of the sequence. So between them the first and rest function\n    characterise the sequence. \n  ")]),t("p",[e._v("\n    The first element of the sequence can be given literally, just as in a\n    finite sequence. But the rest of the sequence is infinite, and hence has\n    to be given as a program. When that program is called it must compute the\n    rest of the original sequence, and that of course consists of its own\n    first element and a program to compute its ownn rest. The entire sequence\n    thus consists of a pair of two things: a literal first value, and a\n    program to compute the rest. \n  ")]),t("p",[e._v("\n    The pair is most conveniently constructed from the first value and the\n    next function. For the infinite list of all natural numbers these are 0\n    and the successor function, for the list of powers of two they are 1 and\n    the doubling function. To construct the pair one can use a program.\n    Friedman and Felleisen (1984, p 181) give a recursive Lisp program for\n    doing just this. \n    The program is called str-maker (for stream maker),\n    and the only other primitives needed are str-first and str-rest\n    for computing the first and the rest of a stream. \n    The next section describes an implementation\n    in Joy whose core is modelled on their Lisp \n    programs.\n    "),t("a",{attrs:{name:"TOC-3"}})]),t("h2",[t("a",{attrs:{name:"TOC-3"}},[e._v("Conventional lazy lists in Joy")])]),t("p",[e._v("\n    This section and the next consists of a run of Joy that has been\n    extensively commented. Note that several standard libraries are loaded.\n    The first part consists of the definitions of the three primitives needed\n    for building a stream, and for accessing its first an its rest. \n  ")]),t("pre",[e._v("  \n  JOY  -  compiled at 14:53:58 on Mar 14 2003 (NOBDW)\n  Copyright 2001 by Manfred von Thun\n  usrlib  is loaded\n  inilib  is loaded\n  numlib  is loaded\n  agglib  is loaded\n  seqlib  is loaded\n     \n    DEFINE \n        str-maker  ==  #  n [N]  =>  [n [N(n) [N] str-maker]] \n            dupd dup [i] dip \n            [str-maker] cons cons \n            [] cons cons; \n        str-first == first; \n        str-rest  == second i. \n  ")]),e._v("\n  Here follow definitions of several streams that will be used later. The\n  first three are streams of numbers, and the fourth is a reminder that the\n  elements of a stream do not have to be numbers. Also included are two of\n  the actual streams that have defined. Observe that in each case the stream\n  consists of two parts: a first value and a quotation for computing the\n  rest of the stream. Note also that the quotation recursively uses the\n  str-maker operator, but the recursive call only occurs when the quotation\n  is executed. \n  "),t("pre",[e._v("  \n   \n    DEFINE \n        str-ints == 0 [succ] str-maker; \n        str-pows == 1 [2 *] str-maker; \n        str-prim == 2 [succ [prime not] [succ] while] str-maker; \n        str-brak == [] [[] cons] str-maker. \n     \n    str-ints. \n  [0 [1 [succ] str-maker]]\n     \n    str-pows. \n  [1 [2 [2 *] str-maker]]\n  ")]),t("p",[e._v("\n    Here are a several definitions of operations on streams that will be used\n    later. The names correspond to similar list operations in Joy. \n    Note that the all are defined in terms of just the two primitives\n    str-first and str-rest, and otherwise plain Joy.\n  ")]),t("pre",[e._v(" \n    DEFINE \n        str-uncons ==  [str-first] [str-rest]  cleave; \n        str-third ==   str-rest str-rest str-rest str-first; \n        str-tenth ==  10 [str-rest] times str-first; \n        str-drop == [str-rest] times; \n        str-n-th == str-drop str-first; \n        str-take ==    #  S n  =>  [S1 S2 .. Sn] \n            [null] [pop pop []] [[str-uncons] dip pred] [cons] linrec. \n  ")]),e._v("\n  Finally, here are examples of these defined operations applied to several\n  of the streams.\n  "),t("pre",[e._v(" \n    str-brak. \n  [[] [[[]] [[] cons] str-maker]]\n    str-brak  str-third. \n  [[[[]]]]\n     \n    str-pows. \n  [1 [2 [2 *] str-maker]]\n    str-pows str-tenth. \n  1024\n     \n    str-ints 5 str-take. \n  [0 1 2 3 4]\n     \n    str-pows 10 str-take. \n  [1 2 4 8 16 32 64 128 256 512]\n     \n    str-prim 10 str-drop 10 str-take. \n  [31 37 41 43 47 53 59 61 67 71]\n  ")]),t("a",{attrs:{name:"TOC-4"}},[t("h2",[e._v("Reproducing programs as lazy lists in Joy")])]),t("p",[e._v("\n    This section is like the previous one, except that the lazy lists are\n    implemented as reproducing programs. Recall from the first section the\n    following reproducing Joy program: \n  ")]),t("pre",[e._v(" \n          [[0 [1 +] infra dup rest cons] infra dup rest cons]\n  ")]),e._v('\n  Since the combination "dup rest cons" occurs frequently,\n  it is convient to introduce an abbreviation "dureco".\n  This is the first definition below.\n  The other three definitions are the three primitives\n  for building a stream and for accessing its first and rest.\n  The prefix "rep-" is a reminder that in this implementation\n  a lazy list is a reproducing program - for the rest operator, to be precise.\n  '),t("pre",[e._v(" DEFINE \n        dureco == dup rest cons; \n        rep-maker == # n [N] => [[n [N] infra dureco] [N] infra dureco] \n            [infra dureco] cons cons  dureco; \n        rep-first == first first; \n        rep-rest  == i. \n  ")]),e._v('\n  Here follow definitions of the same streams as in the previous section.\n  Note that the definions are identical, except for the prefix "rep-"\n  instead of "str-". Two of the constructed streams are shown. Note in\n  particular that, in contrast to the corresponding definitions in the\n  previous section, they do not contain a recursive reference to the\n  operator rep-maker - this is due to the reproducing implementation. \n  '),t("pre",[e._v(" \n    DEFINE \n        rep-ints == 0 [succ] rep-maker; \n        rep-pows == 1 [2 *] rep-maker; \n        rep-prim == 2 [succ [prime not] [succ] while] rep-maker; \n        rep-brak == [] [[] cons] rep-maker. \n     \n    rep-ints. \n  [[0 [succ] infra dureco] [succ] infra dureco]\n     \n    rep-pows. \n  [[1 [2 *] infra dureco] [2 *] infra dureco]\n  ")]),t("p",[e._v("\n    As before, here are the definitions of some core operators\n    and some example applications.   \n  ")]),t("pre",[e._v(" \n    DEFINE \n        rep-uncons ==  [rep-first] [rep-rest]  cleave; \n        rep-third ==   rep-rest rep-rest rep-rest rep-first; \n        rep-tenth ==  10 [rep-rest] times rep-first; \n        rep-drop == [rep-rest] times; \n        rep-n-th == rep-drop rep-first; \n        rep-take ==    #  S n  =>  [S1 S2 .. Sn] \n            [null] [pop pop []] [[rep-uncons] dip pred] [cons] linrec. \n     \n    rep-brak. \n  [[[] [[] cons] infra dureco] [[] cons] infra dureco]\n    rep-brak  rep-third. \n  [[[[]]]]\n     \n    rep-pows. \n  [[1 [2 *] infra dureco] [2 *] infra dureco]\n    rep-pows rep-tenth. \n  1024\n     \n    rep-ints 5 rep-take. \n  [0 1 2 3 4]\n     \n    rep-pows 10 rep-take. \n  [1 2 4 8 16 32 64 128 256 512]\n     \n    rep-prim 10 rep-drop 10 rep-take. \n  [31 37 41 43 47 53 59 61 67 71]\n  ")]),e._v("\n  Finally, a reminder that the elements of a stream can be anything. So here\n  is a stream whose members are lists of two things: the ordinal number of\n  the member and, in this case, a power of two. Of course such a stream\n  could have been defined in the previous section. \n  "),t("pre",[e._v(" \n    DEFINE \n        rep-n-th-pow ==  [0 1] [[succ [2 *] dip] infra] rep-maker. \n     \n    rep-n-th-pow  10 rep-drop 5 rep-take. \n  [[10 1024] [11 2048] [12 4096] [13 8192] [14 16384]]\n  ")]),t("p",[e._v("\n    The output from this and the preceding section was produced\n    by running the input file\n    "),t("a",{attrs:{href:"joy/jp-reprodtst.joy"}},[e._v("jp-reprodtst.joy")]),e._v("\n    which produced the output file\n    "),t("a",{attrs:{href:"joy/jp-reprodtst.out"}},[e._v("jp-reprodtst.out")]),e._v(".\n  ")]),t("p",[e._v("\n    The implementation of lazy lists in this and the preceding section\n    is different from the quite large older Joy library for lazy lists:\n    "),t("a",{attrs:{href:"joy/lazlib.joy"}},[e._v("lazlib.joy")]),e._v('\n    ("lazy" infinite and finite lists) with\n    '),t("a",{attrs:{href:"joy/laztst.joy"}},[e._v("laztst.joy")]),e._v("\n    test file and\n    "),t("a",{attrs:{href:"joy/laztst.out"}},[e._v("laztst.out")]),e._v("\n    output.\n    This library also contains definitions of several useful\n    combinators, and the test file exercises them.\n    There is no reason why the implementation in the preceding\n    two sections could not be extended in a similar way.\n    "),t("a",{attrs:{name:"TOC-5"}})]),t("h2",[t("a",{attrs:{name:"TOC-5"}},[e._v("Other replicating programs")])]),t("p",[e._v("\n    Apart from the replicating lazy lists of the previous section,\n    there are other uses of replicating programs that deserve exploration.\n  ")]),t("p",[e._v("\n    The replicating lists of the previous two sections were all\n    based on a simple next function which uses the first element of the list\n    to determine the first element of the rest of the list.\n    This does not work well for some lists, for example the list\n    of all (natural) logarithms of the positive integers:\n    0, 0.693147, 1.09862, 1.38629, 1.60944, ... .\n    A program for this list is:\n  ")]),t("pre",[e._v("       [ [0 1 [pop succ dup log] infra durereco]\n              [pop succ dup log] infra durereco ]\n\n  ")]),e._v("\n  where durereco has been defined as: dup rest rest cons.\n  Then, as in the previous section, rep-first and rep-rest will find\n  the first element of the list and the rest of the list.\n  Such a list can be constructedd from three parameters, 1, [succ] and [log],\n  by a program similar to rep-maker but somewhat more complex.\n  A different set of parameters will then givve a different list which\n  is also not based on a next function of its members.\n  "),t("p",[e._v("\n    There are also variant styles of lazy lists. The first line\n    below is the style of the previous section. In the second line\n    the program consists of two quotations, in the third of a value\n    and above that two quotations. In all three n is a natural number,\n    the first of the list.\n  ")]),t("pre",[e._v(" \n  (1)       [[n  [succ] infra dup rest cons]  [succ] infra dup rest cons]\n  (2)        [n  [succ] infra dup rest     ] [[succ] infra dup rest     ]\n  (3)         n [[succ]  dip  dup          ] [[succ]  dip  dup          ]\n  ")]),e._v("\n  The rest of the list for styles (1) (2 (3) is formed by the i-combinator.\n  The first element of the list in style (1) is found by first first, as in\n  the previous section. In style (2) it is found by pop first, and in style\n  (3) by pop pop. So for finding the rest of the list style (3) is more efficient\n  than style (2), which is more efficient than style (1). But for other\n  manipulations the exact opposite is the case, especially for stack \n  manipulations.\n  "),t("p",[e._v("\n    In all the replicating programs so far the replication is, in a sense,\n    internal. Replication steps do not involve the stacck below the programs.\n    But this need not be so.\n  ")]),t("p",[e._v('\n    First, there are replicating programs which on every execution deposit\n    something on the stack below the replicating program. One way to do that\n    is to use the lists of the previous section. Assume such a list is on top\n    of the stack. To leave its first element and above that its rest on the stack,\n    do this: rep-uncons. Alternatively, to leave the first of the rest\n    and above that the rest, do this:\n    rep-rest dup rep-first swap.\n    But in neither of these does the replication and depositing occur just\n    by the i-combinator. To achieve this, the replicating program must do its\n    own depositing, and not rely on anything external. Here is an example,\n    it similates radioactivity or diffusion. The internal quantity,\n    1.0 at the start, is halved at every step and the other half "leaks out"\n    and is deposited on the stack below the replicating program.\n  ')]),t("pre",[e._v("      [ [1.0 [2 / dup] infra uncons dureco]\n             [2 / dup] infra uncons dureco ]\n  ")]),e._v("\n  Again, quotations of this kind can be constructed by a variant of rep-maker;\n  the quotation above would be constructed from the parameters 1.0 and [2 / dup].\n  "),t("p",[e._v("\n    Second, whereas the program above left something on the stack\n    after each replication, it is also possible to do the reverse:\n    to remove something from the stack from below the program\n    and incorporate what has been removed into the program.\n    Here are two  examples. The first is a numeric accumulator,\n    it starts with an internal state 0 which has a number from below\n    the stack added to it by every reproduction. The second is also\n    an accumulator, but it starts with an empty list which has an element\n    from below the quotation cons'ed into it by every reproduction.\n  ")]),t("pre",[e._v("      [ [0  cons [+]     infra dureco] cons [+]     infra dureco ]\n      [ [[] cons [swons] infra dureco] cons [swons] infra dureco ]\n  ")]),e._v("\n  Another variant of rep-maker could construct these, from\n  parameter 0 and [+], or [] and [swond], respectively.\n  "),t("p",[e._v("\n    Third, there are reproducing programs that change the stack\n    below and keep an internal count of how many times they have\n    been called. To start, here is a program which will square\n    what it finds below itself on the stack, but without such\n    a count:\n  ")]),t("pre",[e._v("      [ [[dup *] dip dup cons] [dup *] dip dup cons ]\n  ")]),e._v("\n  And the following reproducing program does the same, except that\n  it keeps an internal call-count of the number of times\n  that it has performed a squaring and a reproduction:\n  "),t("pre",[e._v("      [ [0 [succ] infra [dup *] dip dureco]\n           [succ] infra [dup *] dip dureco ]\n  ")]),e._v("\n  Again, a variant of rep-maker could construct such programs,\n  in this case from [dup *].\n  "),t("p",[e._v("\n    Fourthly, here is a reproducing program which picks up quotations\n    from below on the stack and executes them on its own internal stack\n    which starts off as []:\n  ")]),t("pre",[e._v("      [ [[] uncons [swap infra] dip cons dureco]\n            uncons [swap infra] dip cons dureco ]\n  ")]),e._v("\n  If we push two qutations, [dup *] and  then [2 3 +], then this program and finally do\n  i i, then the internal stack will be [25].\n  "),t("a",{attrs:{name:"TOC-6"}},[t("h2",[e._v("Concluding remarks")])]),t("p",[e._v('\n    Abelson and Sussman (1985 "SICP", pp 242-292),\n    in their wonderful early book on Scheme, have a large section\n    on streams, much of it general and independent of any implementation.\n    But they also give a particular implementation which uses two functions,\n    delay and force.\n    The delay funnction creates a thunk, a parameterless lambda expression,\n    which can be evaluated by the force function.\n    (Folklore has it that the name "thunk" derives from the noise\n    when such a beast is dropped onto the runtime stack.)\n    In their simplest form these correspond very roughly to what in\n    Joy would be creating a quotation and executing it by i.\n    In another version force is implemented as "call by need",\n    which is a simple example of "memoising optimisation".\n    Here force evaluates a delayed (unevaluated) expression the first\n    time it is needed, and simply returns that value on later occasions.\n    Eager (non-lazy) languages such as Scheme use call by value as the default,\n    and to implement a call by need version of force requires assignment.\n    This uses a variable "already evaluated" which becomes part of the\n    delayed expression.\n    Lazy languages such as Turner\'s KRC and Miranda, and their modern descendant\n    Haskell use graph rewriting as the implementation,\n    and consequently call by need is the default.\n  ')]),t("p",[e._v("\n    An implementation of call by need in Joy would require a new force combinator\n    which is like the i-combinator except that it also modifies the quotation\n    to contains just the single value which the execution of the quotation\n    left on top of the stack. Normally, but not necessarily, the quotation\n    would be the Joy equivalent of a thunk: its executionn does not access\n    the stack below. An interaction might look like this:\n  ")]),t("pre",[e._v(" \n          DEFINE  five == [2 3 +].\n\n          five.                    =>  [2 3 +]\n          five i.                  =>  5\n          five.                    =>  [2 3 +]   (* as before *)\n          five force.              =>  5         (* also changes quotation *)\n          five.                    =>  [5]       (* note change *)\n          five i.                  =>  5         (* of course *)\n          five force               =>  5         (* cannot simplify further *)\n          five.                    =>  [5]       (* first change is permanent *)\n\n  ")]),t("p",[e._v("\n    [Note to myself: \n    The force funnction must change the first element of the quotation,\n    not the list-node for the quotation.\n    Because in the current implementation of Joy definitions\n    are not gc'ed, this will not work if (1) the quotation is in a definition\n    AND (2) the result value (5 above) is a list or other quotation. So the\n    implementation of force must check that the result value is a number, char,\n    string, set or symbol. In a future implementation of Joy the symbol table\n    management for definitions needs to be changed so that definitions can be\n    gc'ed - at a cost of course. This would also be necessary if runtime changes\n    (assignments?) are being contemplated.]\n  ")]),t("p",[e._v("\n    References:\n  ")]),t("p",[e._v("\n    H. Abelson and G.J. Sussman with J. Sussman, 1985,\n    "),t("em",[e._v("Structure and Interpretation of Computer Programs")]),e._v(",\n    MIT Press, Chicago, Mass.\n  ")]),t("p",[e._v("\n    D.P. Friedman and M. Felleisen, 1984,\n    "),t("em",[e._v("The Little Lisper")]),e._v(", 2nd edn,\n    Science Research Associates, Chicago.\n  ")])])}]};n.a=s},q75Q:function(e,n,t){(e.exports=t("FZ+f")(!1)).push([e.i,"p[data-v-14d93a50]{margin-top:16px;margin-bottom:16px}hr[data-v-14d93a50]{margin-bottom:16px}pre[data-v-14d93a50]{margin-bottom:auto}code[data-v-14d93a50],kbd[data-v-14d93a50],pre[data-v-14d93a50]{font-family:Roboto Mono,monospace}",""])},rmbb:function(e,n,t){var r=t("q75Q");"string"==typeof r&&(r=[[e.i,r,""]]),r.locals&&(e.exports=r.locals);t("rjj0")("1e96b256",r,!1,{sourceMap:!1})}});