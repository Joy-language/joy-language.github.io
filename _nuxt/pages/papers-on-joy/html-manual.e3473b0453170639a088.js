webpackJsonp([24],{BCFa:function(e,t,d){"use strict";var n=function(){var e=this.$createElement;this._self._c;return this._m(0)};n._withStripped=!0;var s={render:n,staticRenderFns:[function(){var e=this,t=e.$createElement,d=e._self._c||t;return d("article",[e._v("\n  JOY - compiled at 16: 57: 51 on Mar 17 2003(BDW) Copyright 2001 by Manfred von Thun\n  "),d("title",[e._v(" The Joy Programming Language - By Manfred Von Thun ")]),d("dl",[e._v("\n    literal\n    "),d("dt",[e._v(" truth value type "),d("code",[e._v(" : ")]),e._v(" ->  B ")]),d("dd",[e._v(" The logical type, or the type of truth values\n      .It has just two literals: true and false.\n    ")]),d("dt",[e._v(" character type "),d("code",[e._v("      :  ")]),e._v(" ->\n      C\n    ")]),d("dd",[e._v(" The type of characters.Literals are written with a single quote.Examples: 'A '\n      7 '; and so on. Unix style\n      escapes are allowed.\n    ")]),d("dt",[e._v(" integer type "),d("code",[e._v("      :  ")]),e._v(" ->\n      I\n    ")]),d("dd",[e._v(" The type of negative, zero or positive integers.Literals are written in decimal notation.Examples:\n      -123 0\n      42.\n    ")]),d("dt",[e._v(" set type "),d("code",[e._v("      :  ")]),e._v(" -> {...\n      } \n    ")]),d("dd",[e._v(" The type of sets of small non - negative integers.The maximum is platform dependent,\n      typically the range is\n      0..31. Literals are written inside curly braces.Examples: {} {\n      0\n      } {\n      1 3 5\n      } {\n      19 18 17\n      }.\n    ")]),d("dt",[e._v(" string type "),d("code",[e._v("      :  ")]),e._v(' ->\n      "..." \n    ')]),d("dd",[e._v(' The type of strings of characters.Literals are written inside double quotes.Examples: ""\n      "A"\n      "hello world"\n      "123".Unix style escapes are accepted.\n    ')]),d("dt",[e._v(" list type "),d("code",[e._v("      :  ")]),e._v(" ->\n      [...] \n    ")]),d("dd",[e._v(" The type of lists of values of any type(including lists), or the type of quoted programs which may contain\n      operators or combinators.Literals of this type are written inside square brackets.Examples: [][3 512 - 7]\n      [john mary]['A '\n      C['B]] [dup *].\n    ")]),d("dt",[e._v(" float type "),d("code",[e._v("      :  ")]),e._v(" -> F ")]),d("dd",[e._v(" The type of floating - point numbers\n      .Literals of this type are written with embedded decimal points(like 1.2) and optional exponent specifiers(\n      like 1.5E2)\n    ")]),d("dt",[e._v(" file type "),d("code",[e._v("      :  ")]),e._v(" -> FILE:\n    ")]),d("dd",[e._v(" The type of references to open I / O streams, typically but not necessarily files.The only literals of this type are stdin,\n      stdout, and stderr.operand\n    ")]),d("dt",[e._v("false "),d("code",[e._v("      :  ")]),e._v(" -> false ")]),d("dd",[e._v(" Pushes the value false.\n    ")]),d("dt",[e._v("true "),d("code",[e._v("      :  ")]),e._v(" -> true ")]),d("dd",[e._v(" Pushes the value true.\n    ")]),d("dt",[e._v("maxint "),d("code",[e._v("      :  ")]),e._v(" -> maxint ")]),d("dd",[e._v(" Pushes largest integer(platform dependent)\n      .Typically it is 32 bits.\n    ")]),d("dt",[e._v("setsize "),d("code",[e._v("      :  ")]),e._v(" -> setsize ")]),d("dd",[e._v(" Pushes the maximum number of elements in\n      a set(platform dependent).Typically it is 32, and set members are in the range 0..31.\n    ")]),d("dt",[e._v("stack "),d("code",[e._v("      :  ")]),e._v(" ..X Y Z ->..X Y Z[Z Y X..] ")]),d("dd",[e._v(" Pushes the stack as a list\n      .\n    ")]),d("dt",[e._v("conts "),d("code",[e._v("      :  ")]),e._v(" ->\n      [\n      [P][Q]..\n      ] \n    ")]),d("dd",[e._v(" Pushes current continuations.Buggy, do not use.\n    ")]),d("dt",[e._v("autoput "),d("code",[e._v("      :  ")]),e._v(" - &\n      gt; I \n    ")]),d("dd",[e._v(" Pushes current value of flag\n      for automatic output, I = 0..2.\n    ")]),d("dt",[e._v("undeferror "),d("code",[e._v("      :  ")]),e._v(" -> I ")]),d("dd",[e._v(" Pushes current value of undefined -\n      is - error flag.\n    ")]),d("dt",[e._v("undefs "),d("code",[e._v("      :  ")]),e._v(" -> ")]),d("dd",[e._v(" Push a list of all undefined symbols in\n      the current symbol table.\n    ")]),d("dt",[e._v("echo "),d("code",[e._v("      :  ")]),e._v(" -> I ")]),d("dd",[e._v(" Pushes value of echo flag, I = 0..3.\n    ")]),d("dt",[e._v("clock "),d("code",[e._v("      :  ")]),e._v(" -> I ")]),d("dd",[e._v(" Pushes the integer value of current CPU usage in\n      hundreds of a second.\n    ")]),d("dt",[e._v("time "),d("code",[e._v("      :  ")]),e._v(" -> I ")]),d("dd",[e._v(" Pushes the current time( in seconds since the Epoch)\n      .\n    ")]),d("dt",[e._v("rand "),d("code",[e._v("      :  ")]),e._v(" -> I ")]),d("dd",[e._v(" I is a random integer.\n    ")]),d("dt",[e._v("stdin "),d("code",[e._v("      :  ")]),e._v(" -> S ")]),d("dd",[e._v(" Pushes the standard input stream.\n    ")]),d("dt",[e._v("stdout "),d("code",[e._v("      :  ")]),e._v(" -> S ")]),d("dd",[e._v(" Pushes the standard output stream.\n    ")]),d("dt",[e._v("stderr "),d("code",[e._v("      :  ")]),e._v(" -> S ")]),d("dd",[e._v(" Pushes the standard error stream.operator\n    ")]),d("dt",[e._v("id "),d("code",[e._v("      :  ")]),e._v(" -> ")]),d("dd",[e._v(" Identity\n      function, does nothing.Any program of the form P id Q is equivalent to just P Q.\n    ")]),d("dt",[e._v("dup "),d("code",[e._v("      :  ")]),e._v(" X -> X X ")]),d("dd",[e._v(" Pushes an extra copy of X onto stack.\n    ")]),d("dt",[e._v("swap "),d("code",[e._v("      :  ")]),e._v(" X Y -> Y X ")]),d("dd",[e._v(" Interchanges X and Y on top of the stack\n      .\n    ")]),d("dt",[e._v("rollup "),d("code",[e._v("      :  ")]),e._v(" X Y Z -> Z X Y ")]),d("dd",[e._v(" Moves X and Y up, moves Z down\n    ")]),d("dt",[e._v("rolldown "),d("code",[e._v("      :  ")]),e._v(" X Y Z -> Y Z X ")]),d("dd",[e._v(" Moves Y and Z down, moves X up\n    ")]),d("dt",[e._v("rotate "),d("code",[e._v("      :  ")]),e._v(" X Y Z -> Z Y X ")]),d("dd",[e._v(" Interchanges X and Z\n    ")]),d("dt",[e._v("popd "),d("code",[e._v("      :  ")]),e._v(" Y Z -> Z ")]),d("dd",[e._v(" As\n      if defined by: popd == [pop] dip\n    ")]),d("dt",[e._v("dupd "),d("code",[e._v("      :  ")]),e._v(" Y Z -> Y Y Z ")]),d("dd",[e._v(" As\n      if defined by: dupd == [dup] dip\n    ")]),d("dt",[e._v("swapd "),d("code",[e._v("      :  ")]),e._v(" X Y Z -> Y X Z ")]),d("dd",[e._v(" As\n      if defined by: swapd == [swap] dip\n    ")]),d("dt",[e._v("rollupd "),d("code",[e._v("      :  ")]),e._v(" X Y Z W -> Z X Y W ")]),d("dd",[e._v(" As\n      if defined by: rollupd == [rollup] dip\n    ")]),d("dt",[e._v("rolldownd "),d("code",[e._v("      :  ")]),e._v(" X Y Z W -> Y Z X W ")]),d("dd",[e._v(" As\n      if defined by: rolldownd == [rolldown] dip\n    ")]),d("dt",[e._v("rotated "),d("code",[e._v("      :  ")]),e._v(" X Y Z W -> Z Y X W ")]),d("dd",[e._v(" As\n      if defined by: rotated == [rotate] dip\n    ")]),d("dt",[e._v("pop "),d("code",[e._v("      :  ")]),e._v(" X -> ")]),d("dd",[e._v(" Removes X from top of the stack.\n    ")]),d("dt",[e._v("choice "),d("code",[e._v("      :  ")]),e._v(" B T F -> X ")]),d("dd",[e._v(" If B is true, then X = T\n      else X = F.\n    ")]),d("dt",[e._v("or "),d("code",[e._v("      :  ")]),e._v(" X Y -> Z ")]),d("dd",[e._v(" Z is the union of sets X and Y,\n      logical disjunction\n      for truth values.\n    ")]),d("dt",[e._v("xor "),d("code",[e._v("      :  ")]),e._v(" X Y -> Z ")]),d("dd",[e._v(" Z is the symmetric difference of sets X and Y,\n      logical exclusive disjunction\n      for truth values.\n    ")]),d("dt",[e._v("and "),d("code",[e._v("      :  ")]),e._v(" X Y -> Z ")]),d("dd",[e._v(" Z is the intersection of sets X and Y,\n      logical conjunction\n      for truth values.\n    ")]),d("dt",[e._v("not "),d("code",[e._v("      :  ")]),e._v(" X -> Y ")]),d("dd",[e._v(" Y is the complement of set X, logical negation\n      for truth values.\n    ")]),d("dt",[e._v("+ "),d("code",[e._v("      :  ")]),e._v(" M I -> N ")]),d("dd",[e._v(" Numeric N is the result of adding integer I to numeric M\n      .Also supports float.\n    ")]),d("dt",[e._v("- "),d("code",[e._v("      :  ")]),e._v(" M I -> N ")]),d("dd",[e._v(" Numeric N is the result of subtracting integer I from numeric M\n      .Also supports float.\n    ")]),d("dt",[e._v("* "),d("code",[e._v("      :  ")]),e._v(" I J -> K ")]),d("dd",[e._v(" Integer K is the product of integers I and J\n      .Also supports float.\n    ")]),d("dt",[e._v("/ "),d("code",[e._v(" : ")]),e._v(" I J  ->  K ")]),d("dd",[e._v(" Integer K is the(rounded) ratio of integers I and J\n      .Also supports float.\n    ")]),d("dt",[e._v("rem "),d("code",[e._v("      :  ")]),e._v(" I J -> K ")]),d("dd",[e._v(" Integer K is the remainder of dividing I by J\n      .Also supports float.\n    ")]),d("dt",[e._v("div "),d("code",[e._v("      :  ")]),e._v(" I J -> K L ")]),d("dd",[e._v(" Integers K and L are the quotient and remainder of dividing I by J\n      .\n    ")]),d("dt",[e._v("sign "),d("code",[e._v("      :  ")]),e._v(" N1 -> N2 ")]),d("dd",[e._v(" Integer N2 is the sign(-1 or 0 or +\n      1) of integer N1, or float N2 is the sign(-1.0 or 0.0 or 1.0) of float N1.\n    ")]),d("dt",[e._v("neg "),d("code",[e._v("      :  ")]),e._v(" I -> J ")]),d("dd",[e._v(" Integer J is the negative of integer I.Also supports float\n      .\n    ")]),d("dt",[e._v("ord "),d("code",[e._v("      :  ")]),e._v(" C -> I ")]),d("dd",[e._v(" Integer I is the Ascii value of character C(\n      or logical or integer).\n    ")]),d("dt",[e._v("chr "),d("code",[e._v("      :  ")]),e._v(" I -> C ")]),d("dd",[e._v(" C is the character whose Ascii value is integer I(\n      or logical or character).\n    ")]),d("dt",[e._v("abs "),d("code",[e._v("      :  ")]),e._v(" N1 -> N2 ")]),d("dd",[e._v(" Integer N2 is the absolute value(0, 1,\n      2..) of integer N1, or float N2 is the absolute value(0.0..) of float N1\n    ")]),d("dt",[e._v("acos "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the arc cosine of F.\n    ")]),d("dt",[e._v("asin "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the arc sine of F.\n    ")]),d("dt",[e._v("atan "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the arc tangent of F.\n    ")]),d("dt",[e._v("atan2 "),d("code",[e._v("      :  ")]),e._v(" F G -> H ")]),d("dd",[e._v(" H is the arc tangent of F / G.\n    ")]),d("dt",[e._v("ceil "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the float ceiling of F.\n    ")]),d("dt",[e._v("cos "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the cosine of F.\n    ")]),d("dt",[e._v("cosh "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the hyperbolic cosine of F.\n    ")]),d("dt",[e._v("exp "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is e(2.718281828...) raised to the Fth power\n      .\n    ")]),d("dt",[e._v("floor "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the floor of F.\n    ")]),d("dt",[e._v("frexp "),d("code",[e._v("      :  ")]),e._v(" F -> G I ")]),d("dd",[e._v(" G is the mantissa and I is the exponent of F\n      .Unless F = 0, 0.5 & lt; = abs(G) & lt; 1.0.\n    ")]),d("dt",[e._v("ldexp "),d("code",[e._v("      :  ")]),e._v(" F I -> G ")]),d("dd",[e._v(" G is F times 2 to the Ith power.\n    ")]),d("dt",[e._v("log "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the natural logarithm of F.\n    ")]),d("dt",[e._v("log10 "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the common logarithm of F.\n    ")]),d("dt",[e._v("modf "),d("code",[e._v("      :  ")]),e._v(" F -> G H ")]),d("dd",[e._v(" G is the fractional part and H is the integer part(\n      but expressed as a float) of F.\n    ")]),d("dt",[e._v("pow "),d("code",[e._v("      :  ")]),e._v(" F G -> H ")]),d("dd",[e._v(" H is F raised to the Gth power.\n    ")]),d("dt",[e._v("sin "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the sine of F.\n    ")]),d("dt",[e._v("sinh "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the hyperbolic sine of F.\n    ")]),d("dt",[e._v("sqrt "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the square root of F.\n    ")]),d("dt",[e._v("tan "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the tangent of F.\n    ")]),d("dt",[e._v("tanh "),d("code",[e._v("      :  ")]),e._v(" F -> G ")]),d("dd",[e._v(" G is the hyperbolic tangent of F.\n    ")]),d("dt",[e._v("trunc "),d("code",[e._v("      :  ")]),e._v(" F -> I ")]),d("dd",[e._v(" I is an integer equal to the float F truncated toward zero\n      .\n    ")]),d("dt",[e._v("localtime "),d("code",[e._v("      :  ")]),e._v(" I -> T ")]),d("dd",[e._v(" Converts a time I into a list T representing local time: [\n      year month day hour minute second isdst yearday weekday\n      ].Month is 1 = January...12 = December; isdst is a Boolean flagging daylight savings / summer time; weekday is 0 =\n      Monday...7 = Sunday.\n    ")]),d("dt",[e._v("gmtime "),d("code",[e._v("      :  ")]),e._v(" I -> T ")]),d("dd",[e._v(" Converts a time I into a list T representing universal time: [\n      year month day hour minute second isdst yearday\n      weekday\n      ].Month is 1 = January...12 = December; isdst is false; weekday is 0 = Monday...7 = Sunday.\n    ")]),d("dt",[e._v("mktime "),d("code",[e._v("      :  ")]),e._v(" T -> I ")]),d("dd",[e._v(" Converts a list T representing local time into a time I\n      .T is in the format generated by localtime.\n    ")]),d("dt",[e._v("strftime "),d("code",[e._v("      :  ")]),e._v(" T S1 -> S2 ")]),d("dd",[e._v(" Formats a list T in the format of localtime or gmtime using string S1 and pushes the result S2\n      .\n    ")]),d("dt",[e._v("strtol "),d("code",[e._v("      :  ")]),e._v(" S I -> J ")]),d("dd",[e._v(' String S is converted to the integer J using base I\n      .If I = 0, assumes base 10, but leading "0"\n      means base 8 and leading "0x"\n      means base 16.\n    ')]),d("dt",[e._v("strtod "),d("code",[e._v("      :  ")]),e._v(" S -> R ")]),d("dd",[e._v(" String S is converted to the float R\n      .\n    ")]),d("dt",[e._v("format "),d("code",[e._v("      :  ")]),e._v(" N C I J -> S ")]),d("dd",[e._v(" S is the formatted version of N in\n      mode C('d or '\n      i = decimal, 'o = octal, '\n      x or 'X = hex with lower or upper\n      case letters) with maximum width I and minimum width J.\n    ")]),d("dt",[e._v("formatf "),d("code",[e._v("      :  ")]),e._v(" F C I J -> S ")]),d("dd",[e._v(" S is the formatted version of F in\n      mode C('e or '\n      E = exponential, 'f = fractional, '\n      g or G = general with lower or upper\n      case letters) with maximum width I and precision J.\n    ")]),d("dt",[e._v("srand "),d("code",[e._v("      :  ")]),e._v(" I -> ")]),d("dd",[e._v(" Sets the random integer seed to integer I\n      .\n    ")]),d("dt",[e._v("pred "),d("code",[e._v("      :  ")]),e._v(" M -> N ")]),d("dd",[e._v(" Numeric N is the predecessor of numeric M\n      .\n    ")]),d("dt",[e._v("succ "),d("code",[e._v("      :  ")]),e._v(" M -> N ")]),d("dd",[e._v(" Numeric N is the successor of numeric M\n      .\n    ")]),d("dt",[e._v("max "),d("code",[e._v("      :  ")]),e._v(" N1 N2 -> N ")]),d("dd",[e._v(" N is the maximum of numeric values N1 and N2\n      .Also supports float.\n    ")]),d("dt",[e._v("min "),d("code",[e._v("      :  ")]),e._v(" N1 N2 -> N ")]),d("dd",[e._v(" N is the minimum of numeric values N1 and N2\n      .Also supports float.\n    ")]),d("dt",[e._v("fclose "),d("code",[e._v("      :  ")]),e._v(" S -> ")]),d("dd",[e._v(" Stream S is closed and removed from the stack\n      .\n    ")]),d("dt",[e._v("feof "),d("code",[e._v("      :  ")]),e._v(" S -> S B ")]),d("dd",[e._v(" B is the end - of - file status of stream S\n      .\n    ")]),d("dt",[e._v("ferror "),d("code",[e._v("      :  ")]),e._v(" S -> S B ")]),d("dd",[e._v(" B is the error status of stream S.\n    ")]),d("dt",[e._v("fflush "),d("code",[e._v("      :  ")]),e._v(" S -> S ")]),d("dd",[e._v(" Flush stream S, forcing all buffered output to be written\n      .\n    ")]),d("dt",[e._v("fgetch "),d("code",[e._v("      :  ")]),e._v(" S -> S C ")]),d("dd",[e._v(" C is the next available character from stream S\n      .\n    ")]),d("dt",[e._v("fgets "),d("code",[e._v("      :  ")]),e._v(" S -> S L ")]),d("dd",[e._v(" L is the next available line(as a string) from stream S\n      .\n    ")]),d("dt",[e._v("fopen "),d("code",[e._v("      :  ")]),e._v(" P M -> S ")]),d("dd",[e._v(" The file system object with pathname P is opened with mode M(\n      r, w, a, etc.) and stream object S is pushed;\n      if the open fails, file: NULL is pushed.\n    ")]),d("dt",[e._v("fread "),d("code",[e._v("      :  ")]),e._v(" S I -> S L ")]),d("dd",[e._v(" I bytes are read from the current position of stream S and returned as a list of I integers\n      .\n    ")]),d("dt",[e._v("fwrite "),d("code",[e._v("      :  ")]),e._v(" S L -> S ")]),d("dd",[e._v(" A list of integers are written as bytes to the current position of stream S\n      .\n    ")]),d("dt",[e._v("fremove "),d("code",[e._v("      :  ")]),e._v(" P -> B ")]),d("dd",[e._v(" The file system object with pathname P is removed from the file system\n      .is a boolean indicating success or failure.\n    ")]),d("dt",[e._v("frename "),d("code",[e._v("      :  ")]),e._v(" P1 P2 -> B ")]),d("dd",[e._v(" The file system object with pathname P1 is renamed to P2\n      .B is a boolean indicating success or failure.\n    ")]),d("dt",[e._v("fput "),d("code",[e._v("      :  ")]),e._v(" S X -> S ")]),d("dd",[e._v(" Writes X to stream S, pops X off stack\n      .\n    ")]),d("dt",[e._v("fputch "),d("code",[e._v("      :  ")]),e._v(" S C -> S ")]),d("dd",[e._v(" The character C is written to the current position of stream S\n      .\n    ")]),d("dt",[e._v("fputchars "),d("code",[e._v("      :  ")]),e._v(' S "abc.." -> S ')]),d("dd",[e._v(" The string abc..(no quotes) is written to the current position of stream S\n      .\n    ")]),d("dt",[e._v("fputstring "),d("code",[e._v("      :  ")]),e._v(' S "abc.." -> S ')]),d("dd",[e._v("= = fputchars, as a temporary alternative\n      .\n    ")]),d("dt",[e._v("fseek "),d("code",[e._v("      :  ")]),e._v(" S P W -> S ")]),d("dd",[e._v(" Stream S is repositioned to position P relative to whence -\n      point W, where W = 0, 1, 2\n      for beginning, current position, end respectively.\n    ")]),d("dt",[e._v("ftell "),d("code",[e._v("      :  ")]),e._v(" S -> S I ")]),d("dd",[e._v(" I is the current position of stream S\n      .\n    ")]),d("dt",[e._v("unstack "),d("code",[e._v("      :  ")]),e._v(" [X Y..] ->..Y X ")]),d("dd",[e._v(" The list[X Y..] becomes the new stack\n      .\n    ")]),d("dt",[e._v("cons "),d("code",[e._v("      :  ")]),e._v(" X A -> B ")]),d("dd",[e._v(" Aggregate B is A with a new member X(\n      first member\n      for sequences).\n    ")]),d("dt",[e._v("swons "),d("code",[e._v("      :  ")]),e._v(" A X -> B ")]),d("dd",[e._v(" Aggregate B is A with a new member X(\n      first member\n      for sequences).\n    ")]),d("dt",[e._v("first "),d("code",[e._v("      :  ")]),e._v(" A -> F ")]),d("dd",[e._v(" F is the first member of the non -\n      empty aggregate A.\n    ")]),d("dt",[e._v("rest "),d("code",[e._v("      :  ")]),e._v(" A -> R ")]),d("dd",[e._v(" R is the non - empty aggregate A with its first member removed\n      .\n    ")]),d("dt",[e._v("compare "),d("code",[e._v("      :  ")]),e._v(" A B -> I ")]),d("dd",[e._v(" I( = -1, 0, +1) is the comparison of aggregates A and B\n      .The values correspond to the predicates & lt; = , = , & gt; = .\n    ")]),d("dt",[e._v("at "),d("code",[e._v("      :  ")]),e._v(" A I -> X ")]),d("dd",[e._v(" X( = A[I]) is the member of A at position I\n      .\n    ")]),d("dt",[e._v("of "),d("code",[e._v("      :  ")]),e._v(" I A -> X ")]),d("dd",[e._v(" X( = A[I]) is the I - th member of aggregate A\n      .\n    ")]),d("dt",[e._v("size "),d("code",[e._v("      :  ")]),e._v(" A -> I ")]),d("dd",[e._v(" Integer I is the number of elements of aggregate A\n      .\n    ")]),d("dt",[e._v("opcase "),d("code",[e._v("      :  ")]),e._v(" X[..[X Xs]..] ->\n      [Xs] \n    ")]),d("dd",[e._v(" Indexing on type of X, returns the list[Xs].\n    ")]),d("dt",[e._v("case "),d("code",[e._v("      :  ")]),e._v(" X[..[X Y]..] -> Y i ")]),d("dd",[e._v(" Indexing on the value of X,\n      execute the matching Y.\n    ")]),d("dt",[e._v("uncons "),d("code",[e._v("      :  ")]),e._v(" A -> F R ")]),d("dd",[e._v(" F and R are the first and the rest of non -\n      empty aggregate A.\n    ")]),d("dt",[e._v("unswons "),d("code",[e._v("      :  ")]),e._v(" A -> R F ")]),d("dd",[e._v(" R and F are the rest and the first of non -\n      empty aggregate A.\n    ")]),d("dt",[e._v("drop "),d("code",[e._v("      :  ")]),e._v(" A N -> B ")]),d("dd",[e._v(" Aggregate B is the result of deleting the first N elements of A\n      .\n    ")]),d("dt",[e._v("take "),d("code",[e._v("      :  ")]),e._v(" A N -> B ")]),d("dd",[e._v(" Aggregate B is the result of retaining just the first N elements of A\n      .\n    ")]),d("dt",[e._v("concat "),d("code",[e._v("      :  ")]),e._v(" S T -> U ")]),d("dd",[e._v(" Sequence U is the concatenation of sequences S and T\n      .\n    ")]),d("dt",[e._v("enconcat "),d("code",[e._v("      :  ")]),e._v(" X S T -> U ")]),d("dd",[e._v(" Sequence U is the concatenation of sequences S and T with X inserted between S and T( ==\n      swapd cons concat)\n    ")]),d("dt",[e._v("name "),d("code",[e._v("      :  ")]),e._v(' sym ->\n      "sym" \n    ')]),d("dd",[e._v(' For operators and combinators, the string "sym"\n      is the name of item sym,\n      for literals sym the result string is its type.\n    ')]),d("dt",[e._v("intern "),d("code",[e._v("      :  ")]),e._v(' "sym" -> sym ')]),d("dd",[e._v(' Pushes the item whose name is "sym"\n      .\n    ')]),d("dt",[e._v("body "),d("code",[e._v("      :  ")]),e._v(" U ->\n      [P] \n    ")]),d("dd",[e._v(" Quotation[P] is the body of user - defined symbol U.predicate\n    ")]),d("dt",[e._v("null "),d("code",[e._v("      :  ")]),e._v(" X -> B ")]),d("dd",[e._v(" Tests\n      for empty aggregate X or zero numeric.\n    ")]),d("dt",[e._v("small "),d("code",[e._v("      :  ")]),e._v(" X -> B ")]),d("dd",[e._v(" Tests whether aggregate X has 0 or 1 members,\n      or numeric 0 or 1.\n    ")]),d("dt",[e._v(">= "),d("code",[e._v("      :  ")]),e._v(" X Y -> B ")]),d("dd",[e._v(" Either both X and Y are numeric or both are strings or symbols\n      .Tests whether X greater than or equal to Y.Also supports float.\n    ")]),d("dt",[e._v("> "),d("code",[e._v("      :  ")]),e._v(" X Y -> B ")]),d("dd",[e._v(" Either both X and Y are numeric or both are strings or symbols\n      .Tests whether X greater than Y.Also supports float.\n    ")]),d("dt",[e._v("<= "),d("code",[e._v("      :  ")]),e._v(" X Y -> B ")]),d("dd",[e._v(" Either both X and Y are numeric or both are strings or symbols\n      .Tests whether X less than or equal to Y.Also supports float.\n    ")]),d("dt",[e._v("< "),d("code",[e._v("      :  ")]),e._v(" X Y -> B ")]),d("dd",[e._v(" Either both X and Y are numeric or both are strings or symbols\n      .Tests whether X less than Y.Also supports float.\n    ")]),d("dt",[e._v("!= "),d("code",[e._v("      :  ")]),e._v(" X Y -> B ")]),d("dd",[e._v(" Either both X and Y are numeric or both are strings or symbols\n      .Tests whether X not equal to Y.Also supports float.\n    ")]),d("dt",[e._v("= "),d("code",[e._v("      :  ")]),e._v(" X Y -> B ")]),d("dd",[e._v(" Either both X and Y are numeric or both are strings or symbols\n      .Tests whether X equal to Y.Also supports float.\n    ")]),d("dt",[e._v("equal "),d("code",[e._v("      :  ")]),e._v(" T U -> B ")]),d("dd",[e._v(" (Recursively) tests whether trees T and U are identical\n      .\n    ")]),d("dt",[e._v("has "),d("code",[e._v("      :  ")]),e._v(" A X -> B ")]),d("dd",[e._v(" Tests whether aggregate A has X as a member\n      .\n    ")]),d("dt",[e._v("in "),d("code",[e._v("      :  ")]),e._v(" X A -> B ")]),d("dd",[e._v(" Tests whether X is a member of aggregate A\n      .\n    ")]),d("dt",[e._v("integer "),d("code",[e._v("      :  ")]),e._v(" X -> B ")]),d("dd",[e._v(" Tests whether X is an integer.\n    ")]),d("dt",[e._v("char "),d("code",[e._v("      :  ")]),e._v(" X -> B ")]),d("dd",[e._v(" Tests whether X is a character.\n    ")]),d("dt",[e._v("logical "),d("code",[e._v("      :  ")]),e._v(" X -> B ")]),d("dd",[e._v(" Tests whether X is a logical.\n    ")]),d("dt",[e._v("set "),d("code",[e._v("      :  ")]),e._v(" X -> B ")]),d("dd",[e._v(" Tests whether X is a set.\n    ")]),d("dt",[e._v("string "),d("code",[e._v("      :  ")]),e._v(" X -> B ")]),d("dd",[e._v(" Tests whether X is a string.\n    ")]),d("dt",[e._v("list "),d("code",[e._v("      :  ")]),e._v(" X -> B ")]),d("dd",[e._v(" Tests whether X is a list.\n    ")]),d("dt",[e._v("leaf "),d("code",[e._v("      :  ")]),e._v(" X -> B ")]),d("dd",[e._v(" Tests whether X is not a list.\n    ")]),d("dt",[e._v("user "),d("code",[e._v("      :  ")]),e._v(" X -> B ")]),d("dd",[e._v(" Tests whether X is a user - defined symbol\n      .\n    ")]),d("dt",[e._v("float "),d("code",[e._v("      :  ")]),e._v(" R -> B ")]),d("dd",[e._v(" Tests whether R is a float.\n    ")]),d("dt",[e._v("file "),d("code",[e._v("      :  ")]),e._v(" F -> B ")]),d("dd",[e._v(" Tests whether F is a file.combinator\n    ")]),d("dt",[e._v("i "),d("code",[e._v("      :  ")]),e._v(" [P] ->... ")]),d("dd",[e._v(" Executes P.So, [P] i == P.\n    ")]),d("dt",[e._v("x "),d("code",[e._v("      :  ")]),e._v(" [P] i ->... ")]),d("dd",[e._v(" Executes P without popping[P].So, [P] x == [\n      P\n      ] P.\n    ")]),d("dt",[e._v("dip "),d("code",[e._v("      :  ")]),e._v(" X[P] ->...X ")]),d("dd",[e._v(" Saves X, executes P, pushes X back\n      .\n    ")]),d("dt",[e._v("app1 "),d("code",[e._v("      :  ")]),e._v(" X[P] -> R ")]),d("dd",[e._v(" Executes P, pushes result R on stack without X\n      .\n    ")]),d("dt",[e._v("app11 "),d("code",[e._v("      :  ")]),e._v(" X Y[P] -> R ")]),d("dd",[e._v(" Executes P, pushes result R on stack\n      .\n    ")]),d("dt",[e._v("app12 "),d("code",[e._v("      :  ")]),e._v(" X Y1 Y2[P] -> R1 R2 ")]),d("dd",[e._v(" Executes P twice, with Y1 and Y2,\n      returns R1 and R2.\n    ")]),d("dt",[e._v("construct "),d("code",[e._v("      :  ")]),e._v(" [P][\n      [P1][P2]..\n      ] -> R1 R2.. \n    ")]),d("dd",[e._v(" Saves state of stack and then executes[P].Then executes each[Pi] to give Ri pushed onto saved stack\n      .\n    ")]),d("dt",[e._v("nullary "),d("code",[e._v("      :  ")]),e._v(" [P] -> R ")]),d("dd",[e._v(" Executes P, which leaves R on top of the stack\n      .No matter how many parameters this consumes, none are removed from the stack.\n    ")]),d("dt",[e._v("unary "),d("code",[e._v("      :  ")]),e._v(" X[P] -> R ")]),d("dd",[e._v(" Executes P, which leaves R on top of the stack\n      .No matter how many parameters this consumes, exactly one is removed from the stack.\n    ")]),d("dt",[e._v("unary2 "),d("code",[e._v("      :  ")]),e._v(" X1 X2[P] -> R1 R2 ")]),d("dd",[e._v(" Executes P twice, with X1 and X2 on top of the stack\n      .Returns the two values R1 and R2.\n    ")]),d("dt",[e._v("unary3 "),d("code",[e._v("      :  ")]),e._v(" X1 X2 X3[P] -> R1 R2 R3 ")]),d("dd",[e._v(" Executes P three times,\n      with Xi, returns Ri(i = 1..3).\n    ")]),d("dt",[e._v("unary4 "),d("code",[e._v("      :  ")]),e._v(" X1 X2 X3 X4[P] -> R1 R2 R3 R4 ")]),d("dd",[e._v(" Executes P four times,\n      with Xi, returns Ri(i = 1..4).\n    ")]),d("dt",[e._v("app2 "),d("code",[e._v("      :  ")]),e._v(" X1 X2[P] -> R1 R2 ")]),d("dd",[e._v(" Obsolescent. == unary2\n    ")]),d("dt",[e._v("app3 "),d("code",[e._v("      :  ")]),e._v(" X1 X2 X3[P] -> R1 R2 R3 ")]),d("dd",[e._v(" Obsolescent. ==\n      unary3\n    ")]),d("dt",[e._v("app4 "),d("code",[e._v("      :  ")]),e._v(" X1 X2 X3 X4[P] -> R1 R2 R3 R4 ")]),d("dd",[e._v(" Obsolescent. ==\n      unary4\n    ")]),d("dt",[e._v("binary "),d("code",[e._v("      :  ")]),e._v(" X Y[P] -> R ")]),d("dd",[e._v(" Executes P, which leaves R on top of the stack\n      .No matter how many parameters this consumes, exactly two are removed from the stack.\n    ")]),d("dt",[e._v("ternary "),d("code",[e._v("      :  ")]),e._v(" X Y Z[P] -> R ")]),d("dd",[e._v(" Executes P, which leaves R on top of the stack\n      .No matter how many parameters this consumes, exactly three are removed from the stack.\n    ")]),d("dt",[e._v("cleave "),d("code",[e._v("      :  ")]),e._v(" X[P1][P2] -> R1 R2 ")]),d("dd",[e._v(" Executes P1 and P2, each with X on top,\n      producing two results.\n    ")]),d("dt",[e._v("branch "),d("code",[e._v("      :  ")]),e._v(" B[T][F] ->... ")]),d("dd",[e._v(" If B is true, then executes T\n      else executes F.\n    ")]),d("dt",[e._v("ifte "),d("code",[e._v("      :  ")]),e._v(" [B][T][F] ->... ")]),d("dd",[e._v(" Executes B.If that yields true,\n      then executes T\n      else executes F.\n    ")]),d("dt",[e._v("ifinteger "),d("code",[e._v("      :  ")]),e._v(" X[T][E] ->... ")]),d("dd",[e._v(" If X is an integer,\n      executes T\n      else executes E.\n    ")]),d("dt",[e._v("ifchar "),d("code",[e._v("      :  ")]),e._v(" X[T][E] ->... ")]),d("dd",[e._v(" If X is a character, executes T\n      else executes E.\n    ")]),d("dt",[e._v("iflogical "),d("code",[e._v("      :  ")]),e._v(" X[T][E] ->... ")]),d("dd",[e._v(" If X is a logical or truth value,\n      executes T\n      else executes E.\n    ")]),d("dt",[e._v("ifset "),d("code",[e._v("      :  ")]),e._v(" X[T][E] ->... ")]),d("dd",[e._v(" If X is a set, executes T\n      else executes E.\n    ")]),d("dt",[e._v("ifstring "),d("code",[e._v("      :  ")]),e._v(" X[T][E] ->... ")]),d("dd",[e._v(" If X is a string, executes T\n      else executes E.\n    ")]),d("dt",[e._v("iflist "),d("code",[e._v("      :  ")]),e._v(" X[T][E] ->... ")]),d("dd",[e._v(" If X is a list, executes T\n      else executes E.\n    ")]),d("dt",[e._v("iffloat "),d("code",[e._v("      :  ")]),e._v(" X[T][E] ->... ")]),d("dd",[e._v(" If X is a float, executes T\n      else executes E.\n    ")]),d("dt",[e._v("iffile "),d("code",[e._v("      :  ")]),e._v(" X[T][E] ->... ")]),d("dd",[e._v(" If X is a file, executes T\n      else executes E.\n    ")]),d("dt",[e._v("cond "),d("code",[e._v("      :  ")]),e._v(" [..[\n      [Bi] Ti\n      ]..[D]] ->... \n    ")]),d("dd",[e._v(" Tries each Bi.If that yields true, then executes Ti and exits.If no Bi yields true,\n      executes\n      default D.\n    ")]),d("dt",[e._v("while "),d("code",[e._v("      :  ")]),e._v(" [B][D] ->... ")]),d("dd",[e._v(" While executing B yields true executes D\n      .\n    ")]),d("dt",[e._v("linrec "),d("code",[e._v("      :  ")]),e._v(" [P][T][R1][R2] ->... ")]),d("dd",[e._v(" Executes P.If that yields true,\n      executes T.Else executes R1, recurses, executes R2.\n    ")]),d("dt",[e._v("tailrec "),d("code",[e._v("      :  ")]),e._v(" [P][T][R1] ->... ")]),d("dd",[e._v(" Executes P.If that yields true,\n      executes T.Else executes R1, recurses.\n    ")]),d("dt",[e._v("binrec "),d("code",[e._v("      :  ")]),e._v(" [B][T][R1][R2] ->... ")]),d("dd",[e._v(" Executes P.If that yields true,\n      executes T.Else uses R1 to produce two intermediates, recurses on both, then executes R2 to combines their results\n      .\n    ")]),d("dt",[e._v("genrec "),d("code",[e._v("      :  ")]),e._v(" [B][T][R1][R2] ->... ")]),d("dd",[e._v(" Executes B,\n      if that yields true executes T.Else executes R1 and then[[B][T][R1][R2] genrec] R2.\n    ")]),d("dt",[e._v("condlinrec "),d("code",[e._v("      :  ")]),e._v(" [\n      [C1][C2]..[D]\n      ] ->... \n    ")]),d("dd",[e._v(" Each[Ci] is of the forms[[B][T]] or[[B][R1][R2]].Tries each B.If that yields true and there is just a[\n      T], executes T and exit.If there are[R1] and[R2], executes R1, recurses, executes R2.Subsequent\n      case are ignored.If no B yields true, then[D] is used.It is then of the forms[[T]] or[[R1][R2]].For the former,\n      executes T.For the latter executes R1, recurses, executes R2.\n    ")]),d("dt",[e._v("step "),d("code",[e._v("      :  ")]),e._v(" A[P] ->... ")]),d("dd",[e._v(" Sequentially putting members of aggregate A onto stack,\n      executes P\n      for each member of A.\n    ")]),d("dt",[e._v("fold "),d("code",[e._v("      :  ")]),e._v(" A V0[P] -> V ")]),d("dd",[e._v(" Starting with value V0,\n      sequentially pushes members of aggregate A and combines with binary operator P to produce value V.\n    ")]),d("dt",[e._v("map "),d("code",[e._v("      :  ")]),e._v(" A[P] -> B ")]),d("dd",[e._v(" Executes P on each member of aggregate A,\n      collects results in sametype aggregate B.\n    ")]),d("dt",[e._v("times "),d("code",[e._v("      :  ")]),e._v(" N[P] ->... ")]),d("dd",[e._v(" N times executes P.\n    ")]),d("dt",[e._v("infra "),d("code",[e._v("      :  ")]),e._v(" L1[P] -> L2 ")]),d("dd",[e._v(" Using list L1 as stack, executes P and returns a new list L2\n      .The first element of L1 is used as the top of stack, and after execution of P the top of stack becomes the first element of L2\n      .\n    ")]),d("dt",[e._v("primrec "),d("code",[e._v("      :  ")]),e._v(" X[I][C] -> R ")]),d("dd",[e._v(" Executes I to obtain an initial value R0\n      .For integer X uses increasing positive integers to X, combines by C\n      for new R.For aggregate X uses successive members and combines by C\n      for new R.\n    ")]),d("dt",[e._v("filter "),d("code",[e._v("      :  ")]),e._v(" A[B] -> A1 ")]),d("dd",[e._v(" Uses test B to filter aggregate A producing sametype aggregate A1\n      .\n    ")]),d("dt",[e._v("split "),d("code",[e._v("      :  ")]),e._v(" A[B] -> A1 A2 ")]),d("dd",[e._v(" Uses test B to split aggregate A into sametype aggregates A1 and A2\n      .\n    ")]),d("dt",[e._v("some "),d("code",[e._v("      :  ")]),e._v(" A[B] -> X ")]),d("dd",[e._v(" Applies test B to members of aggregate A,\n      X = true\n      if some pass.\n    ")]),d("dt",[e._v("all "),d("code",[e._v("      :  ")]),e._v(" A[B] -> X ")]),d("dd",[e._v(" Applies test B to members of aggregate A,\n      X = true\n      if all pass.\n    ")]),d("dt",[e._v("treestep "),d("code",[e._v("      :  ")]),e._v(" T[P] ->... ")]),d("dd",[e._v(" Recursively traverses leaves of tree T,\n      executes P\n      for each leaf.\n    ")]),d("dt",[e._v("treerec "),d("code",[e._v("      :  ")]),e._v(" T[O][C] ->... ")]),d("dd",[e._v(" T is a tree.If T is a leaf,\n      executes O.Else executes[[O][C] treerec] C.\n    ")]),d("dt",[e._v("treegenrec "),d("code",[e._v("      :  ")]),e._v(" T[O1][O2][C] ->... ")]),d("dd",[e._v(" T is a tree.If T is a leaf,\n      executes O1.Else executes O2 and then[[O1][O2][C] treegenrec] C.miscellaneous commands\n    ")]),d("dt",[e._v("help "),d("code",[e._v("      :  ")]),e._v(" -> ")]),d("dd",[e._v(' Lists all defined symbols, including those from library files\n      .Then lists all primitives of raw Joy(There is a variant: "_help"\n      which lists hidden symbols).\n    ')]),d("dt",[e._v("helpdetail "),d("code",[e._v("      :  ")]),e._v(" [S1 S2..] ")]),d("dd",[e._v(" Gives brief help on each symbol S in\n      the list.\n    ")]),d("dt",[e._v("manual "),d("code",[e._v("      :  ")]),e._v(" -> ")]),d("dd",[e._v(" Writes this manual of all Joy primitives to output file\n      .\n    ")]),d("dt",[e._v("setautoput "),d("code",[e._v("      :  ")]),e._v(" I -> ")]),d("dd",[e._v(" Sets value of flag\n      for automatic put to I(\n      if I = 0, none;\n      if I = 1, put;\n      if I = 2, stack.\n    ")]),d("dt",[e._v("setundeferror "),d("code",[e._v("      :  ")]),e._v(" I -> ")]),d("dd",[e._v(" Sets flag that controls behavior of undefined functions(\n      0 = no error, 1 = error).\n    ")]),d("dt",[e._v("setecho "),d("code",[e._v("      :  ")]),e._v(" I -> ")]),d("dd",[e._v(" Sets value of echo flag\n      for listing.I = 0: no echo, 1: echo, 2: with tab, 3: and linenumber.\n    ")]),d("dt",[e._v("gc "),d("code",[e._v("      :  ")]),e._v(" -> ")]),d("dd",[e._v(" Initiates garbage collection.\n    ")]),d("dt",[e._v("system "),d("code",[e._v("      :  ")]),e._v(' "command" -> ')]),d("dd",[e._v(' Escapes to shell, executes string "command"\n      .The string may cause execution of another program.When that has finished, the process returns to Joy.\n    ')]),d("dt",[e._v("getenv "),d("code",[e._v("      :  ")]),e._v(' "variable" ->\n      "value" \n    ')]),d("dd",[e._v(' Retrieves the value of the environment variable "variable".\n    ')]),d("dt",[e._v("argv "),d("code",[e._v("      :  ")]),e._v(" -> A ")]),d("dd",[e._v(" Creates an aggregate A containing the interpreter 's command line arguments.\n    ")]),d("dt",[e._v("argc "),d("code",[e._v("      :  ")]),e._v(" -> I ")]),d("dd",[e._v(" Pushes the number of command line arguments\n      .This is quivalent to 'argv size'.\n    ")]),d("dt",[e._v("get "),d("code",[e._v("      :  ")]),e._v(" -> F ")]),d("dd",[e._v(" Reads a factor from input and pushes it onto stack\n      .\n    ")]),d("dt",[e._v("put "),d("code",[e._v("      :  ")]),e._v(" X -> ")]),d("dd",[e._v(" Writes X to output, pops X off stack.\n    ")]),d("dt",[e._v("putch "),d("code",[e._v("      :  ")]),e._v(" N -> ")]),d("dd",[e._v(" N: numeric, writes character whose ASCII is N\n      .\n    ")]),d("dt",[e._v("putchars "),d("code",[e._v("      :  ")]),e._v(' "abc.." -> ')]),d("dd",[e._v(" Writes abc..(without quotes)\n    ")]),d("dt",[e._v("include "),d("code",[e._v("      :  ")]),e._v(' "filnam.ext" -> ')]),d("dd",[e._v(' Transfers input to file whose name is "filnam.ext"\n      .On end - of - file returns to previous input file.\n    ')]),d("dt",[e._v("abort "),d("code",[e._v("      :  ")]),e._v(" -> ")]),d("dd",[e._v(" Aborts execution of current Joy program,\n      returns to Joy main cycle.\n    ")]),d("dt",[e._v("quit "),d("code",[e._v("      :  ")]),e._v(" -> ")]),d("dd",[e._v(" Exit from Joy.\n    ")])])])}]};t.a=s},DGHM:function(e,t,d){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=d("BCFa"),s=!1;var o=function(e){s||d("ubk6")},v=d("VU/8")(null,n.a,!1,o,"data-v-238d98fc",null);v.options.__file="pages/papers-on-joy/html-manual.vue",t.default=v.exports},odtW:function(e,t,d){(e.exports=d("FZ+f")(!1)).push([e.i,"p[data-v-238d98fc]{margin-top:16px;margin-bottom:16px}hr[data-v-238d98fc]{margin-bottom:16px}pre[data-v-238d98fc]{margin-bottom:auto}code[data-v-238d98fc],kbd[data-v-238d98fc],pre[data-v-238d98fc]{font-family:Roboto Mono,monospace}",""])},ubk6:function(e,t,d){var n=d("odtW");"string"==typeof n&&(n=[[e.i,n,""]]),n.locals&&(e.exports=n.locals);d("rjj0")("17d353ee",n,!1,{sourceMap:!1})}});