webpackJsonp([6],{"3m6o":function(e,n,t){"use strict";var o=function(){var e=this.$createElement;this._self._c;return this._m(0)};o._withStripped=!0;var a={render:o,staticRenderFns:[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("article",[e._v("\n  Contents:"),t("br"),t("ol",[t("li",[e._v("Introduction"),t("br")]),t("li",[e._v("Church numerals"),t("br")]),t("li",[e._v("Arithmetic operators for Church numerals"),t("br")]),t("li",[e._v("Quotation numerals and quotation operators"),t("br")]),t("li",[e._v("Church truth values"),t("br")]),t("li",[e._v("Church predicates, Church conditionals and Church lists"),t("br")]),t("li",[e._v("Miscellaneous"),t("br")]),t("li",[e._v("Brent Kerby's elegant and efficient alternative Church numerals"),t("br")]),t("li",[e._v("Testing Brent Kerby's Church numerals"),t("br")]),t("li",[e._v("Another kind of Church numeral, also by Brent Kerby"),t("br")]),t("li",[e._v("Yet another kind of Church numeral, again by Brent Kerby"),t("br")])]),t("h1",[e._v("Introduction")]),e._v('\n  Numbers are often taken to be be sets or constructions out of sets.\n  Thus the number five can be taken to be the set of all those sets\n  that have 5 members: the set of fingers on my left hand, the set\n  of fingers on my right hand, the set of working days in the week,\n  and so on. \n  In this scheme the number zero is the set of all those\n  sets that have no members,\n  it is the set that has just the null-set as its sole member.\n  On another scheme the number zero is the null-set, and any other\n  natural number is the set of its predecessors.\n  On both schemes natural numbers are possible answers to the question\n  "how many" or more precisely, "how many things".\n  '),t("p",[e._v('\n    But natural numbers can equally well be taken to be answers\n    to the question "how many times" or "how often".\n    This is how they are treated in Church\'s lambda calculus.\n    They are functions which take a unary function as argument\n    and return a unary function as value.\n    If the argument function is the squaring function,\n    and the number in question is three,\n    then the returned function computes the square of the square of the square.\n    So numbers are second order functions.\n    But since they are unary functions, they can be applied to themselves\n    at least in the untyped lambda calculus.\n    So numbers are also third order functions, and so forth - \n    they are simply higher order functions.\n  ')]),t("p",[e._v('\n    Numbers must be distinguished from numerals or more generally,\n    numeric expressions.\n    The numerals "7", "seven", "sept", "VII"\n    and also the expressions "3+4" and "10-3"\n    are all different, and yet they denote the same natural number.\n    The so-called Church numerals of the lambda calculus are expressions\n    which denote higher order functions of the kind described above.\n    The remainder of this note shows how Church numerals\n    can also be expressed in Joy.\n  ')]),t("h1",[e._v("Church numerals")]),e._v("\n  In Joy a Church numeral will have to  be a program which\n  expects on the stack a quoted program, say [P], and below that whatever\n  parameters are needed to execute the quoted program.\n  The numeral will indicate how often [P] is to be executed:\n  not at all, once, twice, thrice, or whatever.\n  "),t("p",[e._v("\n    First, the Church numeral C0, which is to execute\n    the quoted program [P] zero times.\n    Clearly this is achieved by just popping off the quoted program.\n  ")]),t("p",[e._v("\n    The other Church numerals will have to be constructed from\n    C0 together with Csucc, a successor function for Church numerals.\n    This function Csucc will take as parameters a quoted\n    Church numeral, say Cn, and below that whatever quotation is to be\n    executed repeatedly.\n    So a program of the form ... [P] [Cn] Csucc  should\n    execute [P] exactly (n+1) times.\n    This can be done by executing [P] once, and then again n times.\n    So Csucc should first execute a copy of [P] and then\n    allow Cn to execute [P] n times.\n  ")]),t("p",[e._v("\n    Here are the definitions of C0 and Csucc:"),t("br")]),t("pre",[e._v(" DEFINE \n        C0  ==  pop; \n        Csucc  ==  [dup [i] dip] dip i. \n  ")]),e._v("\n  Church numerals do not denote numbers as data values\n  but numbers as repetitions of execution of a program.\n  So they need a program [P] to be repeated zero or more\n  times.\n  Preferably the output should bear some resemblance\n  to what is being tested.\n  A good choice is the ordinary successor function succ\n  for ordinary numbers, to be called\n  zero or more times with the ordinary number 0 on top of the stack.\n  "),t("pre",[e._v(" DEFINE \n        Peano  ==  0 [succ]. \n  ")]),e._v("\n  Here are the obvious tests:"),t("br"),t("pre",[e._v(" Peano C0. \n  0\n    Peano [C0] Csucc. \n  1\n    Peano [[C0] Csucc] Csucc. \n  2\n    Peano [[[C0] Csucc] Csucc] Csucc. \n  3\n  ")]),e._v("\n  It is convenient to introduce definitions\n  for the first few positive Church numerals.\n  The tests follow.\n  "),t("pre",[e._v(" DEFINE \n        C1  ==  [C0] Csucc; \n        C2  ==  [C1] Csucc; \n        C3  ==  [C2] Csucc. \n  ")]),t("pre",[e._v(" Peano C0. \n  0\n    Peano C1. \n  1\n    Peano C2. \n  2\n    Peano C3. \n  3\n  ")]),e._v("\n  Instead of using the natural numbers, with 0 and [succ],\n  for tests of the Church numerals, we can also use many others data structures.\n  Here are two examples:\n  "),t("pre",[e._v(" DEFINE \n        Doublings  ==  1 [2 *]; \n        Lists  ==  [] [[i] swoncat]. \n  ")]),t("pre",[e._v(" Doublings C0. \n  1\n    Doublings C1. \n  2\n    Doublings C2. \n  4\n    Doublings C3. \n  8\n  ")]),t("pre",[e._v(" Lists C0. \n  []\n    Lists C1. \n  [i]\n    Lists C2. \n  [i i]\n    Lists C3. \n  [i i i]\n  ")]),t("h1",[e._v("Arithmetic operators for Church numerals")]),e._v("\n  Church numerals in the lambda calculus or in Joy\n  can be added, multiplied and exponentiated just like\n  ordinary numerals.\n  The three operators Cadd, Cmul and Cpow all take\n  two quoted Church numerals [Cm] and [Cn] as parameters.\n  Of course below those two quotations they expect the quoted \n  function that is to be repeated, and below that the initial value.\n  "),t("p",[e._v("\n    To add two numbers m and n, we can take the n-th successor of m.\n    This is also what the definition of Cadd below will do.\n    It will transform the quotation [Cm] into another quotation\n    by repeatedly constructing the successor quotation,\n    where the number of repetitions is given by [Cn] which\n    is called by the first i.\n    The reculting quotion is then called by the final i.\n  ")]),t("p",[e._v("\n    To multiply two numbers m and n, we can start with 0 and add m\n    exactly n times.\n    To exponentiate, to compute m to the n-th power,\n    we start with 1 and multiply by m exactly n times.\n    This is also what the definitions of Cmul and Cpow do.\n    They are more complex than the definition for Cadd\n    for two reasons:\n    the starting values C0 and C1 have to be specified,\n    and also the operations Cadd and Cmul which they\n    use are binary.\n    The starting values are quoted, as [C0] and [C1] respectively,\n    and they are squeezed below the [Cm] and [Cn].\n    At the same time [Cm] is transformed into \n    either [[[Cm] Cadd] cons] or [[[Cm] Cmul] cons] respectively.\n    This is then repeatedly executed, where the number\n    of repetitions is given by [Cn] which is calle by the first i.\n    The resulting quotation is then called by the final i.\n  ")]),t("p",[e._v("\n    Here follow the definitions and two forms of tests."),t("br")]),t("pre",[e._v(" DEFINE \n        Cadd  ==  [ [[Csucc] cons] ] dip i i; \n        Cmul  ==  [ [[C0]] dip  [Cadd] cons [cons] cons ] dip i i; \n        Cpow  ==  [ [[C1]] dip  [Cmul] cons [cons] cons ] dip i i. \n  ")]),t("pre",[e._v(" Peano [C2] [C3] Cadd. \n  5\n    Peano [C2] [C3] Cmul. \n  6\n    Peano [C2] [C3] Cpow. \n  8\n  ")]),t("pre",[e._v(" Doublings [C2] [C3] Cadd. \n  32\n    Doublings [C2] [C3] Cmul. \n  64\n    Doublings [C2] [C3] Cpow. \n  256\n  ")]),e._v("\n  The operators can of course be used in complex expressions,\n  as in these examples.\n  The first just computes a value,\n  and the second  compares the same value with\n  the identical value obtained from ordinary arithmetic.\n  "),t("pre",[e._v(" Peano [[[[[C3] Csucc] [C2] Cadd] [C3] Cmul] Csucc] [C2] Cadd . \n  21\n    Peano [[[[[C3] Csucc] [C2] Cadd] [C3] Cmul] Csucc] [C2] Cadd \n                3   succ    2   +      3   *     succ    2   +      = . \n  true\n  ")]),e._v("\n  As the second example shows, the value computed using\n  Church arithmetic is the same as the one using ordinary arithmetic.\n  However, the example also shows up how complex the expressions\n  using Church arithmetic become when compared with ordinary expressions.\n  This is because the Church operators need quotations as\n  parameters, and hence the Church expression contains\n  many square brackets whereas the ordinary expression\n  requires none.\n  So it seems that the quotation brackets are\n  performing somewhat the same role as the\n  ordinary grouping parentheses are performing\n  in infix notation.\n  "),t("p",[e._v("\n    It is of some interest to see whether this is an inherent\n    problem with expressing Church arithmetic in Joy,\n    or whether there is a way of expressing Church arithmetic\n    in Joy that retains the usual bracket free notation\n    of Joy as for ordinary arithmetic.\n  ")]),t("h1",[e._v("Quotation numerals and Quotation operators")]),e._v("\n  In Joy it is possible to define quotations and also\n  quotation producing operators on quotations.\n  Such quotations can then be executed by the i combinator\n  or any other combinator.\n  For an analogue of Church arithmetic\n  the quotations will have to be the quoted Church numerals.\n  These will be called quotation numerals.\n  The quotation operators, corresponding to the Church operators,\n  will take quotations off the stack and\n  leave a new quotation on top of the stack.\n  "),t("p",[e._v("\n    The remainder of this section defines quotation numerals\n    and quotation operators in the same sequence as in the\n    two preceding sections.\n  ")]),t("p",[e._v("\n    First, the quotation numeral Q0 and the quotation operator Qsucc:"),t("br")]),t("pre",[e._v(" DEFINE \n        Q0  ==  [pop]; \n        Qsucc  ==  [ [dup [i] dip] dip i ]  cons. \n  ")]),t("pre",[e._v(" Peano Q0 i. \n  0\n    Peano Q0 Qsucc i. \n  1\n    Peano Q0 Qsucc Qsucc i. \n  2\n  ")]),t("pre",[e._v(" DEFINE \n        Q1  ==  Q0 Qsucc; \n        Q2  ==  Q1 Qsucc; \n        Q3  ==  Q2 Qsucc. \n  ")]),t("pre",[e._v(" Peano Q0 i. \n  0\n    Peano Q1 i. \n  1\n    Peano Q2 i. \n  2\n    Peano Q3 i. \n  3\n  ")]),e._v("\n  Since Church numerals denote (higher order) functions,\n  they cannot be written - they do not have a finite representation.\n  However, this is not true of the quotation numerals as just defined -\n  these can be written since they are just quoted programs\n  to compute such functions.\n  \bHere are the first four quotation numerals:\n  "),t("pre",[e._v(" Q0. \n  [pop]\n    Q1. \n  [[pop] [dup [i] dip] dip i]\n    Q2. \n  [[[pop] [dup [i] dip] dip i] [dup [i] dip] dip i]\n    Q3. \n  [[[[pop] [dup [i] dip] dip i] [dup [i] dip] dip i] [dup [i] dip] dip i]\n  ")]),t("p",[e._v("\n    The quotation operators for addition, multiplication and exponentiation\n    are just like the quotation operator Qsucc:\n    they expect quotations as parameters and produce quotations as results.\n    Their definitions below are a simple adaptation of the \n    corresponding Church operators.\n    A few tests also follow.\n  ")]),t("pre",[e._v(" DEFINE \n        Qadd  == \n          [ [[Qsucc i] cons] swap i i ]  cons cons; \n        Qmul  == \n          [ [[[Q0 i]] dip [Qadd i] cons [cons] cons] dip i i ] cons cons; \n        Qpow  == \n          [ [[[Q1 i]] dip [Qmul i] cons [cons] cons] dip i i ] cons cons. \n  ")]),t("pre",[e._v("  \n    Peano Q2 Q3 Qadd i . \n  5\n    Peano Q2 Q3 Qmul i . \n  6\n    Peano Q2 Q3 Qpow i . \n  8\n  ")]),e._v("\n  Again, because these three quotation operators\n  take quotations as parameters and produce quotations,\n  the result quotations can always be written without being called:\n  "),t("pre",[e._v(" Q2 Q3 Qadd . \n  [[[[pop] [dup [i] dip] dip i] [dup [i] dip] dip i] [[[[pop] [dup [i] dip] dip i] [dup [i] dip] dip i] [dup [i] dip] dip i] [[Qsucc i] cons] swap i i]\n    Q2 Q3 Qmul . \n  [[[[pop] [dup [i] dip] dip i] [dup [i] dip] dip i] [[[[pop] [dup [i] dip] dip i] [dup [i] dip] dip i] [dup [i] dip] dip i] [[[Q0 i]] dip [Qadd i] cons [cons] cons] dip i i]\n    Q2 Q3 Qpow . \n  [[[[pop] [dup [i] dip] dip i] [dup [i] dip] dip i] [[[[pop] [dup [i] dip] dip i] [dup [i] dip] dip i] [dup [i] dip] dip i] [[[Q1 i]] dip [Qmul i] cons [cons] cons] dip i i]\n  ")]),e._v("\n  Finally, here is the complex expression from the end of the previous section\n  now written in quotation notation.\n  As can be seen, there are no quotation brackets visible,\n  and as the second example shows,\n  the whole structure of the expression is identical to the\n  ordinary postfix expression for ordinary arithmetic.\n  "),t("pre",[e._v(" Peano      Q3 Qsucc  Q2 Qadd  Q3 Qmul Qsucc Q2 Qadd i. \n  21\n    Peano      Q3 Qsucc  Q2 Qadd  Q3 Qmul Qsucc Q2 Qadd i \n                3  succ   2  +     3  *    succ  2  +      = . \n  true\n  ")]),t("h1",[e._v("Church truth values")]),e._v('\n  Whereas Church numerals can be taken to be answers to the question "how often",\n  Church truth values can be taken to be answers to the question "which one",\n  when there is a choice of two.\n  From an operational point of view,\n  Church numerals represent looping (for-loops),\n  and Church numerals represent branching.\n  Whereas CHurch numerals take as a parameter one function,\n  Church truth values take two parameters of which one will be\n  ignored and the other evaluated.\n  In Joy these two parameters will have to be quotations\n  on the top of the stack.\n  As for Church numerals, Church truth values do not denote data values,\n  but choices between executing one of two quoted programs\n  to be executed.\n  '),t("p",[e._v("\n    Here are the definitions of the two Church truth values,\n    also two pairs of functions, and of course some tests.\n  ")]),t("pre",[e._v("  \n    DEFINE  \n        Ctrue  ==  pop i; \n        Cfalse  ==  popd i. \n  ")]),t("pre",[e._v(' DEFINE \n        Boole  ==  ["Yes, yes"] ["No, no"]; \n        Comparison  ==  2 3 [<] [>]. \n  ')]),t("pre",[e._v(' Boole Ctrue. \n  "Yes, yes"\n    Boole Cfalse. \n  "No, no"\n    Comparison Ctrue. \n  true\n    Comparison Cfalse. \n  false\n  ')]),e._v("\n  The negation operator for Church truth values\n  will take as its parameter a quotation which,\n  when executed, will expect two quotations on the stack.\n  In analogy with the definition of Church negation in\n  the lambda calculus,\n  the Cnot operator for Church truthvalues in Joy might be defined as\n  "),t("pre",[e._v(" DEFINE\n        Cnot  ==  [ [Cfalse] [Ctrue] ] dip i. \n  ")]),e._v("\n  However, because Joy is stack-based,\n  a much simpler definition results if the Cnot operator\n  simply swaps the two quotation parameters\n  below the Church truth value, as follows.\n  "),t("pre",[e._v(" DEFINE \n        Cnot  ==  swapd i. \n  ")]),t("pre",[e._v(' Boole [Ctrue] Cnot. \n  "No, no"\n    Boole [Cfalse] Cnot. \n  "Yes, yes"\n    Comparison [[Ctrue] Cnot] Cnot. \n  true\n    Comparison [[Cfalse] Cnot] Cnot. \n  false\n  ')]),e._v("\n  The definition of the two binary operators\n  on Church truth values look quite different\n  from the binary operators on Church numerals.\n  This is because Church truth values take\n  two quotation parameters, whereas Church numerals\n  only take one.\n  Apart from that, the definitions of the\n  disjunction and conjunction operators\n  on truth values are actually simpler than\n  those for Church numerals.\n  "),t("p",[e._v('\n    Both operators expect two quotations denoting Church truth values.\n    Both may need to be executed to determine the result of the\n    binary operation.\n    In the case of disjunction, Cor,\n    if the evaluation of the top quotation yields Ctrue,\n    then the other quotation will be discarded\n    and the quotation below that will be executed.\n    That will have to be the quotation [Ctrue],\n    which will have to be placed there before Cor\n    can execute the top quotation.\n    On the other hand, if the evaluation of the top\n    quotation yields Cfalse, then the added quotation [Ctrue]\n    will be discarded and the second quotation\n    will be executed whose result then fully determines\n    the result yielded by Cor.\n    Since the second quotation is only executed when\n    its result is needed,\n    this definition of Cor is what is sometimes\n    called a "short circuit" implementation.\n  ')]),t("p",[e._v("\n    The definition of Cand is entirely analogous.\n    The four tests for Cor and for Cand also follow.\n  ")]),t("pre",[e._v(" DEFINE \n        Cor  ==  [[Ctrue]] dipd i; \n        Cand  ==  [[Cfalse]] dip i. \n  ")]),t("pre",[e._v(' Boole [Ctrue ] [Ctrue ] Cor. \n  "Yes, yes"\n    Boole [Ctrue ] [Cfalse] Cor. \n  "Yes, yes"\n    Boole [Cfalse] [Ctrue ] Cor. \n  "Yes, yes"\n    Boole [Cfalse] [Cfalse] Cor. \n  "No, no"\n\n    Boole [Ctrue ] [Ctrue ] Cand. \n  "Yes, yes"\n    Boole [Ctrue ] [Cfalse] Cand. \n  "No, no"\n    Boole [Cfalse] [Ctrue ] Cand. \n  "No, no"\n    Boole [Cfalse] [Cfalse] Cand. \n  "No, no"\n  ')]),t("h1",[e._v("Church predicates, Church conditionals and Church lists")]),e._v("\n  The operators for Church logic are not so useful\n  when they can only operate on Church truth value constants Ctrue and Cfalse.\n  But they become more useful when there are predicates whose\n  evaluation yields Church truth values.\n  "),t("p",[e._v("\n    Below is the definition of just one such predicate,\n    the unary predicate Ceq0 which tests whether its\n    parameter on the top of the stack is equal to zero,\n    or better: whether it is C0.\n    In the case of equality Ceq0 has to behave like\n    Ctrue, otherwise it has to behave like Cfalse.\n    To perform the test, it has to execute its parameter,\n    which is a quotation [Cn] of a Church numeral\n    or a quotation which eventually yields such a numeral.\n    Below that parameter has to be a quotation which\n    might not be executed at all if n=0,\n    but might be executed many times.\n    In the first case, when n=0,\n    the Church numeral C0 has already been executed,\n    and the redundant quotation has already been popped,\n    but now Ctrue has to be executed.\n    In the other cases, when n is positive,\n    the Church numeral will have executed a a quotation\n    several times, but now Cfalse has to be executed.\n  ")]),t("p",[e._v("\n    The definition below will do just that.\n    First, below the quotation [Cn] it inserts two\n    other quotations,\n    [Ctrue] and [pop [Cfalse]].\n    The second of these may be executed zero or more times.\n    The first time, if ever, it will replace the [Ctrue] by\n    [Cfalse], and any further time it will replace\n    the [Cfalse] it has placed there last time by a new [Cfalse].\n    After these two quotations have been inserted \n    below the quoted Church numeral [Cn],\n    the first i executes [Cn],\n    resulting in either the original [Ctrue]\n    or a [Cfalse] to become the top element on the stack.\n    Finally, the second i executes that, as required.\n  ")]),t("p",[e._v("\n    After the definitions there are some obvious tests,\n    and the last two also use the equality predicate\n    in expressions using Cor and Cand.\n  ")]),t("pre",[e._v(" DEFINE \n        Ceq0  == [ [Ctrue] [pop [Cfalse]] ] dip i i. \n  ")]),t("pre",[e._v(' Boole [C0] Ceq0 . \n  "Yes, yes"\n    Boole [C1] Ceq0 . \n  "No, no"\n    Boole [C2] Ceq0 . \n  "No, no"\n    Boole [[C0] Ceq0] [[[C2] Csucc] Ceq0] Cor. \n  "Yes, yes"\n    Boole [[C0] Ceq0] [[[C2] Csucc] Ceq0] Cand. \n  "No, no"\n  ')]),e._v("\n  The Church truth values expect two quotations on the top of the stack,\n  and depending on which truth value it is,\n  one of the quotations will be discarded and the other will be executed.\n  So they implement a simple version of branching.\n  A more useful one would expect a third quotation on the stack\n  that is executed to determine which of the other two is to be executed.\n  The third quotation, the if-part,\n  could be above of below the other two, the then-part and the else-part.\n  For efficient execution the if-part should be on top,\n  to be executed by the combinator i.\n  On the other hand, for analogy with the ordinary combinator ifte,\n  it is best if the if-part is the third element on the stack.\n  In the following definition of a Church combinator Cifte,\n  the if-part is moved to the top by rolling down the other two parts.\n  Following that, the if-part is executed by the i combinator.\n  "),t("p",[e._v("\n    Several examples also follow.\n    The later examples, which use Church conditionals nested within\n    Church conditionals, are written over several lines for ease of reading.\n  ")]),t("pre",[e._v(" DEFINE \n        Cifte  ==  rolldown i. \n  ")]),t("pre",[e._v(" Peano  [[C0] Ceq0]  [C2]  [C3]  Cifte. \n  2\n    Peano  [[C1] Ceq0]  [C2]  [C3]  Cifte. \n  3\n    Peano  [[[C0] Ceq0] Cnot]  [C2]  [C3]  Cifte. \n  3\n    Peano  [[[C1] Ceq0] Cnot]  [C2]  [C3]  Cifte. \n  2\n  ")]),t("pre",[e._v(" Peano [Ctrue ]\n                [[Ctrue ] [C0] [C1] Cifte]\n                [[Ctrue ] [C2] [C3] Cifte]\n                Cifte. \n  0\n    Peano [Ctrue ]\n                [[Cfalse] [C0] [C1] Cifte]\n                [[Cfalse] [C2] [C3] Cifte]\n                Cifte. \n  1\n    Peano [Cfalse]\n                [[Ctrue ] [C0] [C1] Cifte]\n                [[Ctrue ] [C2] [C3] Cifte]\n                Cifte. \n  2\n    Peano [Cfalse]\n                [[Cfalse] [C0] [C1] Cifte]\n                [[Cfalse] [C2] [C3] Cifte]\n                Cifte. \n  3\n  ")]),e._v('\n  Church truth values are actually very similar to\n  the two operations which select one or the other from\n  a pair of objects.\n  The "dotted pair" constructor cons in Lisp and Scheme\n  builds a pair of objects from its two parameters.\n  The two operators car and cdr select the first or the second\n  from such a pair.\n  The last sentence just about captures the semantics of\n  the constructor cons and the two operators.\n  Any implementation must capture this semantic condition,\n  but otherwise any further detail of the implementation is immaterial.\n  '),t("p",[e._v("\n    The following define a constructor Ccons and\n    two operators Ccar and Ccdr.\n    The latter use the Church truth values Ctrue and Cfalse\n    to effect the selection from a pair constructed by Ccons.\n    Ccons of course expects two parameters on the top of the stack,\n    but since there is no requirement that the two be wrapped into\n    one parcel, it does not do so.\n    Instead it just pushes the sligtly curious quotation [i].\n    This will be executed by the call to the i combinator in\n    Ccar and Ccdr, and that will result in either Ctrue or Cfalse\n    being executed, depending on which one caused the execution of [i].\n  ")]),t("p",[e._v("\n    Note that Ccons is more general than the cons operator on Joy\n    which requires its topmost parameter to be a list.\n  ")]),t("p",[e._v("\n    The last four examples are again\n    written over several lines for ease of reading.\n    They are the four list-counterparts of the\n    four conditionals of the previous examples.\n  ")]),t("pre",[e._v(" DEFINE \n        Ccons  ==  [i]; \n        Ccar  ==  [Ctrue] swap i; \n        Ccdr  ==  [Cfalse] swap i. \n  ")]),t("pre",[e._v(" Peano  [C0] [C1] Ccons Ccar. \n  0\n    Peano  [C0] [C1] Ccons Ccdr. \n  1\n  ")]),t("pre",[e._v(" Peano [[C0] [C1] Ccons Ccar]\n                [[C2] [C3] Ccons Ccar]\n                Ccons Ccar. \n  0\n    Peano [[C0] [C1] Ccons Ccdr]\n                [[C2] [C3] Ccons Ccdr]\n                Ccons Ccar. \n  1\n    Peano [[C0] [C1] Ccons Ccar] \n                [[C2] [C3] Ccons Ccar]\n                Ccons Ccdr. \n  2\n    Peano [[C0] [C1] Ccons Ccdr]\n                [[C2] [C3] Ccons Ccdr]\n                Ccons Ccdr. \n  3\n  ")]),t("h1",[e._v("Miscellaneous")]),e._v("\n  As may be seen, complex expressions using any of the operators\n  of the preceding two sections will require the same\n  annoying bracketing as was encountered in the sections\n  on Church arithmetic.\n  However, in analogy with the quotation numerals of section 4\n  it would be straightforward to define quotation truth values\n  and operators and also quotation predicates, conditionals and lists.\n  "),t("p",[e._v("\n    The definitions of Church concepts in Joy,\n    like the corresponding concepts in the lambda calculus,\n    are mainly of theoretical interest.\n    So far none of the definitions have been found useful\n    in practical programming in Joy.\n    Accordingly none of the definitions have been included\n    in any of the libraries.\n    However, the Joy source for this note, without the text,\n    is available on:\n    "),t("a",{attrs:{href:"philosophy/phimvt/joy/jp-church.joy"}},[e._v("jp-church.joy")])]),t("p",[e._v('\n    Church numerals and related matters are treated in many\n    of the more theoretical\n    books dealing with functional languages based on the lambda calculus.\n    There is also a vast literature available online,\n    a web search for "Church numeral" will find many excellent expositions.\n  ')]),t("h1",[e._v("Brent Kerby's elegant and efficient alternative Church numerals")]),t("p",[e._v('\n    Shortly after I put the preceding sections on the web page for Joy,\n    on 9-Oct-2002 Brent Kerby sent a note to the "concatenative" mailing list.\n    The remainder of this section is the first part of his note.\n  ')]),t("pre",[e._v('About the construction of Csucc (which adds one to a church number),\n\n    Csucc ==  [dup [i] dip] dip i.\n\n  this can be simplified a bit:\n\n    Csucc ==  [dup dip] dip i.\n\n  because "dup [i] dip" is the same as "dup dip"; by the way, the "dup dip"\n  combinator is an interesting one; I call it "run", since it in effect\n  executes a program without destroying the program.\n\n  ----------\n  Anyhow, onto the next construction:\n\n    Cadd ==  [ [[Csucc] cons] ] dip i i;\n\n  Here\'s an alternative:\n\n    Cadd == [sip] dip i\n\n  It works like this:\n\n     [p] [m] [n] [sip] dip i\n  == [p] [m] sip [n] i\n  == [p] m [p] [n] i\n  == [p] m [p] n\n\n  ------------\n  Next,\n\n    Cmul ==  [ [[C0]] dip  [Cadd] cons [cons] cons ] dip i i;\n\n  An alternative:\n\n    Cmul == [cons] dip i\n\n  It works like this:\n\n     [p] [m] [n] [cons] dip i\n  == [p] [m] cons [n] i\n  == [[p] m] n\n\n  -----------------\n  Finally,\n\n    Cpow ==  [ [[C1]] dip  [Cmul] cons [cons] cons ] dip i i.\n\n  And, an alternative:\n\n    Cpow == [[cons] cons] dip i i\n\n  Working like this:\n\n     [p] [m] [n] [[cons] cons] dip i i\n  == [p] [m] [cons] cons n i\n  == [p] [[m] cons] n i\n  == [[[[[p] m] m] m] ...] i\n\n  Unfortunately, in this system of church numbers, the Cpow is not a true\n  combinator, only a pseudo-combinator (unlike Csucc, Cadd, and Cmul, which\n  are true combinators).\n  ')]),t("h1",[e._v("Testing Brent Kerby's Church numerals")]),t("pre",[e._v(" # The original definitions, commented away, are given for comparison. \n    # Brent Kerby's new definitions over-ride the old ones. \n     \n    DEFINE \n     \n    #  Csucc ==  [dup [i] dip] dip i; \n       Csucc ==  [dup dip] dip i; \n     \n    #  Cadd ==  [ [[Csucc] cons] ] dip i i; \n       Cadd ==  [sip] dip i;               # but sip needs to be defined: \n                                             sip ==  dupd dip; \n     \n    #  Cmul ==  [ [[C0]] dip  [Cadd] cons [cons] cons ] dip i i; \n       Cmul ==  [cons] dip i; \n     \n    #  Cpow ==  [ [[C1]] dip  [Cmul] cons [cons] cons ] dip i i; \n       Cpow ==  [[cons] cons] dip i i. \n     \n     \n    # Now the old tests using the new definitions: \n     \n    Peano [C2] [C3] Cadd. \n  5\n    Peano [C2] [C3] Cmul. \n  6\n    Peano [C2] [C3] Cpow. \n  8\n     \n    Doublings [C2] [C3] Cadd. \n  32\n    Doublings [C2] [C3] Cmul. \n  64\n    Doublings [C2] [C3] Cpow. \n  256\n     \n    Peano [[[[[C3] Csucc] [C2] Cadd] [C3] Cmul] Csucc] [C2] Cadd . \n  21\n    Peano [[[[[C3] Csucc] [C2] Cadd] [C3] Cmul] Csucc] [C2] Cadd \n                3   succ    2   +      3   *     succ    2   +      = . \n  true\n  ")]),t("h1",[e._v("Another kind of Church numeral, also by Brent Kerby")]),t("p",[e._v("\n    This section is verbatim the second part of his note.\n  ")]),t("pre",[e._v('  \n  By the way, there are several other ways of doing church numbers in Joy. The\n  current way assumes,\n\n    [p] Cn  ==  p p ... p\n\n  But alternatively we could do:\n\n    [p] Rn  ==  p p ... p [p]\n\n  The only difference here is that we save the original program "p". The\n  principal advantage of this approach is that then Rn are reversible\n  combinators (note, Cn were all irreversible combinators since they destroy\n  the original program). We\'d have,\n\n    R0 ==\n    R1 == run\n    R2 == run run\n    R3 == run run run\n    ...\n\n  This is quite an elegant setup, seeing that simply "run" acts as a successor\n   function, and C0 is simply the empty program. Also, the negative church\n  numbers then are\n\n    R-1 == unrun\n    R-2 == unrun unrun\n    R-3 == unrun unrun unrun\n    ...\n\n  Note the reverse of any church number then is simply its negative. Also, to\n  add church numbers is simply to concatenate them. Of course, "cat" itself is\n  irreversible, so we might use "rat":\n\n    [b] [a] rat ==  [b a] [a]\n\n  This is a suitable addition function for the Rn church numbers; notice it\n  preserves one of the parameters, like a reversible addition function should.\n  Also, unlike Cadd, it does not execute the newly formed program (doing so\n  would be irreversible, as "i" is irreversible).\n\n  Here\'s how to multiply these Rn church numbers:\n\n    Rmul == swap cons untack\n\n  It works, for example, like this:\n\n     [2] [3] swap cons untack\n  == [[3] 2] untack\n  == [3 3 [3]] untack\n  == [3 3] [3]\n  == [6] [3]\n\n  So that\'s nice, except that this is not really reversible, since "cons" is\n  not reversible (assuming we have transparent quotation; if we have opaque\n  quotation then "cons" is reversible, but the multiplication then doesn\'t\n  work because "untack" fails):\n\n    [a] [dup] cons    == [[a] dup]  ==  [[a] [a]]\n    [[a] [a]] [] cons == [[a] [a]]\n\n  See how cons can give the same result from different inputs? This means it\n  is irreversible.\n\n  So can Rmul be defined from reversible primitives? If so, we would expect to\n  fail in the case of multiplying by zero, since that is irreversible. Also,\n  having a reversible Rmul would give us the ability to do division, and the\n  ability to construct fractional church numbers. But do fractional church\n  numbers make sense? For example, the church number for 1/2 would have the\n  rule:\n\n    [a a] R1/2  == a [a a]\n\n  In a system with transparent quotation, it seems like R1/2 would not be\n  straightforward to implement, perhaps impossible, since it would require the\n  system to try to coerce an arbitrary "[p]" into the form "[a a]", by using\n  reductions and expansions inside the quotation. But maybe there is some\n  reasonable way to do it ...\n\n  - Brent\n  ')]),t("h1",[e._v("Yet another kind of Church numeral, again by Brent Kerby")]),e._v("\n  Also on 9-Oct-2002 Brent wrote another note,\n  which is reproduced her in full:\n  "),t("pre",[e._v('[ a propos my question: ]\n  > Could you clarify why you say that your Cpow is not a true combinator?\n\n  Well, it\'s pretty simple, really. When we try to write a "reduction rule"\n  for Cpow, the best we can get is this:\n\n    [p] [m] [n] Cpow  ==  [p] [[m] cons] n i\n\n  Note the appearances of "cons" and "i" on the right hand side. This is in\n  essence what makes it a pseudo-combinator. A true combinator has a reduction\n  rule without such things on its right hand side, for example:\n\n          [a] dup   == [a] [a]\n      [b] [a] swap  == [a] [b]\n      [p] [n] Csucc == p [p] n\n  [p] [m] [n] Cadd  == [p] m [p] n\n  [p] [m] [n] Cmul  == [[p] m] n\n\n  See how in all of these the right hand side consists solely of variables,\n  mixed up through concatenation and quotation. That is why they are called\n  true combinators, because they possess a reduction rule of this kind.\n\n  For the curious, there is some interest in a system that contains only true\n  combinators, no pseudo-combinators. Such a system would have to get rid of\n  quotation, since the quotation of any combinator is a pseudo-combinator\n  (e.g., "[dup]" or "[swap]" is a pseudo-combinator, since it possesses no\n  reduction rule). This idea hasn\'t been fully explored, but you might like to\n  look back on the post\n  http://groups.yahoo.com/group/concatenative/message/1051 and other posts\n  thereabouts. The idea is that a workable base is {nil, zap, dup, i, unit,\n  take, cat}:\n\n           nil  == []\n       [a] zap  ==\n       [a] dup  == [a] [a]\n       [a] i    == a\n       [a] unit == [[a]]\n   [b] [a] take == [a [b]]\n   [b] [a] cat  == [b a]\n\n  I suspect that all true combinators can be constructed form these, using\n  concatenation alone (no quotations allowed), and there is very probably a\n  smaller base that will work. Here\'s a few examples of some constructions in\n  this system (a searcher reveals that these are the minimal constructions):\n\n    dip  == take i\n    swap == unit take i\n    flip == unit take take i  (i.e., a combinator that reverses the top 3\n  items)\n    dupd == unit take i unit dup cat take i\n         == unit take i dup unit take take i\n    sip  == unit take i unit dup cat take i take i\n         == unit take i dup unit take take i take i\n\n  More simply, we could have\n\n    dupd == swap dup flip\n    sip  == dupd dip\n\n  [ a propos another question from me: ]\n  > I do remember that in one reference (I cannot remember which, alas)\n  > it was pointed out that exponentiation could be implemented\n  > as applying the exponent n to the base m, but that was\n  > considered "cheating" [sic]. I did not understand that\n  > either, but maybe you are talking about the same thing.\n\n  Yes, in the classical combinatory logic you can exponentiate Church numbers\n  simply by applying them (although it is the base that is applied to the\n  exponent, not the other way around). We can do the same thing in Joy if we\n  reform the Church numbers once more (I\'ll call them Zn, as that is what the\n  Church numbers are standardly called):\n\n    [x] [p] Zn  ==  [[[[[x] p] p] ...] p\n\n  For example,\n\n    [x] [p] Z0  == x\n    [x] [p] Z1  == [x] p\n    [x] [p] Z2  == [[x] p] p\n\n  Note these Church numbers take two parameters as opposed to the one\n  parametered Cn and Rn. Anyhow, we can define the operators then in this way:\n\n       [x] [p] [n] Zsucc ==  [[x] [p] n] p\n   [x] [p] [n] [m] Zadd  ==  [[x] [p] n] [p] m\n   [x] [p] [n] [m] Zmul  ==  [x] [[p] n] m\n   [x] [p] [n] [m] Zpow  ==  [x] [p] [n] m\n\n  Or by construction,\n\n    Zsucc  == [B] S\n    Zadd   == [B] N\n    Zmul   == B\n    Zpow   == i\n\n  where B, S, and N are the classical combinators\n\n      [c] [b] [a] B == [[c] b] a\n      [c] [b] [a] S == [[c] b] [c] a\n  [d] [c] [b] [a] N == [[d] c] [[d] b] a\n\n  See how neat that works, with Zpow being simply "i".\n\n  Anyhow, these Zn seem to be the true analogue of the classical Church\n  numbers, although that\'s not to say that they are necessarily the most\n  appropriate in a concatenative system. But, Zn do have use; for example,\n\n    dip2 == [dip] Z2\n    dip3 == [dip] Z3\n    dip4 == [dip] Z4\n    ...\n\n  See,\n\n     [p] dip3\n  == [p] [dip] Z3\n  == [[[p] dip] dip] dip\n\n  That seems pretty handy.\n  ')])])}]};n.a=a},SIgt:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o=t("3m6o"),a=!1;var i=function(e){a||t("iGon")},s=t("VU/8")(null,o.a,!1,i,"data-v-f0d98270",null);s.options.__file="pages/papers-on-joy/church-arithmetic-and-church-logic-with-brent-kirby.vue",n.default=s.exports},iGon:function(e,n,t){var o=t("su0b");"string"==typeof o&&(o=[[e.i,o,""]]),o.locals&&(e.exports=o.locals);t("rjj0")("09f26425",o,!1,{sourceMap:!1})},su0b:function(e,n,t){(e.exports=t("FZ+f")(!1)).push([e.i,"p[data-v-f0d98270]{margin-top:16px;margin-bottom:16px}hr[data-v-f0d98270]{margin-bottom:16px}pre[data-v-f0d98270]{margin-bottom:auto}code[data-v-f0d98270],kbd[data-v-f0d98270],pre[data-v-f0d98270]{font-family:Roboto Mono,monospace}",""])}});