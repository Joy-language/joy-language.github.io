webpackJsonp([17],{"3LNB":function(e,n,t){var a=t("ACnk");"string"==typeof a&&(a=[[e.i,a,""]]),a.locals&&(e.exports=a.locals);t("rjj0")("25d47851",a,!1,{sourceMap:!1})},ACnk:function(e,n,t){(e.exports=t("FZ+f")(!1)).push([e.i,"p[data-v-64eeae48]{margin-top:16px;margin-bottom:16px}hr[data-v-64eeae48]{margin-bottom:16px}pre[data-v-64eeae48]{margin-bottom:auto}code[data-v-64eeae48],kbd[data-v-64eeae48],pre[data-v-64eeae48]{font-family:Roboto Mono,monospace}",""])},GDJK:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a=t("pzzD"),i=!1;var o=function(e){i||t("3LNB")},s=t("VU/8")(null,a.a,!1,o,"data-v-64eeae48",null);s.options.__file="pages/papers-on-joy/joy-compared-with-other-functional-languages.vue",n.default=s.exports},pzzD:function(e,n,t){"use strict";var a=function(){var e=this.$createElement;this._self._c;return this._m(0)};a._withStripped=!0;var i={render:a,staticRenderFns:[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("article",[e._v("\n  Joy compared with other functional languages\n  "),t("p",[e._v("\n    By Manfred von Thun\n  ")]),t("p",[e._v("\n    Joy is a functional programming language\n    which is not based on the application\n    of functions to arguments\n    but on the composition of functions.\n    This paper compares and contrasts Joy with\n    the theoretical basis of other functional formalisms\n    and the programming languages based on them.\n    One group comprises the lambda calculus\n    and the programming languages Lisp, ML and Miranda.\n    Another comprises combinatory logic and the language FP by Backus.\n    A third comprises Cartesian closed categories.\n    The paper concludes that Joy is\n    significantly different from any of these formalisms\n    and programming languages.\n  ")]),t("h1",[e._v("Introduction")]),t("p",[e._v("\n    This paper outlines the principal\n    similarities and differences between Joy\n    and other high-level and low-level functional languages.\n  ")]),t("p",[e._v("\n    The best known functional languages\n    are the "),t("em",[e._v("lambda calculus")]),e._v(" and, based on it,\n    the programming languages Lisp\n    and its descendants.\n    All of them rely heavily on two operations,\n    abstraction and application,\n    which are in some sense inverses of each other.\n    Abstraction binds free variables in an expression,\n    and it yields a function which is a first class value.\n    The bound variables are the formal parameters of the function,\n    and, importantly, they are named.\n    Application of an abstracted function to some actual parameters\n    can be understood as resulting in a substitution\n    of actual for formal parameters and then evaluation\n    of the modified expression.\n    More efficiently application can be implemented using an "),t("em",[e._v("environment")]),e._v("\n    of name-value pairs.\n    The lambda calculus\n    does not need definitions,\n    but all functional programming languages allow them as a matter\n    of convenience.\n    Definitions also use named formal parameters,\n    and in applications these have to be substituted\n    or an environment has to be maintained.\n  ")]),t("p",[e._v("\n    Two other functional languages are the "),t("em",[e._v("combinatory logic")]),e._v(" of Curry\n    and the "),t("em",[e._v("FP system")]),e._v(" of Backus.\n    They are not based on the lambda calculus,\n    they eliminate abstraction completely and hence\n    do not have to deal with substitution and environments.\n    As a result these languages can be manipulated using simple\n    algebraic techniques.\n    But like the lambda calculus and the languages derived from it,\n    both are based on the application of functions to arguments.\n    However, application does not have attractive algebraic properties,\n    and hence there is no theoretical reason for preferring\n    one concrete notation over another.\n  ")]),t("p",[e._v("\n    The languages of "),t("em",[e._v("category")]),e._v(" theory comprises another group of functional\n    languages.\n    Whereas the other functional languages use function application,\n    these use function composition.\n    No high level programming language has been based on this formalism,\n    but it has been used as a low level machine language\n    as a target for compilation from a (typed) lambda calculus source.\n    Joy is a high level programming language which\n    resembles the categorical languages more than it resembles\n    any of the other functional languages.\n  ")]),t("p",[e._v("\n    The remainder of this paper is organised as follows:\n    The next section gives an overview of the lambda calculus\n    and of the programming languages that are based on it.\n    The section after that describes combinatory logic\n    which eliminates lambda abstraction.\n    Following that is a section on the FP language of Backus.\n    The next section then outlines the language of categories\n    in which even function application is eliminated.\n    In each of these sections the principal difference\n    between these systems and Joy is outlined.\n    There is also a final section on programming in the large;\n    most structuring devices could be adapted to Joy in the future.\n  ")]),t("h1",[e._v("The lambda calculus and its descendants")]),t("p",[e._v("\n    For the present purposes is is sufficient\n    to consider only the "),t("em",[e._v("abstract syntax")]),e._v(" of the lambda calculus.\n    A "),t("em",[e._v("lambda expression")]),e._v(" is built from variables and constants\n    by two constructions, abstraction and application.\n    Constants are values such as number or lists,\n    or they are functions such as addition and concatenation.\n    In an expression an occurrence of a variable can be "),t("em",[e._v("free")]),e._v("\n    or "),t("em",[e._v("bound")]),e._v(".\n    Specifically in an expression consisting of just a variable\n    that variable occurs free.\n    In an expression consisting just of a constant\n    there are no variables at all.\n    An expression which is a "),t("em",[e._v("lambda abstraction")]),e._v("\n    consists of a variable and a body which is an expression.\n    The abstraction construction binds any free occurrences\n    of that variable in the body.\n    An expression which is an "),t("em",[e._v("application")]),e._v("\n    consists of two expressions,\n    the function and the argument (or actual parameter).\n    Occurrences of free and bound variables in the\n    function and the argument are also free and bound in the applicative expression.\n  ")]),t("p",[e._v("\n    Functions of several variables can be abstracted\n    by successive abstractions,\n    and they can be applied to several arguments\n    by successive applications.\n    Each application returns a function of one less\n    argument than the original.\n    This device of replacing standard functions by their "),t("em",[e._v("curried")]),e._v(" form\n    allows the theory to concentrate exclusively\n    on functions of one argument.\n  ")]),t("p",[e._v("\n    Incidentally,\n    a similar effect is achieved in Joy not by application\n    but by "),t("em",[e._v("composition")]),e._v(".\n    The program\n  ")]),t("pre",[e._v("        3  +\n  ")]),e._v("\n  denotes the composition of two functions from stacks to stacks.\n  The first pushes the number 3,\n  the second adds two number on top of the stack.\n  The entire program denotes a function which adds 3\n  to the top number of the stack.\n  The space between the 3 and the "),t("code",[e._v("+")]),e._v(" is not application \n  written in reverse but composition.\n  "),t("p",[e._v("\n    The "),t("em",[e._v("lambda calculus")]),e._v(" uses several syntactic operations called\n    "),t("em",[e._v("reduction")]),e._v("s.\n    The most important of these is "),t("em",[e._v("beta reduction")]),e._v("\n    of applicative expressions.\n    If the function is an abstraction\n    then the applicative expression\n    reduces to the body of the function\n    but with all free occurrences of the abstracted variable\n    replaced by the argument of the application.\n    Beta reduction corresponds exactly to calling a function\n    in the terminology of programming languages.\n    The difference with Joy is already apparent here,\n    since Joy does not have any variables to be used in abstractions\n    and beta reduction does not occur in Joy.\n  ")]),t("p",[e._v("\n    Abstraction creates anonymous functions,\n    and the pure lambda calculus does not have any facility\n    for defining functions.\n    In particular, it cannot be used to give "),t("em",[e._v("recursive definition")]),e._v("s\n    of functions.\n    But to compute recursive functions it is possible\n    to introduce a single device,\n    the "),t("em",[e._v("Y combinator")]),e._v(".\n    This might have been defined recursively if that were possible,\n    or it can be provided as one of the constants.\n    However, it also turns out to be equivalent to a particular\n    lambda expression.\n  ")]),t("p",[e._v("\n    The simple lambda calculus can therefore be used to compute\n    all recursive functions,\n    and hence to compute any function that can be computed by a\n    "),t("em",[e._v("Turing machine")]),e._v(".\n    Even constants are not really necessary,\n    since truth values, numerals, list operations\n    and the like can be expressed as particular lambda expressions.\n    It comes as a surprise that all "),t("em",[e._v("computable function")]),e._v("s\n    can be expressed in the lambda calculus with just variables, abstraction\n    and application, and can then be computed by reduction.\n    However,\n    any efficient implementation will need constants,\n    and all practical programming languages based\n    on the lambda calculus provide them.\n  ")]),t("p",[e._v("\n    The lambda calculus can be extended with simple "),t("em",[e._v("let-expression")]),e._v("s\n    and recursive "),t("em",[e._v("letrec-expression")]),e._v("s\n    and with definitions.\n    The additions make programming significantly easier,\n    and this is approximately the level\n    of the core of (pure) "),t("em",[e._v("Lisp")]),e._v(" and its earlier descendants.\n  ")]),t("p",[e._v("\n    Other extensions are "),t("em",[e._v("pattern matching")]),e._v(" of formal and actual\n    parameters,\n    and static but "),t("em",[e._v("polymorphic")]),e._v(" type checking.\n    The best known functional programming languages\n    that have these features are "),t("em",[e._v("ML")]),e._v(" and \n    "),t("em",[e._v("Miranda")]),e._v(".\n    Being descendants of Lisp and ultimately the lambda calculus,\n    they are also based on abstraction and application.\n  ")]),t("p",[e._v("\n    Peyton Jones (1987 Chapter 2) \n    contains a good exposition to the lambda calculus,\n    including many extensions.\n    The survey paper\n    Hudak (1989) \n    compares many features of different functional languages,\n    with a minor emphasis on "),t("em",[e._v("Haskell")]),e._v(".\n    A very elegant general introduction to modern functional programming\n    in a non-Lisp language can be found in\n    Hughes (1990) .\n    A recent introduction to Miranda\n    is in\n    Turner (1990) .\n  ")]),t("p",[e._v("\n    A notable variation on the lambda calculus is described in\n    Cartwright (1991) .\n    Normally the binding operators (such as lambda )\n    are special forms rather than operators in a semantic algebra.\n    Here lambda is taken to be a true function;\n    the universe of models is enlarged to include\n    environments,\n    and variables are interpreted as selector functions mapping\n    environments to values.\n  ")]),t("p",[e._v('\n    All languages mentioned in this section were based\n    on application and abstraction.\n    By contrast, Joy uses neither of these,\n    instead it is based on composition and quotation.\n    Brus   et al (1987 p 364) \n    write "if one wants to have a computational model\n    for functional languages which is also close to their implementations,\n    pure lambda calculus is not the obvious choice anymore".\n    They present the language '),t("em",[e._v("Clean")]),e._v(" in which programs\n    consist of rewrite rules (for graphs)\n    using pattern matching extensively.\n    The implementation uses the rewrite rules\n    more or less directly.\n    Joy accepts the spirit of the above quotation,\n    but draws a very different consequence.\n  ")]),t("h1",[e._v("Combinatory logic")]),t("p",[e._v('\n    Robinson (1969 p 125) \n    remarked:\n    "whatever can be expressed in a language based on application\n    '),t("em",[e._v(" and")]),e._v(" abstraction as fundamental notions\n    can be expressed in a far simpler language\n    "),t("em",[e._v(" based on application alone")]),e._v('."\n    The simpler language is '),t("em",[e._v("combinatory logic")]),e._v('.\n    It is not a way of doing logic in a combinatory way,\n    but it deals with the logic of combinators\n    which denote higher order functions.\n    The key idea came from\n    Sch\\"{o}nfinkel (1924) \n    but was greatly expanded by Curry.\n    The classic reference,\n    Curry and Feys (1958) \n    uses the same notation as is used today.\n    A recent short exposition of the basic combinators is given for example in\n    Henson (1987) .\n  ')]),t("p",[e._v("\n    The calculus of combinators can be understood without reference\n    to its connection with the lambda calculus,\n    as indeed it is done in many expositions.\n    But for the present purposes it is best to keep\n    in mind the goal of eliminating abstraction from the lambda calculus\n    while retaining "),t("em",[e._v("Turing completeness")]),e._v(".\n  ")]),t("p",[e._v("\n    Abstraction is a construction in the "),t("em",[e._v("object language")]),e._v(",\n    the lambda calculus.\n    In combinatory logic this construction is replaced by\n    an operation in the "),t("em",[e._v("metalanguage")]),e._v(".\n    This new operation is called "),t("em",[e._v("bracket abstraction")]),e._v(".\n    It takes an object language variable\n    and an object language expression as arguments\n    and it yields a new object language expression as value.\n    The new expression will contain some function symbols\n    specific to combinatory logic.\n    If all object language lambda abstraction are removed from\n    a lambda expression by this process of metalanguage bracket abstraction,\n    then the final result will be equivalent to the original expression.\n    So this process should be seen as a compilation.\n    Since all lambda calculus expressions can be compiled in this manner,\n    the language of combinators is again Turing complete.\n  ")]),t("p",[e._v("\n    The astonishing feature of this compilation is that it only needs\n    two new function constants or combinators.\n    However, to understand the rationale,\n    it is best to start with three combinators.\n    The three arise naturally from considering\n    the cases of lambda expressions\n    on which bracket abstraction with respect to a variable\n    is to be performed.\n    These will be lambda expressions without lambda abstractions,\n    so they are just variables or applications.\n  ")]),t("p",[e._v("\n    Let "),t("code",[e._v("x")]),e._v(" be the variable to be abstracted.\n    1) If the expression is the same variable "),t("code",[e._v("x")]),e._v(",\n    then the bracket abstraction should give the  "),t("em",[e._v("identity function")]),e._v("\n    which just returns its argument.\n    So the unary "),t("em",[e._v("I combinator")]),e._v(" is introduced as the translation,\n    it will receive its argument only when the abstracted\n    expression is applied.\n    2) If the expression is a different variable "),t("code",[e._v("y")]),e._v(",\n    then the abstraction should give a constant function\n    which ignores its argument "),t("code",[e._v("x")]),e._v(" and just returns "),t("code",[e._v("y")]),e._v(".\n    A single binary "),t("em",[e._v("K combinator")]),e._v(" is introduced\n    and given the argument "),t("code",[e._v("y")]),e._v(".\n    The translation will receive its second argument\n    only when the abstracted expressions is applied,\n    and then it will ignore that argument.\n    3)\n    If the expression is an application of a function "),t("code",[e._v("f")]),e._v("\n    to an argument "),t("code",[e._v("g")]),e._v(",\n    then both the function and the argument first have to be\n    abstracted with respect to "),t("code",[e._v("x")]),e._v(",\n    The final bracket abstraction will be applied to an argument\n    and then it has to make this argument available to both\n    subabstracts.\n    A ternary "),t("em",[e._v("S combinator")]),e._v(" is introduced\n    which does just that.\n    It is given as arguments the two subabstract from "),t("code",[e._v("f")]),e._v(" and "),t("code",[e._v("g")]),e._v(".\n    The translation will receive its third argument\n    only when the translation is applied to its argument.\n    At that point it will supply that argument to\n    the translation of "),t("code",[e._v("f")]),e._v(" and "),t("code",[e._v("g")]),e._v("\n    and then apply the result from "),t("code",[e._v("f")]),e._v(" to the result from "),t("code",[e._v("g")]),e._v(".\n  ")]),t("p",[e._v("\n    These are the three principal combinators arising naturally.\n    It so happens that the I combinator can actually be defined\n    in terms of the other two.\n    So any lambda calculus expression can be translated\n    into a combinatory expression in which\n    there are no variables but just two combinators K and S.\n    Since lambda calculus even "),t("em",[e._v(" without constants")]),e._v("\n    is Turing complete,\n    combinatory logic with just K and S and "),t("em",[e._v(" no other constants")]),e._v("\n    is also Turing complete.\n    This is all the more surprising since\n    an expression consisting exclusively of K and S\n    is really just a tree in which the leaves hold only one bit.\n  ")]),t("p",[e._v("\n    Here are some links to web pages.\n    An introduction to combinatory calculus, by Brent Kerby,\n    a valued contributor to the concatenative mailing group:\n  ")]),t("ul",[t("li",[t("a",{attrs:{href:"http://tunes.org/~iepos/introduction-to-logic/chap00/sect00.html"}},[e._v("Functions and Currying")])]),t("li",[t("a",{attrs:{href:"http://tunes.org/~iepos/introduction-to-logic/chap00/sect01.html"}},[e._v("Common Combinators: B, C, W, K, I, S")])]),t("li",[t("a",{attrs:{href:"http://tunes.org/~iepos/introduction-to-logic/chap00/sect02.html"}},[e._v("Lambda Construct and Completeness")])]),t("li",[t("a",{attrs:{href:"http://tunes.org/~iepos/introduction-to-logic/chap00/sect03.html"}},[e._v("Iterators: Combinatory Numbers")])]),t("li",[t("a",{attrs:{href:"http://tunes.org/~iepos/introduction-to-logic/chap00/sect04.html"}},[e._v("Other Interesting Combinators")])])]),e._v("\n  Another interesting discussion on combinators, by Peter Hancock:\n  "),t("ul",[t("li",[t("a",{attrs:{href:"http://www.dcs.ed.ac.uk/home/pgh/arithmetic.lhs"}},[e._v("\n      AMEN combinators")])])]),t("p",[e._v("\n    The simple compilation scheme yields translations\n    whose length can be exponential\n    in the length of the source expression.\n    Optimisations have been known for a long time\n    which produce translations of only quadratic length.\n    These optimisations use further combinators that are\n    special cases of the S combinator.\n    But the size of the translation result was still\n    prohibitive for any but the smallest lambda expressions.\n  ")]),t("p",[e._v("\n    Turner (1979) \n    introduced some optimisations\n    into the standard translator from lambda calculus\n    to combinator notation.\n    With these optimisations the size of the combinatory code\n    was kept within an acceptable limit.\n    The interpreter for the combinatory code\n    used "),t("em",[e._v("normal graph reduction")]),e._v(",\n    one form of "),t("em",[e._v("lazy implementation")]),e._v("\n    in which actual parameters are evaluated only once.\n    Turner's implementation method using combinators has been used\n    to build a hardware reduction machine,\n    the "),t("em",[e._v("CURRY chip")]),e._v(", see\n    Ramsdell (1986) .\n  ")]),t("p",[e._v("\n    Peyton Jones (1987 Chapter 16) \n    contains a good exposition on the translation\n    from the lambda calculus to combinators\n    and many details of the implementation of Miranda.\n    Hindley and Seldin (1986) \n    provide a very complete parallel account\n    of the lambda calculus, combinatory logic and their relationship.\n    Robinson (1969) \n    shows how the language of Sch\\\"{o}nfinkel and Curry\n    can be used in the mechanisation\n    of theorem proving in higher order logic.\n    Fradet and Le M\\'{e}tayer (1989) \n    show how to compile lambda calculus into conventional machine code.\n    Fradet (1991) \n    uses what are described as low level indexed combinators\n    as a target language to implement a lambda calculus language.\n    Expressions using these combinators lend themselves to rewriting techniques,\n    including optimisations.\n    Impressive execution times are reported.\n    The target code is again not intended to be read by human users.\n  ")]),t("p",[e._v("\n    The variables of the lambda calculus\n    are very similar to the variables of predicate logic.\n    The notions of free and bound variables are essentially the same\n    in both fields,\n    and so is the operation of substituting a term\n    for a free variable.\n    Henkin, Monk and Tarski (1971) \n    show how simultaneous substitution for variables\n    can be eliminated in terms of the "),t("em",[e._v("identity relation")]),e._v(".\n    The idea is that every formula which uses variables\n    in some arbitrary order\n    is replaced by another formula in which all variables\n    occur exactly once and in strictly alphabetical order.\n    The replacement formula will typically contain\n    more variables than the original.\n    The replacement formula is then to be conjoined with several\n    identity sentences of the form "),t("code",[e._v("x=y")]),e._v(".\n    It can be shown that the resulting conjunction is\n    logically equivalent to the original formula.\n    It may be that this idea can be adapted to the lambda calculus.\n    As an implementation technique it would amount to\n    something like this:\n    A lambda term is replaced by another term using consecutive\n    variables, and the replacement is associated with\n    some identity statements which guide the values.\n    There may be some connection with "),t("em",[e._v("director strings")]),e._v("\n    used in some implementations of functional languages,\n    (see for example\n    Peyton Jones (1987 p 274) ).\n    But it is unlikely that a high level programming\n    language could be designed which uses these principles.\n  ")]),t("h1",[e._v("Combinatory logic and Joy")]),t("p",[e._v("\n    The difference between combinatory logic and Joy is best explained\n    by a simple example.\n    To multiply two numbers, say "),t("code",[e._v("2")]),e._v(" and "),t("code",[e._v("3")]),e._v(", in Joy one writes\n  ")]),t("pre",[e._v("        2  3  *\n  ")]),e._v("\n  In combinatory logic one writes\n  "),t("pre",[e._v("        *  2  3\n  ")]),e._v("\n  and there seems to be no significant difference between the two notations\n  apart from the order of operators and operands.\n  But this is deceptive.\n  In combinatory logic a two-argument function like multiplication\n  is understood to be "),t("em",[e._v("curried")]),e._v(".\n  The binary "),t("code",[e._v("*")]),e._v(" function is first applied to "),t("code",[e._v("2")]),e._v(",\n  yielding a function which doubles its argument.\n  That function is then applied to "),t("code",[e._v("3")]),e._v(" yielding the result "),t("code",[e._v("6")]),e._v(".\n  Fully parenthesised the expression is\n  "),t("pre",[e._v("        (* 2)  3\n  ")]),e._v("\n  However, the convention is that application associates to the left,\n  so the parentheses are not needed.\n  "),t("p",[e._v("\n    To compute the square of a number, say "),t("code",[e._v("3")]),e._v(", it has to be multiplied by itself.\n    In combinatory logic and in Joy one can write, respectively,\n  ")]),t("pre",[e._v("        *  3  3                                  3  3  *\n  ")]),e._v("\n  But in both notations it is possible to modify the\n  binary multiplication\n  function to turn it into the unary squaring function.\n  In combinatory logic the "),t("em",[e._v("W combinator")]),e._v("\n  can be applied to a function which then duplicates the (first)\n  argument of the function.\n  It is defined by\n  "),t("pre",[e._v("        (W f) x   =   (f x) x\n  ")]),e._v("\n  Again the parentheses are not needed.\n  So the square of "),t("code",[e._v("3")]),e._v(" is given by\n  "),t("pre",[e._v("        (W *) 3\n  ")]),e._v("\n  In Joy the simplest way to compute the square of "),t("code",[e._v("3")]),e._v(" is by\n  "),t("pre",[e._v("        3  dup  *\n  ")]),e._v("\n  To facilitate the comparison between the two languages it is also\n  possible to define a "),e._v('< kbd="" combinator="" in="" joy:="" '),e._v('="">\n  w   ==   [dup] dip\n  Then the square of '),t("code",[e._v("3")]),e._v(" is also computed in Joy by\n  "),t("pre",[e._v("        3  [*]  w\n  ")]),t("p",[e._v("\n    In both languages one can introduce a mapping combinator to apply\n    a function to a list.\n    In the examples to follow the list will be just "),t("code",[e._v("[1 2 3 4]")]),e._v(".\n    In combinatory logic one might define a "),t("em",[e._v("Map combinator")]),e._v(" by\n  ")]),t("pre",[e._v("        Map  f  []   =   []\n          Map  f  [X | Xs}   =   [f X | Map f Xs]\n  ")]),e._v("\n  where the bar "),t("code",[e._v("|")]),e._v(" separates the first element of the list\n  from the rest.\n  Then the list of squares of the given list is computed by\n  "),t("pre",[e._v("        Map  (W *)  [1 2 3 4]\n  ")]),e._v("\n  Note that the parentheses around "),t("code",[e._v("(X *)")]),e._v(" are necessary.\n  The same computation is expressed in Joy by\n  "),t("pre",[e._v("        [1 2 3 4]  [[*] w]  map\n  ")]),e._v("\n  Superficially one version is just the reverse of the other.\n  Combinatory logic uses prefix notation,\n  and Joy uses what looks like postfix notation.\n  "),t("p",[e._v("\n    But the apparent similarity is deceptive.\n    To see this it will help to write both versions with the hidden\n    operators made explicit.\n    In combinatory logic the hidden binary operator is "),t("em",[e._v("application")]),e._v("\n    of a function to an argument,\n    which might be written explicitly as infix "),t("code",[e._v('"@"')]),e._v(".\n    Fully parenthesised the combinatory version thus is\n  ")]),t("pre",[e._v("        (Map  @  (W  @ *))  @  [1 2 3 4]\n  ")]),e._v("\n  In Joy the hidden binary operator is "),t("em",[e._v("composition")]),e._v("\n  of functions,\n  which might be written explicitly as infix "),t("code",[e._v('"."')]),e._v(".\n  The Joy version thus is\n  "),t("pre",[e._v("        [1 2 3 4]  .  [[*]  .  w]  .  map\n  ")]),e._v("\n  There are as many compositions in the Joy version as there are\n  applications in the combinatory logic version.\n  Since composition is associative, it does not matter how the\n  expression is parenthesised.\n  "),t("p",[e._v("\n    Because of associativity the following is also meaningful in Joy:\n  ")]),t("pre",[e._v("        [1 2 3 4]  .  [[*]  .  w]\n  ")]),e._v("\n  It denotes a function which pushes two items,\n  a list and a quotation, onto the stack.\n  By contrast its combinatory counterpart\n  "),t("pre",[e._v("        (W  @  *)  @  [1 2 3 4]\n  ")]),e._v("\n  is not meaningful.\n  This is because the squaring function on the left,\n  "),t("code",[e._v("(W @ *)")]),e._v(",\n  expects to be applied to a "),t("em",[e._v(" number")]),e._v(" on the right,\n  and not a "),t("em",[e._v(" list")]),e._v(".\n  "),t("p",[e._v("\n    Another way of noting the difference between combinatory logic and\n    Joy is in the following equations,\n    here again with application and composition left implicit:\n  ")]),t("pre",[e._v("        Map  (W  *)  [1 2 3 4]   =   [1 4 9 16]\n          [1 2 3 4]  [[*] w]  map   ==   [1 4 9 16]\n  ")]),e._v("\n  The combinatory logic version denotes the identity of objects,\n  in this case lists.\n  The Joy version denotes the identity of functions,\n  in this case functions which,\n  when applied to a stack, will push a list.\n  Stacks are the arguments to which all Joy functions are applied,\n  but this application plays no role in the construction of programs.\n  By contrast, application is the principal program constructor\n  in combinatory logic,\n  even if the application operator is left implicit.\n  "),t("p",[e._v("\n    Wald (1993) \n    develops a theory of 'unary pairfunctions'\n    with primitives "),t("code",[e._v("L")]),e._v(", "),t("code",[e._v("S")]),e._v(", "),t("code",[e._v("D")]),e._v(" and "),t("code",[e._v("B")]),e._v("\n    satisfying\n  ")]),t("pre",[e._v("    L(<a,b>) = a                    S(<a,b>) = <b,a>\n          D(a) = <a,a>                    B(<a,<b,c>>) = <<a,b>,c>\n  ")]),e._v("\n  He gives a finite presentation (69 axioms)\n  of a "),t("em",[e._v("semigroup")]),e._v(" of such functions under composition.\n  The theory is not intended as the basis of an implementation,\n  but it would appear that there are some connections\n  with Joy that are worth exploring.\n  "),t("h1",[e._v("Backus' FP systems")]),t("p",[e._v("\n    In his Turing award lecture\n    Backus (1978) \n    introduced his "),t("em",[e._v("FP system")]),e._v(',\n    short for "Functional Programming system".\n    The system is not about programming using functions,\n    as Lisp and its descendents are,\n    but about programming with functionals,\n    also known as higher order functions or\n    combinators or, in his terminology, '),t("em",[e._v(" functional forms")]),e._v(".\n  ")]),t("p",[e._v("\n    Backus builds his FP systems on three kinds of entities.\n    Firstly, there are "),t("em",[e._v("object")]),e._v("s.\n    These are built recursively from atomic objects such as\n    truth values and numbers,\n    and the only constructor is that of forming sequences or lists of objects.\n    Secondly there are "),t("em",[e._v("primitive function")]),e._v("s.\n    These comprise the usual arithmetic operations and relations\n    and several powerful operations on lists.\n    Importantly all primitive functions are unary functions\n    technically,\n    since functions requiring several arguments are provided\n    with a single list of these arguments.\n    Furthermore, all functions are first order.\n    Thirdly there are "),t("em",[e._v("functional form")]),e._v("s,\n    and these are the essential novelty of the system.\n    They are second order functions used to build\n    more complex functions from simpler ones.\n    Since all primitive functions are unary,\n    and the combining forms preserve this property,\n    all functions in the system are unary.\n    Combining forms, however,\n    can have several functions as parameters.\n    In detail, the combining forms are as follows.\n  ")]),t("p",[e._v("\n    The "),t("em",[e._v("composition form")]),e._v(" requires two functions.\n    The resulting functions is that function which applied\n    to its argument always gives the same value\n    as applying first the one function and then the other.\n    The "),t("em",[e._v("conditional form")]),e._v(" takes three functions as parameters,\n    an if-function, a then-function and an else-function.\n    The if-function is applied to the argument,\n    if that yields true the the value returned is that\n    given by applying the then-function,\n    otherwise it is that of applying the else-function.\n    The "),t("em",[e._v("construction form")]),e._v(" takes as single parameter\n    a list of functions.\n    Applied to one argument the resulting function\n    returns a list of values,\n    each obtained by applying the functions to the argument.\n    The "),t("em",[e._v("apply-to-all form")]),e._v("\n    is essentially the same as "),e._v('< kbd="" in="" other="" languages.="" it="" takes="" a="" single="" function="" as="" parameter.="" the="" resulting="" can="" only="" be="" applied="" to="" list,="" and="" then="" returns="" list="" of="" values="" obtained="" by="" applying="" parameter="" each="" member="" list.="" construction="" apply-to-all="" are="" some="" sense="" complementary.="" '),e._v('="">insert form is sometimes called\n    '),t("em",[e._v("reduce")]),e._v(" or "),e._v('< kbd="" in="" other="" languages.="" it="" also="" takes="" a="" single="" function="" as="" parameter,="" one="" which="" pairs="" arguments.="" the="" resulting="" can="" be="" applied="" to="" non-empty="" list,="" and="" then="" returns="" object="" obtained="" by="" applying="" parameter="" repeatedly="" adjacent="" members="" of="" list="" argument.="" finally,="" '),e._v('="">constant form\n    takes as parameter an object\n    (considered as a function of no arguments).\n    The resulting unary function ignores its argument\n    and always returns the parameter object.\n    There is no facility for user-defined forms;\n    Backus held the view that this would lead to obscure programs.\n    However, new functions may be defined, even recursively.\n    ')]),t("p",[e._v("\n    The combining forms as operations on unary functions\n    constitute a rich but unfamiliar algebra.\n    Importantly, the arguments of the functions\n    do not play any role at all.\n    Backus gives an elaborate axiomatisation of the algebra;\n    in  Williams (1982)  a smaller version is given\n    comprising just 11 axioms.\n    Two axioms deal with the interplay between composition and conditional,\n    two deal with composition, construction and insert,\n    and one deals with just composition and construction.\n    Two deal with construction and indexing into a list.\n    Another concerns nested conditionals with the same if-function.\n    Two deal with the "),t("em",[e._v(" append-left")]),e._v(" function\n    (elsewhere known as "),t("kbd",[e._v("cons")]),e._v(")\n    and the apply-to-all form.\n    A final one deals with composition and constant.\n    As may be seen, each combining form\n    has a significant relationship\n    with at least some other combining form.\n  ")]),t("p",[e._v("\n    The FP system is further explained and expanded in\n    Williams (1982) .\n    A very useful exposition to the FP systems is found in\n    Henson (1987 Chapter 5) .\n    The book also gives a very extensive bibliography.\n    For a good exposition to the\n    relation between the lambda calculus, combinatory logic\n    and the FP systems of Backus see\n    Revesz (1988 section 5.3) .\n    Givler and Kieburtz (1984) \n    present methods for automatically and reliably\n    transforming clear and correct\n    but possibly inefficient FP programs\n    into possibly obscure but efficient equivalent programs.\n    Bellegarde (1984) \n    presents a set of convergent rewriting rules\n    for the algebra of FP programs but without conditionals.\n    Whereas FP is a "),t("em",[e._v("strict")]),e._v(' language,\n    Dosch and M\\"{o}ller (1984) \n    describe the algebraic semantics of a '),t("em",[e._v("lenient")]),e._v(" variant of FP\n    allowing infinite objects\n    and using both busy and lazy evaluation.\n    Sheeran (1984) \n    uses a variant of FP as a VLSI design language\n    for describing semantics and physical layout of hardware.\n    For a critique of the FP systems, see\n    Harland (1984 section 18.4) .\n  ")]),t("p",[e._v("\n    A recent descendant of the FP system by Backus\n    is the "),t("em",[e._v("FL language")]),e._v(" described in\n    Backus, Williams and Wimmers (1990) \n    Another variant is the language "),t("em",[e._v("GRAAL")]),e._v('\n    which implements ("infinite") streams\n    using call-by-need;\n    it is described in\n    Bellot and Robinet (1985) .\n  ')]),t("p",[e._v("\n    In FP there are three kinds of semantic entities,\n    the objects, the functions and the combining forms.\n    They correspond fairly well to three kinds of functions in Joy:\n    those denoted by literals,\n    by operators and by combinators.\n    But the Joy functions are all of the same kind,\n    they are functions taking one stack as argument\n    and giving a new stack as value.\n    In FP combining forms are applied to functions\n    and the resulting functions are applied to objects.\n    In Joy there is no "),t("em",[e._v("application")]),e._v(" of functions to arguments at all,\n    there is just "),t("em",[e._v("composition")]),e._v(" of functions.\n    In FP the function parameters of combining forms cannot depend\n    on any objects supplied\n    as arguments to functions.\n    In Joy the "),t("em",[e._v("quotation")]),e._v(" parameters of combinators\n    can be manipulated at run time.\n    Hence it is possible to call "),t("em",[e._v("constructed program")]),e._v("s\n    which have been built on the fly.\n  ")]),t("p",[e._v("\n    In his Turing award lecture Backus also introduces another language,\n    "),t("em",[e._v("FFP system")]),e._v(', short for "Formal Functional Programming system".\n    In addition to objects as in FP there are now explicit expressions.\n    In addition to the listforming constructor as in FP\n    there is now a new binary constructor to form '),t("em",[e._v("application")]),e._v("s\n    consisting of an operator and an operand.\n    Operator expressions which are atoms of course denote functions\n    which can be applied to an argument.\n    Operator expressions which are lists must have as their first\n    element an expression denoting a function.\n    When such an expression is applied to an argument,\n    the function is applied to a pair consisting\n    of the original list and the argument.\n  ")]),t("p",[e._v("\n    This last rule, "),t("em",[e._v("metacomposition")]),e._v(", is immensely powerful.\n    It can be used to define arbitrary new functional forms,\n    including of course the fixed forms from FP.\n    The rule also makes it possible to compute recursive functions\n    without a recursive definition.\n    This is because in the application\n    the functions is applied to a pair which includes the original\n    list operand which in turn contains as its first element\n    the expression denoting the very same function.\n    The method is considerably simpler than the\n    use of the "),t("em",[e._v("Y combinator")]),e._v(".\n    Williams (1982) \n    extends the method to mutually recursive functions,\n    even ones that are not "),t("em",[e._v("primitive recursive")]),e._v(".\n  ")]),t("p",[e._v("\n    Joy is in fact closer to FFP than any of the languages mentioned\n    so far.\n    Both replace abstraction by other mechanisms,\n    both rely heavily on higher order functions,\n    and both obey the principle that "),t("em",[e._v("program = data")]),e._v(".\n    Both permit construction of first order\n    and higher order recursive and non-recursive functions\n    without ever using named formal parameters.\n    An effect similar to metacomposition\n    is achieved in Joy with the "),e._v('< kbd=""> combinator,\n    which expects a quoted program on top of the stack\n    and executes it without popping it off.\n    ')]),t("p",[e._v("\n    One important difference is that FFP still uses "),t("em",[e._v("application")]),e._v("\n    as an essential operation,\n    whereas Joy uses "),t("em",[e._v("composition")]),e._v(".\n    It appears that this makes the algebra of Joy considerably simpler.\n  ")]),t("h1",[e._v("Categorical combinators")]),t("p",[e._v('\n    Meertens (1989 p 72) \n    speaks of\n    "the need of a suitable system of combinators\n    for making functions out of component functions\n    without introducing extra names in the process.\n    Composition should be the major method, and not application."\n  ')]),t("p",[e._v("\n    Meertens (1989 p 71)  writes\n    \"The basic problem is that the basic operation of the classical combinator\n    calculus (and also of the closely related lambda calculus)\n    is application instead of composition.\n    Application has not a single property.\n    Function composition is associative\n    and has an identity element\n    (if one believes in the 'generic' identity function).\"\n    He develops a system of combining functions\n    that is more suitable to formal manipulation\n    than the classical combinators.\n    It is worth noting that in "),t("em",[e._v("monad")]),e._v("s\n    the monadic composition operator is associative.\n  ")]),t("p",[e._v("\n    A "),t("em",[e._v("category")]),e._v(" consists of a collection of "),t("em",[e._v("object")]),e._v("s\n    and for any two objects a collection of "),t("em",[e._v("morphism")]),e._v("s,\n    each having the one object as their "),t("em",[e._v("source")]),e._v("\n    and the other object as their "),t("em",[e._v("target")]),e._v(".\n    For any single object, the morphisms must include an\n    "),t("em",[e._v("identity morphism")]),e._v(" with that single object\n    as source and target.\n    For any object and two morphisms having it as source and target\n    respectively, there must be a "),t("em",[e._v("composite morphism")]),e._v("\n    having as source the source of one morphism and as target\n    the target of the other.\n    This "),t("em",[e._v("composition of morphisms")]),e._v(" must be associative,\n    with identity morphisms as left and right unit elements.\n  ")]),t("p",[e._v("\n    An object is a "),t("em",[e._v("terminal object")]),e._v(" in a category\n    if for each object as source there is exactly one\n    morphism with that object as target.\n    An object is a "),t("em",[e._v("product object")]),e._v("\n    of two given objects\n    if there are two special "),t("em",[e._v("projection morphisms")]),e._v("\n    having the product as source.\n    For any arbitrary morphism having an arbitrary object as source\n    and either of the two given objects as target\n    there must be a corresponding morphism\n    having the same arbitrary object as source\n    and the product object as target.\n    That arbitrary morphism must then be the composition\n    of that corresponding morphism and the appropriate\n    projection morphism.\n  ")]),t("p",[e._v("\n    In a category with products there may also be "),t("em",[e._v("exponential object")]),e._v("s\n    of a given source object and a given target object.\n    Such an exponential object must have a special "),t("em",[e._v("evaluation morphism")]),e._v('\n    having the product of the given source object\n    and the exponential object as source\n    and the given target object as target.\n    For any arbitrary morphism\n    having the product of the source object and an arbitrary object\n    as source there must be exactly one corresponding ("curried")\n    morphism.\n    That arbitrary morphism must then be (essentially)\n    the composition of the corresponding morphism\n    and the evaluation morphism.\n  ')]),t("p",[e._v("\n    A "),t("em",[e._v("Cartesian closed category")]),e._v("\n    is one which has a terminal object,\n    and for any two objects their product and exponential,\n    together with their projection and evaluation morphisms.\n    In the category of sets,\n    products are Cartesian products,\n    exponentials are functions from sets to sets,\n    and evaluation morphisms are the application\n    of a function to a value.\n    In the category of logical systems,\n    products are conjunctions,\n    exponentials are conditionals,\n    projections are and-elimination rules\n    and evaluation morphisms are the "),t("em",[e._v(" modus ponens")]),e._v(" rule.\n  ")]),t("p",[e._v('\n    The language of categories is another functional language.\n    If it has products,\n    then it can deal with functions of several variables.\n    If it has exponentials,\n    then functions are "'),t("em",[e._v("first class citizen")]),e._v('s".\n    The language is therefore an alternative\n    to the (typed) lambda calculus and to combinatory logic.\n    Whereas the lambda calculus needs variables,\n    the combinatory language and the categorical language do not.\n  ')]),t("p",[e._v("\n    Cartesian closed categories are explained for example in\n    Barr and Wells (1990 Chapter 6) \n    and in\n    Poigne (1992) .\n    Barr and Wells give an example of a simple lambda expression\n    with variables and a complicated looking categorical equivalent formula.\n    They suggest an acceptable reformulation of the categorical formula.\n    Both categorical versions\n    essentially replace occurrences of variables by\n    use of projection functions.\n  ")]),t("p",[e._v("\n    Could the language of categories be used for writing programs?\n    Any lambda expression can be translated into a categorical expression,\n    so the language of categories is expressively complete.\n    But this does not make it a suitable language for writing\n    programs.\n    As it stands it is a very low-level language.\n  ")]),t("p",[e._v("\n    On the other hand,\n    category theory has given rise to another model of computation:\n    the "),t("em",[e._v("CAM")]),e._v(" or "),t("em",[e._v("Categorical Abstract Machine")]),e._v(",\n    described in\n    Cousineau   et al (1985) ,\n    Cousineau   et al (1987) \n    and in\n    Curien (1986) .\n    The machine language of the CAM is very elegant,\n    but programs in that language\n    look as inscrutable as low level programs in other\n    machine languages.\n    The language is of course suitable as the target language\n    for compilation from any functional language.\n    A very compact but comprehensive exposition\n    of a compiler from (a mini-) ML to CAM is described in\n    Clement   et al (1986) .\n    Mauny and Su\\'{a}rez (1986) \n    describe compilers from a strict and a nonstrict\n    version of ML\n    to an eager and a lazy version of the CAM.\n  ")]),t("p",[e._v("\n    The original translation from lambda expressions\n    to categorical combinators was quadratic in the worst case, but\n    Lins (1987) \n    introduces a linear translation to a simplified abstract machine code.\n    Hannan (1991) \n    uses a variant of the CAM for generating more concrete\n    code suitable for register-level implementation\n    or even micro-coding on conventional architectures.\n    An extension of ML for data-parallel computation has been implemented by\n    Hains and Foisy (1993) \n    to run on a distributed version of the CAM.\n  ")]),t("p",[e._v("\n    Combinatory languages should be seen as abstract machine languages.\n    In contrast, Joy was designed to be a high level language\n    to be used by the human programmer.\n  ")]),t("h1",[e._v("Programming in the large")]),t("p",[e._v("\n    In all high level languages a program consists of a possibly\n    large collection of definitions and a comparatively small\n    main program.\n    The collection of definitions and their interrelations\n    can become very difficult to comprehend and maintain.\n    Many languages provide some mechanisms\n    for giving additional structure to the definitions\n    of functions and their interrelations.\n    One kind of interrelation is due to their mutual calling patterns.\n    The main program calls functions at level one,\n    and these call each other or functions at level two,\n    and so on.\n    A second structure that can be exploited is that due to\n    common types.\n    For example, functions which concatenate two strings\n    and reverse a string will not call each other\n    but belong together in an implementation of strings.\n    A third possible device only makes sense in imperative languages\n    because procedures have additional interrelations\n    due to global assignable variables\n    which might be written by one procedure and read by another.\n  ")]),t("p",[e._v("\n    One of the simplest but very powerful structuring mechanisms\n    is "),t("em",[e._v("block structure")]),e._v(".\n    It was already used in the earliest "),t("em",[e._v("Lisp")]),e._v(" and in "),t("em",[e._v("Algol 60")]),e._v(",\n    and later in "),t("em",[e._v("Pascal")]),e._v(".\n    It has been retained almost all their descendants.\n    A block consists of any number of definitions followed by a body,\n    and a definition consists of a header and a block.\n    So definitions can contain local definitions and so on,\n    with no intrinsic limit to the levels of nesting.\n    Hence any definition can at least provide some\n    "),t("em",[e._v("hiding of information")]),e._v("\n    that is not needed outside.\n    This hiding could be used even in cases where what is defined\n    does not take any parameters at all.\n    (Thus it could be used in context-free grammars,\n    but apparently never is.)\n    More importantly, if there are parameters\n    in the header of a definition,\n    then the bodies of any enclosed definition can access those parameters.\n    Additionally, for an imperative language,\n    if there are assignable variables in a block,\n    then the bodies of any enclosed block can access these variables.\n    Access to non-local parameters and variables is automatic\n    via a static chain or a display.\n    This mechanism achieves what otherwise would have to be handled by\n    explicitly passing them as parameters.\n  ")]),t("p",[e._v("\n    Joy currently does not have block structure,\n    but it would be easy to implement.\n    Since Joy does not have formal parameters and no assignable\n    variables, block structure would only provide the benefit\n    of information hiding.\n  ")]),t("p",[e._v("\n    The popular imperative "),t("em",[e._v("C language")]),e._v(" does not have block structure\n    but it does address the problem of hiding information about\n    assignable variables from function bodies that do not need this\n    information.\n    One such mechanism is that of "),t("em",[e._v("own variable")]),e._v("s,\n    or "),t("em",[e._v(" internal static")]),e._v(" variables in C-terminology.\n    Such a variable can be declared, initialised and used within a single\n    function body and not be visible outside.\n    The value of the variable persists between successive calls\n    of the function.\n    The other mechanism is that of independent compilation units.\n    These are just files containing declarations of global variables\n    and functions without a main program.\n    The variables can be made invisible from outside their unit.\n    A complete program then consists of very few variables\n    visible everywhere,\n    and several files each containing a collection of variables\n    and procedures that belong together.\n  ")]),t("p",[e._v("\n    In Joy the first mechanism does not even make sense\n    because Joy as a functional language does not have any assignable\n    variables.\n    The second mechanism could still allow related functions to be kept\n    together in one file.\n    The current implementation of Joy does not use a single input file\n    but a stack of such files.\n    A new file can be opened and become the current input file\n    by an "),e._v('< kbd=""> directive.\n    But no information hiding occurs through this mechanism,\n    there is only one global namespace.\n    Hiding only occurs in explicit '),e._v('< kbd="" declarations..="" '),e._v('="">\n    Independent compilation units in files are not without problems.\n    One criticism is that in order to achieve independence,\n    programs have to be spread over too many files.\n    Another concerns security,\n    since a simple compiler does not check type conformity of\n    formal parameters in the declarations of in one unit\n    and the actual parameters in the calls of another unit.\n    A third criticism is that such units cannot be nested.\n    The language '),t("em",[e._v("Modula2")]),e._v(" overcomes these problems.\n    A collection of declarations and definitions can be\n    wrapped up inside a "),t("em",[e._v("module")]),e._v(".\n    A single file can contain several modules.\n    In addition to a detailed "),t("em",[e._v("implementation module")]),e._v("\n    there is a short "),t("em",[e._v("definition module")]),e._v(" containing\n    only type information, especially about formal parameters.\n    This interface is used to check type conformity with calls\n    from another module.\n    Finally, modules can be nested.\n    A module specifies explicitly which of its identifiers\n    are to be exported and made visible to the outside.\n    Any others remain hidden.\n    But the total number of identifiers exported from various\n    modules in a program can still be very large.\n    Moreover, if different modules were written by different\n    programmers, the exported identifiers might clash.\n    To avoid this problem,\n    Modula2 allows use of qualified names which are similar to record\n    notation.\n    Such names consist of the name of the module together with\n    the name of the exported identifier.\n    ")]),t("p",[e._v("\n    Structuring devices similar to modules would benefit any language\n    for programming in the large.\n    Because Joy is so weakly typed,\n    definition modules would be almost pointless.\n    However, implementation modules with selective export would hide\n    utility functions of a module that are not needed outside the module.\n    Qualified names would then be as in Modula2.\n    A crude substitute for a hiding facility and for qualified names\n    is already used in the Joy libraries.\n    Hidden functions are given names that are not displayed by the\n    "),e._v('< kbd-facility,="" and="" exported="" functions="" have="" names="" beginning="" with="" the="" name="" of="" module.="" modules="" are="" a="" simplified="" version="" older="" concept="" '),e._v('="">class\n    which first occurred in '),t("em",[e._v("Simula")]),e._v(", an early descendant of Algol 60.\n    Classes are a generalisation of record types,\n    but in addition to fields for assignable variables\n    there are fields for procedures and functions.\n    Instances of a class type are called "),t("em",[e._v("object")]),e._v("s,\n    they consists of instance specific assignable variables of their type.\n    From the outside objects are manipulated only by the procedures\n    and functions of their class.\n    This is the essence of "),t("em",[e._v("object oriented programming")]),e._v(",\n    it emphasises hiding of implementation details\n    so that only "),t("em",[e._v("abstract data type")]),e._v("s\n    are visible from the outside.\n    Two other notions are "),t("em",[e._v("inheritance")]),e._v("\n    of properties of objects from other objects,\n    and making functions and procedures "),t("em",[e._v("re-usable")]),e._v(" and "),t("em",[e._v("polymorphic")]),e._v(".\n    the ability of an object to respond to actual\n    parameters of different types.\n    The "),t("em",[e._v("C++ language")]),e._v(" has made these concepts\n    extremely popular. It is being used to build extensive libraries\n    containing re-usable components.\n    ")]),t("p",[e._v("\n    Since Joy does not have any assignable variables,\n    the notion of class and objects are not applicable.\n    However, hiding, inheritance and polymorphism would still be\n    useful.\n    Many operators in Joy are already polymorphic,\n    and it is possible to write libraries\n    which retain or even extend this property.\n  ")]),t("p",[e._v("\n    One of the most sophisticated devices for structuring programs\n    is to be found in the language ML.\n    For a good introduction, see\n    Paulson (1992 Chapter 7) \n    and\n    Sokolowski (1991 Chapters 8 and 9) .\n    A "),t("em",[e._v("signature")]),e._v(" is very much like an definition module\n    in Modula2,\n    it specifies parameter types and result types of functions,\n    but it does not specify their bodies.\n    A "),t("em",[e._v("structure")]),e._v(" is like an implementation module,\n    it specifies the bodies of functors\n    but does not hide implementation details.\n    Real hiding and hence real abstraction is provided by "),t("em",[e._v("functor")]),e._v("s,\n    inspired by category theory.\n    In their simplest form they simply hide implementation detail.\n    But they can also take one or more other structures\n    as formal parameters and produce other structures as value.\n    The bodies of functions can access all the functions in\n    the formal structure parameters.\n    Functors must be instantiated with actual structures\n    before they can be used,\n    and they can be instantiated several times with\n    different actual parameters.\n    Instantiation of functors thus resembles calling a function\n    with actual parameters,\n    but like the generics of Ada, it occurs at compile time.\n    However, the functors of ML are far more powerful than\n    the generics of Ada.\n    Functors are again structuring devices for programming in the large.\n    They could be used not just for functional languages\n    but equally well for procedural,\n    logical or actor languages.\n    A mathematically very mature treatment of modules\n    in terms of category theory is given in\n    Ehrig and Mahr (1990) .\n  ")])])}]};n.a=i}});