webpackJsonp([13],{G59P:function(e,t,n){(e.exports=n("FZ+f")(!1)).push([e.i,"p[data-v-7c2d3108]{margin-top:16px;margin-bottom:16px}hr[data-v-7c2d3108]{margin-bottom:16px}pre[data-v-7c2d3108]{margin-bottom:auto}code[data-v-7c2d3108],kbd[data-v-7c2d3108],pre[data-v-7c2d3108]{font-family:Roboto Mono,monospace}",""])},OQ57:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=n("lcoX"),s=!1;var r=function(e){s||n("iMCS")},i=n("VU/8")(null,o.a,!1,r,"data-v-7c2d3108",null);i.options.__file="pages/papers-on-joy/programming-in-joy.vue",t.default=i.exports},iMCS:function(e,t,n){var o=n("G59P");"string"==typeof o&&(o=[[e.i,o,""]]),o.locals&&(e.exports=o.locals);n("rjj0")("c5b0859a",o,!1,{sourceMap:!1})},lcoX:function(e,t,n){"use strict";var o=function(){var e=this.$createElement;this._self._c;return this._m(0)};o._withStripped=!0;var s={render:o,staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("article",[n("i",[e._v(" By Manfred von Thun ")]),n("h1",[e._v(" Introduction ")]),e._v("\n  This paper shows how to write simple programs in Joy. Since Joy is very different\n  from familiar programming languages, it takes a while to become used to writing programs\n  in Joy. One way to start the learning process is by way of writing some simple generally\n  useful library programs. In an implementation these may be part of an actual library,\n  or they may be built into the language.\n  "),n("p",[e._v("\n    Some general "),n("em",[e._v("utility program")]),e._v("s include operators for manipulating the Joy\n    stack just below the top element, further operators for manipulating aggregate\n    values, and a few output programs. Generally useful are the\n    "),n("em",[e._v("stack type")]),e._v(" and the\n    "),n("em",[e._v("queue type")]),e._v(". Values and operators of these two types are easily implemented\n    as Joy lists and list operators.\n  ")]),n("p",[e._v("\n    Another collection of useful operators take an aggregate as parameter and produce\n    a list of subaggregates. These operators are "),n("em",[e._v("polymorphic")]),e._v(" in the sense\n    that the aggregate parameter can be a (small) set, a string, or a list. For example,\n    one such operator can take a set as parameter and produces a list of its subsets.\n    All of these operators are definable without recursion by using the "),n("kbd",[e._v("linrec")]),e._v("  combinator.\n  ")]),n("p",[e._v("\n    Some "),n("em",[e._v("arithmetic operator")]),e._v("s are often used to illustrate recursive definitions,\n    although it is well known that iterative execution is more efficient. In particular\n    the use of "),n("em",[e._v("accumulating parameter")]),e._v("s can often replace recursion. This is\n    easily done in Joy using various iteration combinators.\n  ")]),n("p",[e._v("\n    Values of "),n("em",[e._v("sequence type")]),e._v("s, such as strings and lists, can be sorted, and\n    sorted sequences can be merged. Programs for doing this are easily written in Joy\n    without recursive definitions but using appropriate combinators instead.\n  ")]),n("p",[e._v("\n    Joy's inbuilt "),n("em",[e._v("set type")]),e._v(" is implemented just as bitstrings, and hence it\n    is limited to small sets of small numbers. The more useful "),n("em",[e._v("big set type")]),e._v(",\n    which allows large sets of elements of any type, can be implemented in any language\n    which has lists. It is simple to do in Joy, and the usual set-theoretic operations\n    are easily provided. A similar implementation can be used for the "),n("em",[e._v("dictionary type")]),e._v(",\n    which uses lookup tables for finite functions.\n  ")]),n("p",[e._v("\n    Also useful is the "),n("em",[e._v("tree type")]),e._v(", of lists, or lists of lists, or lists of\n    lists of lists ... of elements other than lists.\n  ")]),n("p",[e._v('\n    The remainder of this paper illustrates programming in Joy by way of simple examples.\n    Many of the programs are first written in pseudo-code and the translated into Joy.\n    Some of the Joy programs here have been adapted from the literature on ML or Miranda\\footnote{"Miranda"\n    is a trademark of Research Software Ltd}. The next section defines some useful\n    general purpose operators and combinators. This is followed by a section on two\n    little collections of operators for two datatypes, stacks and queues. A longer\n    section deals with programs for creating and manipulating lists of subaggregates.\n    A shorter section then illustrates the use of accumulating parameters for the efficient\n    implementation of numeric functions. Then there is another section on sorting sequences\n    and on merging sorted sequences. Another section gives an implementation of unrestricted\n    sets and of lookup dictionaries.\n  ')]),n("h1",[e._v("Utility operators and combinators")]),n("p",[e._v("\n    This section describes some very simple utilities which are useful in very different\n    settings. Joy definitions are of the form\n  ")]),n("pre",[e._v("        ATOM   ==   PROGRAM\n  ")]),e._v("\n  where the long equals "),n("kbd",[e._v("==")]),e._v(" means that the atom on the left is being\n  defined to cause the execution of the program on the right.\n  "),n("p",[e._v("\n    Joy has three important operations for manipulating the top few items of the stack:\n    "),n("kbd",[e._v("pop")]),e._v(" for removing the top item,\n    "),n("kbd",[e._v("dup")]),e._v(" for creating a copy of the top item, and "),n("kbd",[e._v("swap")]),e._v(" for interchanging\n    the top two items. Often it is necessary to perform similar operations further\n    below the stack. The following define three similar operators which leave the top\n    element of the stack intact and perform the work just below that. All three use\n    the "),n("kbd",[e._v("dip")]),e._v(" combinator which takes as a parameter a quoted program and below\n    that a further item. The item is saved, the quoted program is executed and the\n    item then restored.\n  ")]),n("pre",[e._v("        popd   ==  [pop ] dip\n          dupd   ==  [dup ] dip\n          swapd  ==  [swap] dip\n  ")]),e._v("\n  The "),n("kbd",[e._v("popd")]),e._v(" operator removes the second item. The "),n("kbd",[e._v("dupd")]),e._v("operator duplicates the second item. The "),n("kbd",[e._v("swapd")]),e._v(" operator interchanges the\n  second and third item.\n  "),n("p",[e._v("\n    Three similar operators affect the order of the top three items on the stack. The\n    "),n("kbd",[e._v("rollup")]),e._v(" operator places items one, two and three from the top in the\n    order two, three, one. The "),n("kbd",[e._v("rolldown")]),e._v(" operator places items one, two and\n    three in the order three, one, two. The "),n("kbd",[e._v("rotate")]),e._v(" operator places them\n    in the order three, two, one.\n  ")]),n("pre",[e._v("        rollup     ==  swap [swap] dip\n          rolldown   ==  [swap] dip swap\n          rotate     ==  swap [swap] dip swap\n  ")]),n("p",[e._v("\n    The next examples are for "),n("em",[e._v("unary operator")]),e._v("s which expect an item on the\n    stack and replace it with either a set or a string or a list containing just that\n    item. All three operators work by first pushing The "),n("em",[e._v(" empty set ")]),n("kbd",[e._v(" {} ")]),e._v("  or the "),n("em",[e._v("empty string")]),n("kbd",[e._v('""')]),e._v(" or the "),n("em",[e._v("empty list")]),n("kbd",[e._v("[]")]),e._v("}\n    on top of the stack. Then they use the "),n("kbd",[e._v("cons")]),e._v(" operation to add the item\n    below into the aggregate. The items have to be of the right type. The "),n("kbd",[e._v("unitset")]),e._v("  operator requires a small number, the "),n("kbd",[e._v("unitstring")]),e._v(" operator requires a\n    character, and the "),n("kbd",[e._v("unitlist")]),e._v(" operator requires anything. If the items\n    are not of the right type, an error occurs when the "),n("code",[e._v("cons")]),e._v(" is executed.\n  ")]),n("pre",[e._v('        unitset     ==  {} cons\n          unitstring  ==  "" cons\n          unitlist    ==  [] cons\n  ')]),e._v("\n  The action of all three is reversed by the single standard operator\n  "),n("kbd",[e._v("first")]),e._v(".\n  "),n("p",[e._v("\n    Analogously one may define three operators\n    "),n("kbd",[e._v("pairset")]),e._v(", "),n("kbd",[e._v("pairstring")]),e._v(" and "),n("kbd",[e._v("pairlist")]),e._v(", which form a\n    set, string or list from "),n("em",[e._v(" two")]),e._v(" appropriate items on top of the stack:\n  ")]),n("pre",[e._v('        pairset     ==  {} cons cons\n          pairstring  ==  "" cons cons\n          pairlist    ==  [] cons cons\n  ')]),e._v("\n  The action of all three is reversed by a single operator "),n("kbd",[e._v("unpair")]),e._v(",\n  which may be defined in either of two equivalent ways:\n  "),n("pre",[e._v("        unpair  ==  uncons uncons pop\n          unpair  ==  uncons first\n  ")]),n("p",[e._v("\n    Joy has two operators applicable to\n    "),n("em",[e._v(" non-empty")]),e._v(" sets, strings and lists: The operator "),n("kbd",[e._v("first")]),e._v(" extracts\n    the first item of a string or list, and that item from a set which is the first\n    in the underlying order. The operator "),n("kbd",[e._v("rest")]),e._v(" removes the first item and\n    returns the remaining set, string or list. Sometimes it is necessary to extract\n    the\n    "),n("kbd",[e._v("second")]),e._v(" or "),n("kbd",[e._v("third")]),e._v(" item. Suitable definitions are these:\n  ")]),n("pre",[e._v("        second  ==  rest first\n          third  ==  rest rest first\n  ")]),n("p",[e._v("\n    The operators "),n("kbd",[e._v("uncons")]),e._v(" and "),n("kbd",[e._v("unswons")]),e._v(" undo what is done by\n    "),n("code",[e._v("cons")]),e._v(" and "),n("code",[e._v("swons")]),e._v(", Often it is useful to dissect not just\n    one aggregate into its "),n("code",[e._v("first")]),e._v(" and "),n("code",[e._v("rest")]),e._v(", but to dissect\n    two aggregates. This can be done by "),n("kbd",[e._v("uncons2")]),e._v(" and "),n("kbd",[e._v("unswons2")]),e._v(",\n    defined as follows:\n  ")]),n("pre",[e._v("        uncons2   ==  [uncons ] dip uncons  swapd\n          unswons2  ==  [unswons] dip unswons swapd\n  ")]),e._v("\n  Both expect two aggregates on top of the stack, both leave two "),n("code",[e._v("first")]),e._v("s\n  and two "),n("code",[e._v("rest")]),e._v("s on the stack. For "),n("code",[e._v("uncons2")]),e._v(" the two "),n("code",[e._v("first")]),e._v("s\n  are items 3 and 4 on the stack, the two "),n("code",[e._v("rest")]),e._v("s are items 1 and 2. For\n  "),n("code",[e._v("unswons2")]),e._v(" it is the other way around.\n  "),n("p",[e._v("\n    Similarly, it is sometimes necessary to test whether at least one of two aggregates\n    is empty, or whether at least one of two numeric values is equal to zero. For a\n    single parameter this is done by "),n("code",[e._v("null")]),e._v(", for two parameters it is\n    done by "),n("kbd",[e._v("null2")]),e._v(", defined in either of two equivalent ways:\n  ")]),n("pre",[e._v("        null2  ==  [null] [true] [pop null] ifte\n          null2  ==  [ [[null] true] [pop null] ]  cond\n  ")]),n("p",[e._v("\n    Strings and lists are special kinds of aggregates, they are "),n("em",[e._v("sequence")]),e._v("s.\n    Sometimes it is necessary to reverse sequences. The naive way of doing this is\n    recursively as follows:\n  ")]),n("pre",[e._v("          To reverse a sequence S:\n                   If    S is empty\n                         then return the empty sequence\n                         else    remove the first element\n                                 reverse the rest of S\n                                 append the first element of S at the tail\n  ")]),e._v("\n  It is easy to see that this is very inefficient because the append operation\n  requires a lot of copying, and every element to be appended requires portions of\n  the rest to be copied again and again. A well-known optimisation uses an extra parameter,\n  an "),n("em",[e._v("accumulating parameter")]),e._v(", to obtain the same effect. The idea is to prepend\n  the elements of the original list onto the accumulating parameter. Sometimes this\n  is expressed by analogy with railways. The "),n("kbd",[e._v("shunt")]),e._v(" operator takes two sequences\n  as parameters and, starting at the front of the topmost parameter, moves all items\n  onto the front of the second parameter. Joy has a combinator "),n("kbd",[e._v("step")]),e._v(" for\n  stepping through all items of its top parameter, and for each item executing a program\n  that is given as a further parameter. That program has to take the item and add it\n  to the accumulating parameter, so it is the "),n("kbd",[e._v("swons")]),e._v(" operator. So this is\n  how "),n("code",[e._v("shunt")]),e._v(" can be defined:\n  "),n("pre",[e._v("        shunt  ==  [swons] step\n  ")]),e._v("\n  To reverse a list or a string, an empty list or empty string has to be supplied\n  as an accumulating parameter just below the list or string that is to be reversed.\n  So here are definitions for "),n("kbd",[e._v("reverselist")]),e._v(" and "),n("kbd",[e._v("reversestring")]),e._v(":\n  "),n("pre",[e._v('        reverselist    ==  [] swap shunt\n          reversestring  ==  "" swap shunt\n  ')]),e._v("\n  But there is something unsatisfactory about this, the reversal operation should\n  be polymorphic. So the following version of "),n("kbd",[e._v("reverse")]),e._v(" first tests whether\n  the sequence to be reversed is a list or not, and inserts the appropriate accumulating\n  parameter. The testing is done by the "),n("kbd",[e._v("iflist")]),e._v(" combinator which takes two\n  (here rather tiny) programs as parameters. and below that one other item, the list\n  or string to be reversed. If the latter happens to be a list, then the first quoted\n  program is executed, and it will push an empty list. Otherwise the second program\n  is executed, and it will push an empty string. In either case the two top items are\n  now\n  "),n("code",[e._v("swap")]),e._v("ped and then "),n("code",[e._v("shunt")]),e._v("ed.\n  "),n("pre",[e._v('        reverse  ==  [[]] [""] iflist swap shunt\n  ')]),n("p",[e._v("\n    It comes as a surprise that lists can be reversed in another way. The idea is this:\n    When a list is executed by a combinator, all the members of the list will be literals,\n    so they will each be pushed onto the stack. The last element of the list will end\n    up on top of the stack. So the elements of the list will then be in reverse order.\n    To make use of this idea we have to arrange that an initially empty list is treated\n    as a stack. This is what the "),n("kbd",[e._v("infra")]),e._v(" combinator does. It takes a list\n    as one parameter and a program as the second. It uses the list as a temporary stack\n    and executes the program. The resultant stack is then pushed as a list. For the\n    reversal problem the program is the list to be reversed, and the other parameter\n    has to be the empty list. That empty list first has to be inserted below the list\n    to be reversed. So another program to reverse a list is this:\n  ")]),n("pre",[e._v("        reverselist  ==  [] swap infra\n  ")]),e._v("\n  What makes this version possible is that in Joy the principle that "),n("em",[e._v("program = data")]),e._v("is extended to "),n("em",[e._v("program = data = memory")]),e._v(". This version is actually more efficient\n  than the one given earlier. Of course it cannot be adapted for reversing strings.\n  "),n("p",[e._v("\n    The two principal operators for explicit output are\n    "),n("kbd",[e._v("put")]),e._v(", which prints a single value of any type, and "),n("kbd",[e._v("putch")]),e._v(",\n    which prints a single stand alone character without quote symbol. Two useful little\n    utility operators are worth defining. The "),n("kbd",[e._v("putchars")]),e._v(" operator uses the\n    "),n("kbd",[e._v("step")]),e._v(" combinator to step through the characters in a list or string and\n    writes them to the output file without the enclosing\n    "),n("code",[e._v("[]")]),e._v(" or "),n("code",[e._v('""')]),e._v(". The "),n("kbd",[e._v("newline")]),e._v(" operator just outputs\n    the newline character "),n("code",[e._v("\\n")]),e._v(" to terminate a line.\n  ")]),n("pre",[e._v("        putchars  ==  [putch] step\n          newline     ==  '\\n put\n  ")]),n("p",[e._v("\n    Using the "),n("code",[e._v("step")]),e._v(" combinator it is easy to define several conversion\n    operators which can be useful. The first two produce sets from aggregates of upper\n    or lower case aggregates. The last two produce strings of upper or lower case characters\n    from aggregates of small numbers.\n  ")]),n("pre",[e._v('        upper2set == {} swap [64 - swons] step\n          lower2set == {} swap [96 - swons] step\n          set2upper == "" swap [64 + swons] step\n          set2lower == "" swap [96 + swons] step\n  ')]),n("p",[e._v("\n    The "),n("kbd",[e._v("dip")]),e._v(" combinator expects a quotation and below that an item that will\n    be saved before execution of the quotation and restored afterwards. Sometimes one\n    wants to save and restore two or even three items, so it is useful to have further\n    variants "),n("kbd",[e._v("dip2")]),e._v(" and "),n("kbd",[e._v("dip3")]),e._v(", defined as follows:\n  ")]),n("pre",[e._v("        dip2  ==  [dip] cons dip\n          dip3  ==  [dip] cons dip2\n  ")]),e._v("\n  Note that "),n("kbd",[e._v("cons")]),e._v(" is being used to build a "),n("em",[e._v("constructed program")]),e._v("that is then supplied as a parameter to the last combinator.\n  "),n("h1",[e._v("Stacks and queues")]),n("p",[e._v("\n    This section and the next two contain implementations of two simple data types. Members\n    of the "),n("em",[e._v("stack type")]),e._v(" are linear structures which allow read and write access\n    at one end only, and members of the "),n("em",[e._v("queue type")]),e._v(" are linear structures which\n    allow read access at one end and write access at the other end. Both have this\n    much in common: the stack or queue remains on the Joy stack, and any stack or queue\n    operations using it leave it there. Of course it can be explicitly removed with\n    "),n("code",[e._v("pop")]),e._v(".\n  ")]),n("p",[n("em",[e._v(" 1.")]),e._v(" First, the "),n("em",[e._v("stack type")]),e._v(". A stack is a linear structure that\n    can grow by having items added, inspected and removed all from the same end. The\n    simplest way to implement stacks in Joy is as lists. One essential operator is\n    "),n("kbd",[e._v("st-new")]),e._v(" for the creation of a new empty stack, which is just an empty\n    list. So the definition is\n  ")]),n("pre",[e._v("        st-new  ==  []\n  ")]),n("p",[e._v("\n    Stacks can have additional items pushed onto them, and this is done by adding them\n    to the front of the list. Since the stack is already there, the new item will typically\n    be first pushed onto the Joy stack, and then it is to be pushed onto the stack.\n    One way to do this is to "),n("code",[e._v("swap")]),e._v(" the item and the stack and then perform\n    a "),n("code",[e._v("cons")]),e._v(" operation. But Joy has an operation which combines these two,\n    namely "),n("kbd",[e._v("swons")]),e._v(". So the "),n("kbd",[e._v("st-push")]),e._v(" operation can be defined by\n  ")]),n("pre",[e._v("        st-push  ==  swons\n  ")]),e._v("\n  An essential predicate is "),n("kbd",[e._v("st-null")]),e._v(" for testing whether a stack is\n  empty or null. However it will not do to just use "),n("code",[e._v("null")]),e._v(", since this will\n  remove the stack --- but typically the stack is intended for further applications.\n  So, to avoid losing the stack, it has to be "),n("code",[e._v("dup")]),e._v("licated first, and then\n  the "),n("code",[e._v("null")]),e._v(" test can be applied to the duplicate:\n  "),n("pre",[e._v("        st-null  ==  dup null\n  ")]),n("p",[e._v("\n    The previous two operations both make sense when the stack is empty, but this is\n    not the case for the stack operations to follow. The first of these is "),n("kbd",[e._v("st-top")]),e._v("  for extracting the top element of the stack, while leaving the stack itself unchanged.\n    The second is "),n("kbd",[e._v("st-pop")]),e._v(" for removing the top element. The third is "),n("kbd",[e._v("st-pull")]),e._v("  which combines the last two, it is the opposite of push. It extracts the top item\n    and pops the stack. Ignoring the complication of an empty stack, the definitions\n    would simply be:\n  ")]),n("pre",[e._v("        st-top   ==  dup first\n          st-pop   ==  rest\n          st-pull  ==  unswons\n  ")]),e._v("\n  To guard against an empty stack, a test has to be performed to determine whether\n  the stack is empty. If it is, then an error message should be given, otherwise the\n  operation should be performed. So for all three operations the structure will be\n  of the form\n  "),n("pre",[e._v("        ==   [null]  [ERROR-MESSAGE]  [PERFORM OPERATION]  ifte\n  ")]),e._v("\n  The error messages should state which of the operations was being attempted,\n  but otherwise they should be the same. So the name of the operation is given as a\n  string parameter to an error handling operation. That particular operation will be\n  called\n  "),n("code",[e._v("_st-error")]),e._v(", and we leave the details of its implementation till a little\n  later. The leading underscore "),n("code",[e._v("_")]),e._v(" in the name has been added because this\n  operation is not intended to be used by the programmer; in the current implementation\n  the "),n("kbd",[e._v("help")]),e._v(" command hides identifiers with a leading underscore. The remaining\n  stack operations are then:\n  "),n("pre",[e._v('        st-top  == [null] ["st-top"  _st-error] [dup first] ifte\n          st-pop  == [null] ["st-pop"  _st-error] [rest     ] ifte\n          st-pull == [null] ["st-pull" _st-error] [unswons  ] ifte\n  ')]),e._v("\n  As may be seen, the three operations still have a lot in common, and one might\n  consider extracting that further. However, the result is likely to be less clear\n  to the human reader. It remains to implement the error operation. It should state\n  that an error has occurred due to an empty stack, and this part is the same for all\n  three operations. It should also state which of the operations failed. So a minimal\n  implementation of "),n("code",[e._v("_st-error")]),e._v(" would simply write one string which is common\n  for any call, and another string which is the specific parameter. This is crude but\n  very easy to implement:\n  "),n("pre",[e._v('        _st-error  ==  "non_empty stack needed for " put put\n  ')]),e._v("\n  A minor improvement is to concatenate the two strings (in the right order),\n  so that only one string has to be written. But the double quotation marks in the\n  output still look silly. So instead of writing the one or two strings with "),n("code",[e._v("put")]),e._v(",\n  it looks nicer to write their constituent characters with "),n("kbd",[e._v("putchars")]),e._v(". Also,\n  the line should be terminated with "),n("kbd",[e._v("newline")]),e._v(". Finally, there is little sense\n  in continuing the computation, so after the two parts of the error message have been\n  displayed, it is best to "),n("kbd",[e._v("abort")]),e._v(", to return to the top level.\n  "),n("p",[e._v("\n    In a library implementation for the collection of definitions of stack operations\n    might look like this:\n  ")]),n("pre",[e._v('LIBRA (* stack *)\n\n  _st-error == "non-empty stack needed for " putchars putchars newline abort;\n  st-new  == [];\n  st-push == swons;\n  st-null == dup null;\n  st-top  == [null] ["st-top"  _st-error] [dup first] ifte;\n  st-pop  == [null] ["st-pop"  _st-error] [rest     ] ifte;\n  st-pull == [null] ["st-pull" _st-error] [unswons  ] ifte.\n  ')]),e._v("\n  As may be seen from the example, a library declaration begins with the word\n  "),n("kbd",[e._v("LIBRA")]),e._v(" and terminates with a period. In between is a sequence of definitions\n  separated by semicolons "),n("kbd",[e._v(";")]),e._v(". A definition consists of an atomic symbol and\n  then the symbol "),n("kbd",[e._v("==")]),e._v(" followed by a Joy program. Note again that the "),n("code",[e._v("_st-error")]),e._v("operator is not really intended to be used outside the remaining definitions. It\n  could well be hidden completely from outside. A mechanism for this will be illustrated\n  below.\n  "),n("p",[n("em",[e._v(" 2.")]),e._v(" Next, the "),n("em",[e._v("queue type")]),e._v(". A queue is a linear structure that\n    can grow by having items added at one end, and inspected or removed from the other\n    end. A simple minded implementation would consists of a single Joy list to which\n    items are added at the end and removed from the front. But adding something at\n    the end requires copying the entire list every time. Nothing would be gained by\n    reversing the role of front and end, because in that case the removal requires\n    copying of (almost) the entire list. A better implementation uses "),n("em",[e._v(" two")]),e._v("  lists. Conceptually one is the front of the queue, and items are removed at the\n    front. Conceptually the other list is the back of the queue, but in reverse, and\n    items are added to the front of this list. If at any time the list implementing\n    the front of the queue becomes empty, the other list gets explicitly reversed and\n    it becomes the front, and the empty list becomes the rear. There are two auxiliary\n    operators that need only be visible to the remaining operators but not to the outside;\n    in the following they are hidden in the private part of this module. Because they\n    are hidden, there is no need to choose names which indicate the datatype on which\n    they operate.\n  ")]),n("pre",[e._v('LIBRA (* queue *)\n\n  HIDE\n    error   == "non_empty queue needed for " putchars putchars newline abort;\n    prepare == [null] [swap reverse] [] ifte\n  IN\n    q-new   == [] [];\n    q-add   == swap [swons] dip;\n    q-addl  == swap [shunt] dip;\n    q-null  == prepare dup null;\n    q-front == prepare [null] ["q-front" error] [dup first] ifte;\n    q-rem   == prepare [null] ["q-rem "  error] [unswons  ] ifte\n  END.\n  ')]),n("p",[e._v("\n    As may be seen, such a declaration consists of the word "),n("kbd",[e._v("HIDE")]),e._v(", followed\n    by a sequence of definitions, then the word "),n("kbd",[e._v("IN")]),e._v(" followed by another sequence\n    of definitions, and then the word "),n("kbd",[e._v("END")]),e._v(". A sequence of definitions is\n    again separated by semicolons "),n("kbd",[e._v(";")]),e._v(". The whole declaration can occur inside\n    a library declaration where a single definition can occur. Any hiding declaration\n    can occur wherever a single definition can occur, so they can be nested.\n  ")]),n("p",[e._v("\n    The first auxiliary error reporting procedure, "),n("code",[e._v("error")]),e._v(", is similar to\n    the one for stacks. The second auxiliary operation, "),n("code",[e._v("prepare")]),e._v(", prepares\n    the two lists: if the list implementing the front happens to be empty, the roles\n    of the two lists are interchanged. If the front list is not empty, nothing is done.\n  ")]),n("p",[e._v("\n    A new queue is created by "),n("kbd",[e._v("q-new")]),e._v(' in the form of two empty lists. An item\n    can be added (to the "rear of the queue") by '),n("kbd",[e._v("q-add")]),e._v(" which adds it to\n    the front of the second list. The members of a whole list can be added to the rear\n    by "),n("kbd",[e._v("q-addl")]),e._v(". The operator "),n("kbd",[e._v("q-null")]),e._v(" first prepares the two lists\n    so that the list implementing the front is not empty, if that is possible at all.\n    It then tests the front list. The operator "),n("kbd",[e._v("q-front")]),e._v(" and "),n("kbd",[e._v("q-rem")]),e._v("  extract respectively a copy of the front element or the front element itself. The\n    copy or the original are left above the two lists. Both operators require the queue\n    to be prepared so that the list implementing the front is not empty. Also, both\n    operators need to check whether the front really is non-empty. If it is not, the\n    error operator is called.\n  ")]),n("p",[e._v("\n    The definitions for stacks and queues are part of the library file\n    "),n("kbd",[e._v("TYPLIB.JOY")]),e._v(".\n  ")]),n("h1",[e._v("Lists of subaggregates")]),e._v("\n  The "),n("em",[e._v("aggregate type")]),e._v("s of Joy comprise sets of small numbers, or strings of\n  characters, or lists of items of any kind. Much of this section deals with lists\n  of aggregates constructed from a given aggregate. The principal tool is the "),n("kbd",[e._v("linrec")]),e._v("combinator. It expects four program parameters on the stack, an if-part, a then-part,\n  a rec1-part and a rec2-part. Execution begins by saving the four parts and then executing\n  the if-part. If that produces the truth value "),n("code",[e._v("true")]),e._v(" on top of the stack,\n  the then-part is executed and the combinator exits. Otherwise the rec1-part is executed,\n  then the combinator calls itself with the same four parts, and then the rec2-part\n  is executed.\n  "),n("p",[e._v("\n    The first definition below is for an operator "),n("kbd",[e._v("restlist")]),e._v(" which takes any\n    aggregate as parameter and produces the list of all those subaggregates that would\n    be formed by repeatedly taking the "),n("kbd",[e._v("rest")]),e._v("s of the aggregate. Such an operator\n    can of course be defined recursively and this could be done in any language. But\n    in Joy it is possible to use a non-recursive definition using the "),n("code",[e._v("linrec")]),e._v("  combinator. Here is some pseudocode:\n  ")]),n("pre",[e._v("1.      If    the aggregate is empty\n  2.            then  form its unitlist\n  3.            else    take a copy and the rest of that,\n                        recurse using this rest,\n                        eventually forming a list of aggregates,\n  4.                    use cons to add the original aggregate\n                        to the front of this list\n  ")]),e._v("\n  The above pseudocode translates directly into a recursive form in any language,\n  but in Joy a non-recursive definition is also possible. The four program parameters\n  for the "),n("code",[e._v("linrec")]),e._v(" combinator correspond exactly to the labelled lines.\n  Nothing corresponds to the unlabelled line, the "),n("code",[e._v("linrec")]),e._v(" combinator recurses\n  here automatically.\n  "),n("pre",[e._v("    restlist  ==\n  1.        [ null ]\n  2.        [ unitlist ]\n  3.        [ dup rest ]\n  4.        [ cons ]\n            linrec\n  ")]),n("p",[e._v("\n    The next program also takes an aggregate as parameter and produces a list of subaggregates.\n    But the subaggregates are those obtained by successively deleting the last elements.\n    In analogy with the previous operator it will be called the "),n("kbd",[e._v("frontlist")]),e._v("  operator. For empty aggregate parameters again the unitlist has to be returned,\n    so the if-part and the then-part are the same as before. Also, for non-empty aggregates\n    the aggregate has to be taken apart in the rec1-part. This can be done in two ways.\n    We can take the front aggregate and the last element, but that would require defining\n    a suitable operator, and it would require expensive copying in the case of list\n    or string aggregates. Alternatively we can just "),n("code",[e._v("uncons")]),e._v(". This leaves\n    only the rec2-part to be written. But it will be more complicated than for the\n    previous operator. Let us ignore for the moment that the operator is intended to\n    be used for aggregates of any of the three types. When the anonymous recursion\n    has completed, the stack will contain the first item of the non-empty aggregate\n    and above that the "),n("code",[e._v("frontlist")]),e._v(" of its rest. The first item has to be\n    "),n("code",[e._v("cons")]),e._v("ed into each member of the frontlist, and that is best done by\n  ")]),n("pre",[e._v("        [cons]  map\n  ")]),e._v("\n  Then that first item, which is now still the second element on the stack,\n  has to be deleted. This can be done by a variant of "),n("code",[e._v("pop")]),e._v(", namely "),n("code",[e._v("popd")]),e._v(".\n  Finally, assuming that the operator is to be used for lists, the empty list has to\n  be added to the frontlist, and the easiest way is by "),n("code",[e._v("[] swap cons")]),e._v(", or\n  simply by "),n("code",[e._v("[] swons")]),e._v(". This gives the following provisional rec2-part:\n  "),n("pre",[e._v("        [ [cons] map   popd   [] swons ]\n  ")]),e._v("\n  But the assumption that the operator is to be used only for lists is unnecessarily\n  restrictive. The final part, adding an empty aggregate, should depend on what the\n  initial aggregate was, a set, a string or a list. This can be achieved by looking\n  up the first element of the frontlist, it is a one element aggregate and taking its\n  rest produces the required empty aggregate of that type. So the required rec2-part\n  is:\n  "),n("pre",[e._v("        [ [cons] map   popd   dup first rest swons ]\n  ")]),e._v("\n  The entire definition for "),n("code",[e._v("frontlist")]),e._v(", applicable to any aggregate,\n  now is:\n  "),n("pre",[e._v("    frontlist ==\n          [ null ]\n          [ unitlist ]\n          [ uncons ]\n          [ [cons] map popd dup first rest swons ]\n          linrec\n  ")]),n("p",[e._v("\n    The next program defines an operator "),n("kbd",[e._v("subseqlist")]),e._v(" which is in some ways\n    a combination of the preceding ones. Again it takes any aggregate as parameter\n    and returns a list of subaggregates. This time the subaggregates are all those\n    obtainable from the parameter aggregate by deleting first or last elements. For\n    ordered aggregates, lists and strings, the resulting subaggregates will still contain\n    elements in the same order as the parameter. It is tempting to define the operator\n    very simply by\n  ")]),n("pre",[e._v("        ==   frontlist  [restlist]  map\n  ")]),e._v("\n  But this produces not a list of subsequences but a list of list of subsequences.\n  This list of lists could then be flattened to a single list, even if this is somewhat\n  inefficient. However, a different solution is possible.\n  "),n("p",[e._v("\n    The if-part and the then-part are as for "),n("code",[e._v("restlist")]),e._v(" and "),n("code",[e._v("frontlist")]),e._v(",\n    of course. The rec2-part is easy, it is only necessary to "),n("code",[e._v("concat")]),e._v("enate\n    two lists that were produced by the rec1-part. But the rec1-part is rather complex,\n    and this is what it has to do: the first element of the aggregate has to be extracted\n    and later it has to be "),n("code",[e._v("cons")]),e._v("ed into every subaggregate of the "),n("code",[e._v("frontlist")]),e._v("  of the rest of the aggregate. But also the rest of the aggregate has to be made\n    available for the "),n("code",[e._v("linrec")]),e._v(" combinator to work on. So the rec1-part must\n    "),n("code",[e._v("uncons")]),e._v(" the aggregate, and produce a second copy of the rest. The second\n    copy has to be kept aside by using the "),n("code",[e._v("dip")]),e._v(" combinator to work on the\n    original copy. So an intermediate draft of the rec1-part looks like this:\n  ")]),n("pre",[e._v("        [ uncons  dup\n            [ ... ]\n            dip ]\n  ")]),e._v("\n  The "),n("code",[e._v("[...]")]),e._v(" program must take the "),n("code",[e._v("frontlist")]),e._v(" (of the\n  original copy of the rest) and then "),n("code",[e._v("cons")]),e._v(" the first element into each\n  of the members of the result. We already know how to do that, and how to delete the\n  hidden first member. So the rec2-part is the following:\n  "),n("pre",[e._v("        [ uncons  dup\n            [ frontlist  [cons] map  popd ]\n            dip ]\n  ")]),e._v("\n  The entire program now is this:\n  "),n("pre",[e._v("    subseqlist ==\n          [ null ]\n          [ unitlist ]\n          [ uncons dup [frontlist [cons] map popd] dip ]\n          [ concat ]\n          linrec\n  ")]),e._v("\n  The program uses "),n("code",[e._v("frontlist")]),e._v(", but because the latter is defined\n  without recursion, it is possible to simply use the RHS of the definition of "),n("code",[e._v("frontlist")]),e._v("and insert that textually into the definition of "),n("code",[e._v("subseqlist")]),e._v(". The "),n("code",[e._v("frontlist")]),e._v("and "),n("code",[e._v("subseqlist")]),e._v(" operators were adapted from recursive programs in \\AX{Thompson}{1991\n  p 247}{Thompson:91}.\n  "),n("p",[e._v("\n    The next program defines a unary operator "),n("kbd",[e._v("powerlist")]),e._v(" which for any aggregate\n    returns a list of all subaggregates. If the parameter aggregate has "),n("var",[e._v("N")]),e._v("  members, the resulting list of subaggregates has "),n("var",[e._v("2^N")]),e._v(" members.\n  ")]),n("pre",[e._v("    powerlist ==\n          [ null ]\n          [ unitlist ]\n          [ uncons ]\n          [ dup swapd [cons] map popd swoncat ]\n          linrec\n  ")]),e._v("\n  It uses the "),n("code",[e._v("linrec")]),e._v(" combinator and the same if-part and then-part\n  as the previous programs. It also uses the same rec1-part as the "),n("code",[e._v("frontlist")]),e._v("program: before recursing, the parameter is split into its first and its rest by\n  "),n("code",[e._v("uncons")]),e._v(". The recursion then produces the powerlist of the rest. The rec2-part\n  then uses that result to produce two copies, using "),n("code",[e._v("dup")]),e._v(". One copy is\n  left untouched, the other has the original first element\n  "),n("code",[e._v("cons")]),e._v("ed before every sublist using "),n("code",[e._v("map")]),e._v(". For this to work,\n  the original first element has to be placed in the right position by "),n("code",[e._v("swapd")]),e._v("and eventually deleted by "),n("code",[e._v("popd")]),e._v(". The two resultant lists are finally\n  combined with\n  "),n("code",[e._v("swoncat")]),e._v(". This produces the list of subaggregates starting with the empty\n  one; if "),n("code",[e._v("concat")]),e._v(" is used instead of "),n("code",[e._v("swoncat")]),e._v(", the list ends\n  with the empty one. Neither method yields the subsequences sorted according to "),n("code",[e._v("size")]),e._v(";\n  but see the later section on sorted sequences.\n  "),n("p",[e._v("\n    The next program defines a binary operator "),n("kbd",[e._v("insertlist")]),e._v(". This operator\n    expects a list or a string as a parameter and below that a potential list member\n    or a character. It returns a list whose elements are either lists or strings, each\n    with the potential member or character inserted once at all possible positions.\n    So if the original list or string has "),n("var",[e._v("N")]),e._v(" members, the resultant list\n    has "),n("var",[e._v("N+1")]),e._v(" lists or strings as members.\n  ")]),n("pre",[e._v("    insertlist ==       (*   Item  Sequence   ->   List(Sequence) *)\n          cons\n          [ small ]\n          [ unitlist ]\n          [ dup                           (* keep original *)\n            unswons [uncons] dip swons ]  (* take out second *)\n          [ swap [swons] cons map         (* swons in second *)\n            cons ]                        (* cons in original *)\n          linrec\n  ")]),e._v("\n  The operator can also be used, with a set parameter instead of a string or\n  list. Then it produces a list of "),n("var",[e._v("N+1")]),e._v(" identical sets, each with the new\n  member added. But such a use will rarely be wanted.\n  "),n("p",[e._v("\n    The "),n("kbd",[e._v("permlist")]),e._v(" operator expects a sequence and returns the list of all\n    "),n("em",[e._v("permutation")]),e._v("s of that sequence. So if the original sequence has "),n("var",[e._v("N")]),e._v("  members, the result list has factorial("),n("var",[e._v("N")]),e._v(") members.\n  ")]),n("pre",[e._v("    permlist ==\n          [ small ]\n          [ unitlist ]\n          [ uncons ]\n          [ swap [swap insertlist] cons map\n            flatten ]\n          linrec\n  ")]),e._v("\n  Note again that in the two preceding programs the "),n("code",[e._v("map")]),e._v(" combinator\n  uses a "),n("em",[e._v("constructed program")]),e._v(".\n  "),n("p",[e._v("\n    The "),n("kbd",[e._v("zip")]),e._v(" operator expects two aggregate parameters, not necessarily of\n    the same type, and not necessarily of the same "),n("code",[e._v("size")]),e._v(". It produces a\n    list of two element lists by combining corresponding elements from the two aggregates.\n    The result list contains as many pairs as the smaller of the two parameter aggregates.\n    Here is the definition:\n  ")]),n("pre",[e._v("    zip ==\n          [ null2 ]\n          [ pop pop [] ]\n          [ uncons2 ]\n          [ [pairlist] dip cons ]\n          linrec\n  ")]),e._v("\n  This might be paraphrased as: If one or the other of the two parameter aggregates\n  is "),n("code",[e._v("null")]),e._v(", then "),n("code",[e._v("pop")]),e._v(" them both and return the empty list "),n("code",[e._v("[]")]),e._v(",\n  otherwise take out the two "),n("code",[e._v("first")]),e._v(" elements and the two "),n("code",[e._v("rest")]),e._v("s,\n  recurse with the two "),n("code",[e._v("rest")]),e._v("s producing a result list of two element lists\n  of that, then "),n("code",[e._v("dip")]),e._v(" below that result list to combine the two previous\n  "),n("code",[e._v("first")]),e._v("s with "),n("kbd",[e._v("pairlist")]),e._v(" to form a two element list, and "),n("code",[e._v("cons")]),e._v("that into the front of the result list.\n  "),n("p",[e._v("\n    Related to this is the more general "),n("kbd",[e._v("zipwith")]),e._v(" combinator, adapted from\n    \\AX{Bird and Wadler}{1988 p 57}{Bird:88}. It takes three parameters, two aggregates\n    and one quotation which can be used to combine members of the aggregates. The program\n    again uses the "),n("code",[e._v("linrec")]),e._v(" combinator which needs four quoted programs\n    as parameters. The fourth quotation now has to be a "),n("em",[e._v("constructed program")]),e._v(",\n    it is built from the program parameter of "),n("code",[e._v("zipwith")]),e._v(" and the program\n    stub "),n("code",[e._v("[dip cons]")]),e._v(" already seen for "),n("code",[e._v("zip")]),e._v(". The other three\n    program parameters for "),n("code",[e._v("linrec")]),e._v(" first have to be "),n("code",[e._v("dip")]),e._v("ped\n    below the parameter of "),n("code",[e._v("zipwith")]),e._v(". The definition for this combinator\n    thus is:\n  ")]),n("pre",[e._v("    zipwith ==\n  1.       [ [ null2 ]\n  2.         [ pop pop [] ]\n  3.         [ uncons2 ] ]\n           dip\n  4.       [ dip cons ] cons\n           linrec\n  ")]),n("p",[e._v("\n    A list of sequences can be concatenated into a single sequence by the unary operator\n    "),n("kbd",[e._v("flatten")]),e._v(". The code is straightforward: if the parameter list is empty,\n    then there is nothing to concatenate, leave it as it is. Otherwise use "),n("code",[e._v("uncons")]),e._v("  to take out its first and its rest, recurse anonymously on the rest to produce\n    the "),n("code",[e._v("flatten")]),e._v("ed result of that, and finally "),n("code",[e._v("concat")]),e._v("enate\n    the saved first part to the front of the last result.\n  ")]),n("pre",[e._v("    flatten  ==  [null]  []  [uncons]  [concat] linrec\n  ")]),n("p",[e._v("\n    A two dimensional "),n("em",[e._v("matrix")]),e._v(" can be implemented as a list of lists. One important\n    matrix operation is the interchange of rows and columns, performed by the unary\n    operator "),n("kbd",[e._v("transpose")]),e._v(". A draft of the program is the following:\n  ")]),n("pre",[e._v("          To transpose a list of lists LL :\n  1                If    LL is empty or some sublist of LL is empty\n  2                      then     pop  it off and return the empty list  [] \n                         else    (all sublists are non-empty)\n  3a                             construct a list of all the  first s of sublists\n  3b                             construct a list of all the  rest s of sublists\n                                 recurse anonymously on the list of  rests\n  4                               cons  the list of  firsts into the result.\n  ")]),e._v("\n  This version has been adapted from \\AX{Reade}{1989 p 133}{Reade:89}. To test\n  the disjunction whether LL is empty or some of its sublists are empty, we use the\n  conditional combinator "),n("kbd",[e._v("ifte")]),e._v(". The if-part has to test whether LL is empty,\n  and if it is, then the then-part has to return "),n("code",[e._v("true")]),e._v(". Otherwise the then-part\n  will have to determine whether some sublists of LL are empty. This is best done with\n  the combinator "),n("kbd",[e._v("some")]),e._v(". So part 1 of the Joy version is:\n  "),n("pre",[e._v("1        [null]  [true]  [[null] some]  ifte\n  ")]),e._v("\n  For parts 3a and 3b it is necessary to use the parameter LL to produce two\n  lists, of the "),n("code",[e._v("first")]),e._v("s and the "),n("code",[e._v("rest")]),e._v("s. Either of these two\n  can be obtained with the "),n("kbd",[e._v("map")]),e._v(" combinator. To obtain the two lists, the\n  "),n("kbd",[e._v("cleave")]),e._v(" combinator can be used, it takes two quotation parameters and a\n  further parameter, and produces two values, one from each of the two quotations.\n  So parts 3a and 3b are just:\n  "),n("pre",[e._v("3a      [ [first] map ]\n  3b      [ [rest ] map ]\n          cleave\n  ")]),e._v("\n  The entire Joy program thus is:\n  "),n("pre",[e._v("    transpose ==\n  1       [ [null] [true] [[null] some] ifte ]\n  2       [ pop [] ]\n  3       [ [[first] map] [[rest] map] cleave ]\n  4       [ cons ]\n          linrec;\n  ")]),n("p",[e._v("\n    Alternatively, line 1 can be replaced by the following:\n  ")]),n("pre",[e._v("1        [ [null] [[null] some] disjoin i ]\n  ")]),e._v("\n  Here the two tests are first "),n("kbd",[e._v("disjoin")]),e._v("ed to form a single test predicate.\n  This is the called by the "),n("code",[e._v("i")]),e._v(" combinator. The net effect is exactly the\n  same as in the version given earlier.\n  "),n("p",[e._v("\n    A common binary operation on aggregates is that of forming the "),n("em",[e._v("Cartesian product")]),e._v(".\n    It will take two aggregates as parameters and produce the list of two element list\n    which each contain one element from each of the two aggregates. If the two aggregates\n    have "),n("var",[e._v("M")]),e._v(" and "),n("var",[e._v("N")]),e._v(" members respectively, then the resultant list\n    has "),n("var",[e._v("M \\times N")]),e._v(" elements. In order to form the Cartesian product, it\n    is necessary to consider each of the members of one aggregate with each of the\n    members of the other aggregate. This is like "),n("code",[e._v("step")]),e._v("ping through an aggregate,\n    except that there are two aggregate to be stepped through. It will be useful first\n    to define a combinator "),n("kbd",[e._v("step2")]),e._v(" which does just that, leaving at each step\n    two items on top of the stack. Then the Cartesian product operator will just form\n    their pairs, and then form a list of all these pairs. An application of the "),n("code",[e._v("step2")]),e._v("  combinator will look like this:\n  ")]),n("pre",[e._v("        A1   A2   [P]   step2\n  ")]),e._v("\n  The implementation is based on the simple idea that\n  "),n("code",[e._v("A2")]),e._v(" and "),n("code",[e._v("[P]")]),e._v(" be used to construct a program which is then\n  used by the ordinary "),n("code",[e._v("step")]),e._v(" combinator to step through the elements of\n  "),n("code",[e._v("A1")]),e._v(":\n  "),n("pre",[e._v("        A1   [ .. A2 .. [P] .. ]   step\n  ")]),e._v("\n  We now fill in the dots. The program to be constructed has to "),n("code",[e._v("step")]),e._v("through the members of "),n("code",[e._v("A2")]),e._v(" using a program which depends on "),n("code",[e._v("[P]")]),e._v(".\n  It has to do this for each member of "),n("code",[e._v("A1")]),e._v(", and when it has done that the\n  current member of "),n("code",[e._v("A1")]),e._v(" can be "),n("code",[e._v("pop")]),e._v("ped off. So the program\n  will have to look like this:\n  "),n("pre",[e._v("        A1   [ A2  [ .. P ]  step  pop ]   step\n  ")]),e._v("\n  Since "),n("code",[e._v("P")]),e._v(" must be allowed to consume a current member of\n  "),n("code",[e._v("A1")]),e._v(" but this still has to be available for the next inner "),n("code",[e._v("step")]),e._v(",\n  that member of "),n("code",[e._v("A1")]),e._v(" first has do be duplicated, below the current member\n  of "),n("code",[e._v("A2")]),e._v(". So the dots are just "),n("code",[e._v("[dup] dip")]),e._v(". In sum, the required\n  program is\n  "),n("pre",[e._v("        A1   [ A2  [ [dup]  dip  P ]  step  pop ]   step\n  ")]),e._v("\n  The definition of "),n("kbd",[e._v("step2")]),e._v(" must construct that program from "),n("code",[e._v("A2")]),e._v("and "),n("code",[e._v("[P]")]),e._v(" and then call "),n("code",[e._v("step")]),e._v(" with just two parameters, the\n  program just constructed and below that the other aggregate "),n("code",[e._v("A1")]),e._v(". The\n  definition looks like this:\n  "),n("pre",[e._v("    step2  ==\n          [[dup] dip]  swoncat            (* form inner quote *)\n          [step pop]  cons                (* form outer quote *)\n          cons                            (* insert A2 *)\n          step                            (* through A1 *)\n  ")]),n("p",[e._v("\n    It is now relatively easy to define the "),n("em",[e._v("Cartesian product")]),e._v(" operator as\n    follows. First we need to insert an "),n("em",[e._v("accumulating parameter")]),e._v(", an empty list\n    "),n("code",[e._v("[]")]),e._v(". It has to be inserted "),n("em",[e._v(" below")]),e._v(" the two aggregates of which\n    the Cartesian product is to be computed. This is easily done with "),n("code",[e._v("[] rollup")]),e._v(".\n    The program which is then used by the "),n("code",[e._v("step2")]),e._v(" combinator has to form\n    the "),n("code",[e._v("pairlist")]),e._v(" of the two items on top of the stack. The resultant pair\n    has to be inserted into the accumulator with\n    "),n("code",[e._v("swons")]),e._v(". But between the accumulator and the just formed pair is the\n    current original member of the first aggregate which must be left intact. So the\n    pair and the member have to be "),n("code",[e._v("swap")]),e._v("ped, and the "),n("code",[e._v("swons")]),e._v("  has to be done below the member, by "),n("code",[e._v("dip")]),e._v(". This is the program that\n    is given as the parameter for "),n("code",[e._v("step2")]),e._v(". So the definition for the "),n("kbd",[e._v("cartproduct")]),e._v("  operator is\n  ")]),n("pre",[e._v("    cartproduct  ==\n          [] rollup\n          [pairlist swap [swons] dip]\n          step2\n  ")]),e._v("\n  The program works for aggregates of any type, and the two aggregates do not\n  have to be of the same type. If both are lists of numbers or sets of small numbers,\n  other variations are possible: By changing the pairing operator "),n("code",[e._v("pairlist")]),e._v("to, say, multiplication "),n("code",[e._v("*")]),e._v(", we obtain a program which produces a list\n  of all products. By further changing the accumulator "),n("code",[e._v("[]")]),e._v(" to the number\n  "),n("code",[e._v("0")]),e._v(" and the insertion operation "),n("code",[e._v("swons")]),e._v(" to, say, addition "),n("code",[e._v("+")]),e._v(",\n  we obtain a program which produces the sum of all "),n("var",[e._v("M \\times N")]),e._v(" products.\n  For two numeric aggregates of the same size, say "),n("var",[e._v("N")]),e._v(", another binary operator\n  can be defined, the "),n("kbd",[e._v("scalarproduct")]),e._v(":\n  "),n("pre",[e._v("        scalarproduct  ==\n              0 rollup                             (* accumulator *)\n              [ null2 ]\n              [ popd ]\n              [ uncons2 [* +] dip2 ]\n              tailrec\n  ")]),e._v("\n  It produces the sum of all "),n("var",[e._v("N")]),e._v(" products of pairs taken from corresponding\n  positions in the two aggregates.\n  "),n("h1",[e._v("Arithmetic operators")]),n("p",[e._v("\n    This section gives efficient implementation of several well-known functions which\n    are often used in the literature for demonstration purposes: the "),n("em",[e._v("factorial")]),e._v(",\n    the "),n("em",[e._v("Fibonacci")]),e._v("-function,\n    "),n("em",[e._v("exponentiation")]),e._v(" and the "),n("em",[e._v("greatest common divisor")]),e._v(". All of them are\n    often defined recursively, and of course they can be defined recursively in Joy.\n    Using one of several suitable recursion combinators they can be computed recursively\n    in Joy without a recursive definition. But recursive execution in any language\n    can be inefficient.\n  ")]),n("p",[e._v("\n    There are well known techniques for "),n("em",[e._v("removing linear recursion")]),e._v(', see for\n    example \\AX{Bauer and W\\"ossner}{1982 Chapter 4}{Bauer-Woessner:82}. The same topic\n    is discussed in \\AX{Henson}{1987 Chapter 4}{Henson:87} using the useful concept\n    of '),n("em",[e._v("eureka definition")]),e._v("s due to Burstall and Darlington. These involve creative\n    steps in the production of more efficient versions of programs, and hence would\n    be difficult to perform by an optimising program.\n  ")]),n("p",[e._v("\n    Several of the functions to be defined require a little program to be executed a\n    number of times. A useful combinator for this is "),n("kbd",[e._v("times")]),e._v(". It requires\n    the program to be repeated as the top element of the stack and the required number\n    of repetitions to be the second element on the stack.\n  ")]),n("p",[e._v("\n    The factorial of a number "),n("var",[e._v("n")]),e._v(" is simply the product of "),n("var",[e._v("n")]),e._v(" factors\n    from "),n("var",[e._v("1")]),e._v(" to "),n("var",[e._v("n")]),e._v(". To compute it using "),n("code",[e._v("times")]),e._v(", a small\n    program has to be pushed on top of the number "),n("var",[e._v("n")]),e._v(" which is the parameter.\n    The number itself will be consumed by "),n("code",[e._v("times")]),e._v(". The program works on\n    two other numbers on the stack. One of these is the accumulating parameter, it\n    has to start at "),n("var",[e._v("1")]),e._v(". The other is the next factor to be used by the program\n    with which to multiply the accumulator. The multiplication has to be done without\n    losing the factor, so it has to be duplicated first. Apart from doing the multiplication,\n    the program also has to increment the factor using the successor operator "),n("kbd",[e._v("succ")]),e._v(".\n    The program which is the parameter to "),n("code",[e._v("times")]),e._v(" thus is\n  ")]),n("pre",[e._v("        [dup  [*]  dip  succ]\n  ")]),e._v("\n  Before the "),n("code",[e._v("times")]),e._v(" combinator can get to work on the parameter\n  "),n("var",[e._v("n")]),e._v(" and the quoted program, the accumulator and the first factor have to\n  be placed in position, below the parameter "),n("var",[e._v("n")]),e._v(". Both begin with the value\n  "),n("var",[e._v("1")]),e._v(", so the "),n("code",[e._v("rolldown")]),e._v(" operator can be used to push these two\n  values below "),n("var",[e._v("n")]),e._v(". Finally, after "),n("code",[e._v("times")]),e._v(" has completed, the stack\n  will contain the required accumulator value but also on top of that the next factor.\n  The latter is simply "),n("code",[e._v("pop")]),e._v("ped off. The entire definition of "),n("kbd",[e._v("fact")]),e._v("is:\n  "),n("pre",[e._v("        fact == 1 1 rolldown [dup [*] dip succ] times pop\n  ")]),n("p",[e._v("\n    The "),n("em",[e._v("Fibonacci")]),e._v(" function can be computed in a similar way. Again there is\n    a certain computation that has to be repeated a number of times as given by the\n    parameter "),n("var",[e._v("n")]),e._v(". Again the computation involves two further numbers, the\n    larger one is to be replaced by their sum, and the smaller one is to be replaced\n    by the former larger one. Adding the two must not destroy the original larger number,\n    so again it has to be "),n("code",[e._v("dup")]),e._v("licated. The addition is then performed under\n    the control of "),n("code",[e._v("dip")]),e._v(". Then the two numbers are "),n("code",[e._v("swap")]),e._v("ped.\n    This describes the little program that serves as the parameter to the "),n("code",[e._v("times")]),e._v("  combinator. Before it can start, the two initial values "),n("var",[e._v("0")]),e._v(" and "),n("var",[e._v("1")]),e._v("  have to be placed below the parameter "),n("var",[e._v("n")]),e._v(" with "),n("code",[e._v("rolldown")]),e._v(".\n    When it has completed, the required accumulated sum is the second element, and\n    the top element, the useless next summand, is "),n("code",[e._v("pop")]),e._v("ped. So this is the\n    definition of "),n("kbd",[e._v("fib")]),e._v(":\n  ")]),n("pre",[e._v("        fib  ==  0 1 rolldown [dup [+] dip swap] times pop\n  ")]),e._v("\n  This version of the Fibonacci function requires a computation time which is\n  a linear function of the parameter "),n("var",[e._v("n")]),e._v(".\n  "),n("p",[e._v("\n    The recursive version of the Fibonacci function requires quadratic computation time.\n    Since the result values are not very large, it is often used as a test program.\n    What is of interest is the number of recursive calls made during the computation,\n    to be divided by the total time it took. To obtain the number of recursive calls\n    it is often convenient to use a variant of the Fibonacci function, sometimes called\n    "),n("kbd",[e._v("nfib")]),e._v(". It has the property that the value returned is the same as the\n    number of calls made during recursive execution. The following are recursive definitions\n    of Fibonacci and its variant:\n  ")]),n("pre",[e._v("    r-fib  ==  [small] []      [pred dup pred [r-fib ] app2 +     ] ifte\n      r-nfib ==  [small] [pop 1] [pred dup pred [r-nfib] app2 + succ] ifte\n  ")]),e._v("\n  These are recursive definitions which of course are intended to run in quadratic\n  time. The following is a definition of "),n("kbd",[e._v("nfib")]),e._v(" which uses accumulators to\n  run in linear time. Of course it does not measure its own runtime, it is included\n  here to illustrate a programming technique.\n  "),n("pre",[e._v("        nfib  ==  1 1 rolldown [dup [+ succ] dip swap] times pop\n  ")]),n("p",[e._v("\n    The next two programs are for "),n("em",[e._v("binary operator")]),e._v("s which compute functions\n    of two parameters: the "),n("em",[e._v("exponentiation")]),e._v(" function and the "),n("em",[e._v("greatest common divisor")]),e._v(".\n    Exponentiation can be computed by performing a certain operation as many times\n    as given by the exponent. This description again suggests using the "),n("code",[e._v("times")]),e._v("  combinator to execute a quoted program several times. The operation to be repeated\n    consists in multiplying an accumulator by the base which is the second parameter.\n    So it is necessary to construct a little program from the base which for every\n    call will multiply by the base. Assuming that the base is in the right position\n    on the stack, the program is easily constructed, by\n  ")]),n("pre",[e._v("        [*] cons\n  ")]),e._v("\n  Before the "),n("em",[e._v("constructed program")]),e._v(" can be handed to "),n("code",[e._v("times")]),e._v(",\n  the initial value "),n("var",[e._v("1")]),e._v(" has to be placed as an accumulator below the two numbers\n  which are the two parameters, the base and the exponent. This is done by "),n("code",[e._v("1 rollup")]),e._v(".\n  To get the two parameters into the order appropriate for "),n("code",[e._v("cons")]),e._v(" it is\n  necessary to perform a "),n("code",[e._v("rotate")]),e._v(" first. So here is the "),n("kbd",[e._v("exp")]),e._v(" operator:\n  "),n("pre",[e._v("        exp  ==  1 rotate [*] cons times\n  ")]),e._v("\n  The technique of first constructing a program (here by "),n("code",[e._v("cons")]),e._v(")\n  and then supplying it to a combinator (here "),n("code",[e._v("times")]),e._v(") is very useful in\n  Joy.\n  "),n("p",[e._v("\n    The next program computes the greatest common divisor of two numbers, using "),n("em",[e._v("Euclid's algorithm")]),e._v(".\n    The algorithm uses two numbers and repeatedly takes the remainder after dividing\n    one by the other. The remainder obtained is then used to replace the dividend.\n    The process is repeated as long as the potential divisor is positive. So, unlike\n    the previous programs, we cannot use the "),n("code",[e._v("times")]),e._v(" combinator. Instead\n    a combinator called "),n("code",[e._v("while")]),e._v(" is used which resembles while-loops in imperative\n    languages. It takes two parameters: the while-part is a quoted program which must\n    return a truth value, and the do-part is a quoted program which can compute anything.\n    The while-part in the following "),n("kbd",[e._v("gcd")]),e._v(" program is of course very similar\n    to a corresponding part in the "),n("code",[e._v("fib")]),e._v(" program.\n  ")]),n("pre",[e._v("    gcd  ==  [0 >] [dup [rem] dip swap] while pop\n  ")]),n("p",[e._v("\n    Two other arithmetic functions that are sometimes useful are for computing the "),n("kbd",[e._v("sum")]),e._v("  or the "),n("kbd",[e._v("product")]),e._v(" of a set or a list of numbers. Both are best implemented\n    by "),n("kbd",[e._v("step")]),e._v("ping through all members of the set or list, doing additions\n    or multiplications with an accumulator every time. The initial accumulator value,\n    "),n("code",[e._v("0")]),e._v(" or "),n("code",[e._v("1")]),e._v(", is first pushed onto the stack below the parameter\n    set or list. For comparison, the third line below gives a definition of the "),n("kbd",[e._v("size")]),e._v("  operator which is applicable to any aggregate. The fourth line below gives a definition\n    of a similar operator\n    "),n("kbd",[e._v("size2")]),e._v(" for determining the total number of elements in a list of aggregates.\n    If these aggregates are themselves lists, then their members are counted but not\n    the members of their sublists.\n  ")]),n("pre",[e._v("    sum     ==  0  swap  [+       ]  step\n      product ==  1  swap  [*       ]  step\n      size    ==  0  swap  [pop succ]  step\n      size2   ==  0  swap  [size  + ]  step\n  ")]),e._v("\n  A generalisation of "),n("code",[e._v("size2")]),e._v(" for counting the leaves in recursive\n  lists or trees is "),n("kbd",[e._v("treesize")]),e._v(", defined later.\n  "),n("h1",[e._v("Sorted sequences")]),n("p",[e._v("\n    The "),n("em",[e._v("sequence type")]),e._v("s of Joy are the "),n("em",[e._v("string type")]),e._v(" and the "),n("em",[e._v("list type")]),e._v(".\n    Values of these types can be ordered. Strings contain just characters, but lists\n    may contain anything. So for lists it only makes sense to speak of ordering if\n    the elements are characters or integers or something else that has an ordering\n    defined on it.\n  ")]),n("p",[e._v("\n    An informal description of the "),n("em",[e._v("quicksort")]),e._v(" algorithm is this:\n  ")]),n("pre",[e._v('To sort a sequence S :\n  1       If    S is small (has only 0 or 1 element)\n  2             then it is sorted already, leave it alone\n                else    (S has at least one element)\n  3                     using     the first of S\n                                  as a "pivot" for comparison,\n                                  split the rest of S into two portions -\n                                  those that are less than the pivot\n                                  and those that are not\n                        separately sort both portions P1 and P2\n  4                     concatenate    the now sorted lesser portion,\n                                       the pivot, and\n                                       the sorted other portion.\n  ')]),e._v("\n  The following is a definitions of an operator "),n("kbd",[e._v("qsort")]),e._v(" which uses\n  the above algorithm. But instead of using explicit "),n("em",[e._v("binary recursion")]),e._v(" it uses\n  the "),n("kbd",[e._v("binrec")]),e._v(" combinator. This is like the "),n("code",[e._v("linrec")]),e._v(" combinator\n  except that it recurses twice, once each on the top two element of the stack. The\n  recursions again occur between the rec1-part and the rec2-part. The program also\n  uses another combinator "),n("kbd",[e._v("split")]),e._v(" which takes as parameter an aggregate and\n  above that a quoted program which must return a truth value. The "),n("code",[e._v("split")]),e._v("combinator returns two aggregates, containing those elements for which the test yields\n  "),n("code",[e._v("false")]),e._v(" and those for which it yields "),n("code",[e._v("true")]),e._v(". The "),n("code",[e._v("split")]),e._v("combinator has access to the remainder of the stack which in this case contains the\n  pivot. So the test determines whether the pivot is "),n("code",[e._v(">")]),e._v(" than the element\n  being examined.\n  "),n("pre",[e._v("    qsort  ==\n  1       [ small ]\n  2       [ ]\n  3       [ uncons [>] split ]\n  4       [ swap23 cons concat ]\n          binrec\n  ")]),n("p",[e._v("\n    Sometimes it is required to sort a list of aggregates on the basis of their first\n    elements. In that case it is necessary to supply to the comparison operator "),n("code",[e._v(">")]),e._v("  not the pivot and the element to be apportioned by "),n("code",[e._v("split")]),e._v(", but their\n    first elements instead. This is conveniently done by the "),n("kbd",[e._v("app2")]),e._v(" combinator\n    which applies a quoted program to two elements on top of the stack and replaces\n    them by whatever values the programs return.\n  ")]),n("pre",[e._v("    qsort1  ==\n  1       [ small ]\n  2       [ ]\n  3       [ uncons [[first] app2 > ] split ]\n  4       [ swap23 cons concat ]\n          binrec\n  ")]),n("p",[e._v("\n    Note that in part 3 when the first element of the pivot has to be compared with the\n    first element of the aggregate to be apportioned, the first element of the pivot\n    is being extracted every time. It would perhaps be more efficient if the first\n    element of the pivot is extracted just once, as soon as the pivot is available.\n    In that case it is necessary to take the pivot apart with\n    "),n("code",[e._v("unswons")]),e._v(", but this has to be done by "),n("code",[e._v("dip")]),e._v("ping below the\n    rest of the list still to be sorted. Then the quotation parameter to "),n("code",[e._v("split")]),e._v("  just needs to take out the "),n("code",[e._v("first")]),e._v(" of the current aggregate and compare\n    it with the first of the pivot. After "),n("code",[e._v("split")]),e._v(" has done its job, the\n    pivot has to be re-assembled by "),n("code",[e._v("swons")]),e._v(", but this now has to be done\n    below the two portions with "),n("kbd",[e._v("dip2")]),e._v(". So part 3 can be replaced by\n  ")]),n("pre",[e._v("3       [ uncons [unswons] dip [first >] split [swons] dip2 ]\n  ")]),n("p",[e._v("\n    Sometimes it might be necessary to sort a list of items on the basis not of their\n    first element but on their size or their second or third element or even the size\n    of the second of the third element. For the last example it would only be necessary\n    to use "),n("code",[e._v("[third second size]")]),e._v(" instead of "),n("code",[e._v("[first]")]),e._v(" in the\n    "),n("code",[e._v("qsort1")]),e._v(" program. But it would be impossible to anticipate all alternative\n    sorting bases for a library, and it would be awkward to have to write the appropriate\n    sorting program on every special occasion. It is possible to write a general quicksort\n    program which takes as an additional parameter something like\n    "),n("code",[e._v("[first]")]),e._v(" or "),n("code",[e._v("[third second size]")]),e._v(". The "),n("kbd",[e._v("mk-qsort")]),e._v("  combinator does just that:\n  ")]),n("pre",[e._v("    mk_qsort ==\n          [ [small] [] ] dip\n          [ app2 >] cons [split] cons [uncons] swoncat\n          [ swap23 cons concat ]\n          binrec\n  ")]),e._v("\n  It begins in line 1 by inserting the standard if-part and then-part below\n  its parameters. In line 2 it uses the parameter to build a "),n("em",[e._v("constructed program")]),e._v(",\n  the required rec1-part. Then in line 3 it pushes the standard rec2-part. At this\n  point the top five elements of the stack are the list to be sorted and above that\n  the four program parts needed for "),n("code",[e._v("binrec")]),e._v(". The latter now executes. For\n  example the program\n  "),n("pre",[e._v("        [third second size]  mk-qsort\n  ")]),e._v("\n  will sort a list of lists of three or more elements whose third member are\n  aggregates of two or more elements. It will sort according to the size of the second\n  of the third element.\n  "),n("p",[e._v("\n    The binary operator "),n("kbd",[e._v("insert")]),e._v(" takes a sorted sequence and a potential new\n    member as parameters, it returns a new sequence with the additional member inserted\n    in the appropriate position. Here is a draft program:\n  ")]),n("pre",[e._v("To insert an item into a sorted sequence :\n  1       If    the sequence is empty or\n                 its first element is >= than the item\n  2             then add the new item in the front of the sequence\n  3             else    set aside the first item of the sequence\n                        recurse with the rest of the sequence and the new item\n  4                     add the previously set aside first item to the front\n  ")]),e._v("\n  The disjunction in line 1 is best handled by the "),n("kbd",[e._v("disjoin")]),e._v(" operator\n  on programs. It expects two quoted programs which return a truth value, and it returns\n  a single quoted program which computes their disjunction. So line 1 consists of two\n  quoted programs one of them tests whether the sequence is empty, the other tests\n  whether its first element is "),n("code",[e._v(">=")]),e._v(" than the item to be inserted. The\n  "),n("code",[e._v("disjoin")]),e._v(" operator then produces their disjunction. The resulting program\n  is the if-part for the "),n("code",[e._v("linrec")]),e._v(" combinator. The other three parts are\n  now quite obvious. So the definition in Joy is:\n  "),n("pre",[e._v("    insert ==\n  1       [ pop null ]  [ [first] dip ]  disjoin\n  2       [ swons ]\n  3       [ [uncons] dip ]\n  4       [ cons ]\n          linrec\n  ")]),n("p",[e._v("\n    Two sorted sequences can be "),n("kbd",[e._v("merge")]),e._v("d into a single sequence which respects\n    the original ordering. Here is a very informal algorithm for a recursive version:\n  ")]),n("pre",[e._v("To merge two sorted sequences : \n          If    the first sequence is empty,\n                then throw it away and return the second sequence.\n          If the second sequence is empty,\n                then throw it away and return the first sequence.\n          (Both sequences are non-empty, so both have a first element:)\n          If the first of the first sequence is less than the first of the second,\n                then    set the lesser element aside,\n                        recurse using the rest of the first sequence,\n                        prepend the previously set aside element.\n          If the first of the first sequence is greater than the first of the second,\n                then set the lesser element aside,\n                        recurse using the rest of the second sequence,\n                        prepend the previously set aside element.\n         (The two first elements of the sequences are equal:)\n          Default  \n                set both first elements aside,\n                recurse using the rests of both sequences,\n                prepend the two previously set aside elements.\n  ")]),n("p",[e._v("\n    Like just about all programming languages, Joy has an if-then-else construct ("),n("code",[e._v("ifte")]),e._v(")\n    for two-way branching. Multiway branching can be achieved by nested "),n("code",[e._v("ifte")]),e._v("s,\n    but this can become difficult to read. Joy has another combinator for multi-way\n    branching borrowed from Lisp. The combinator "),n("kbd",[e._v("cond")]),e._v(" expects one parameter\n    which is a list of cases. The last case is the default case, the other cases each\n    consist of a condition or if-part and a program or then-part The condition is a\n    quoted program in front of the program. Execution of the "),n("code",[e._v("cond")]),e._v(" combinator\n    tests successive conditions, and for the first condition that yields\n    "),n("code",[e._v("true")]),e._v(" the associated program is executed. If none of the conditions\n    is true, the default case is executed. The informal algorithm given earlier now\n    translates into the following recursive definition of "),n("kbd",[e._v("r-merge")]),e._v(":\n  ")]),n("pre",[e._v("    r-merge  ==\n          [ [ [null] pop]\n            [ [pop null] swap pop]\n            [ [unswons2 <] [uncons] dip r-merge cons]\n            [ [unswons2 >] uncons swap23 r-merge cons]\n            [ uncons2 r-merge cons cons] ]\n          cond\n  ")]),n("p",[e._v("\n    As may be seen from the earlier informal version and the above Joy version, for each\n    case the program recurses at most once. Therefore the program has the pattern of\n    "),n("em",[e._v("linear recursion")]),e._v(". However, because there are three cases in which recursion\n    occurs, it is not possible to use the "),n("code",[e._v("linrec")]),e._v(" combinator. However,\n    Joy has a combinator "),n("kbd",[e._v("condlinrec")]),e._v(" which has features of "),n("code",[e._v("cond")]),e._v("  and "),n("code",[e._v("linrec")]),e._v(". The combinator "),n("code",[e._v("condlinrec")]),e._v(" also expects one\n    parameter which is a list of cases. Again the last case is the default case, and\n    the other cases consist of a list of two or three quoted programs. If there are\n    just two parts, then they are called the if-part and the then-part. Their meaning\n    is as for "),n("code",[e._v("cond")]),e._v(". If there are three parts, then they are called the\n    if-part, the rec1-part and the rec2-part. In that case linear recursion occurs\n    between execution of the rec1-part and the rec2-part. The following is a non-recursive\n    definition of "),n("kbd",[e._v("merge")]),e._v(":\n  ")]),n("pre",[e._v("    merge ==\n          [ [ [null] [pop] ]\n            [ [pop null] [swap pop] ]\n            [ [unswons2 <] [[uncons] dip] [cons] ]\n            [ [unswons2 >] [uncons swap23] [cons] ]\n            [ [uncons2] [cons cons] ] ]\n          condlinrec;\n  ")]),n("p"),n("p",[e._v("\n    Sometimes it is necessary to merge two lists of aggregates on the basis of their\n    first elements. In that case the comparisons "),n("code",[e._v("<")]),e._v(" and "),n("code",[e._v(">")]),e._v("  should not be applied to the elements of the sequences but to their first members.\n    A simple solution is to replace the two comparisons respectively by the following\n    two:\n  ")]),n("pre",[e._v("        [first] app2 <              [first] app2 >\n  ")]),e._v("\n  So the definition of the "),n("kbd",[e._v("merge1")]),e._v(" operator could be\n  "),n("pre",[e._v("    merge1 ==\n          [ [ [null] [pop] ]\n            [ [pop null] [swap pop] ]\n            [ [unswons2 [first] app2 <] [[uncons] dip] [cons] ]\n            [ [unswons2 [first] app2 >] [uncons swap23] [cons] ]\n            [ [uncons2] [cons cons] ] ]\n          condlinrec\n  ")]),e._v("\n  The definition of "),n("code",[e._v("merge")]),e._v(" (and especially "),n("code",[e._v("merge1")]),e._v(")\n  could be optimised so that the "),n("code",[e._v("unswons")]),e._v(" (and the "),n("code",[e._v("first")]),e._v(")\n  is not done repeatedly for each comparison. As the definitions stand, they are easy\n  to understand and work correctly.\n  "),n("h1",[e._v("Big sets and dictionaries")]),n("p",[e._v("\n    Computer words are short bit-sequences and a common size is 32. These can be used\n    to implement small sets of small numbers 0..31, with a few common set operations\n    implemented in hardware. Joy uses this in its "),n("em",[e._v("set type")]),e._v(". But often it\n    is necessary to have either much larger sets or sets of larger elements. Such a\n    "),n("em",[e._v("big set type")]),e._v(" can be implemented in various ways: as unordered lists, as\n    ordered lists, as unbalanced trees or as balanced trees. Each implementation method\n    has its advantages and disadvantages. The following implementation of big sets\n    in terms of ordered lists has been adapted from \\AX{Bird and Wadler}{1988 p 230\n    ff}{Bird:88}.\n  ")]),n("p",[e._v("\n    The empty set is represented as an empty list, in this library it is written as "),n("kbd",[e._v("bs-new")]),e._v(".\n  ")]),n("pre",[e._v("LIBRA (* big sets *)\n\n  bs-new == [];\n  ")]),n("p",[e._v("\n    One very important binary set operation is "),n("em",[e._v("union")]),e._v(". The two parameters are\n    sorted lists, and the returned value also has to be a sorted list. It would appear\n    that the two lists should be simply\n    "),n("kbd",[e._v("merge")]),e._v("d. But if they have an element in common, then the returned list\n    would then contain the element twice. However, in sets any element should occur\n    at most once. This consideration affects the default case, the last case of the\n    program list which is the parameter. The case occurs when the first elements of\n    the two parameter lists are equal. So in the definition of "),n("kbd",[e._v("bs-union")]),e._v("  instead of saving and later restoring both, only one is saved and later restored.\n  ")]),n("pre",[e._v("bs-union ==\n          [ [ [null] [pop] ]\n            [ [pop null] [swap pop] ]\n            [ [unswons2 <] [[uncons] dip] [cons] ]\n            [ [unswons2 >] [uncons swap23] [cons] ]\n            [ [rest [uncons] dip] [cons] ] ]\n          condlinrec;\n  ")]),n("p",[e._v("\n    The same situation arises for "),n("em",[e._v("insert")]),e._v("ing or adding a new member to a set.\n    If the new member is already in the set, then it should not be inserted again.\n    So if the first member of the current list is equal to the candidate new member,\n    then the candidate is just popped off in the third line below. In the definition\n    of "),n("kbd",[e._v("bs-insert")]),e._v(" the only recursion occurs in the last, the default case.\n  ")]),n("pre",[e._v("bs-insert ==\n          [ [ [pop null] [swons] ]\n            [ [[first] dip >] [swons] ]\n            [ [[first] dip =] [pop] ]\n            [ [[uncons] dip] [cons] ] ]\n          condlinrec;\n  ")]),n("p",[e._v("\n    The next operator tests for "),n("em",[e._v("member")]),e._v("ship, so it must return a truth value.\n    If the list is null or its first element is "),n("code",[e._v(">")]),e._v(" than the candidate,\n    then "),n("code",[e._v("false")]),e._v(" is returned. If the first element is "),n("code",[e._v("=")]),e._v(" to\n    the candidate, then "),n("code",[e._v("true")]),e._v(" is returned. In the default case, when the\n    relation is "),n("code",[e._v("<")]),e._v(", the list has to be inspected recursively further\n    down. So the case must contain two programs to effect the recursion. However, on\n    the way back from the recursion, the last returned truth value is the one to be\n    used. Hence no further action is required, and the second program is just "),n("code",[e._v("[]")]),e._v(".\n    This is the definition of "),n("kbd",[e._v("bs-member")]),e._v(":\n  ")]),n("pre",[e._v("bs-member ==\n          [ [ [pop null] [pop2 false] ]\n            [ [[first] dip >] [pop2 false] ]\n            [ [[first] dip =] [pop2 true] ]\n            [ [[rest] dip] [] ] ]\n          condlinrec;\n  ")]),n("p",[e._v("\n    The same device is used in the default case of the definition of "),n("kbd",[e._v("bs-differ")]),e._v("  for finding the "),n("em",[e._v("difference")]),e._v(" between two sets. As may be seen, there are\n    two further recursive cases, for "),n("code",[e._v("<")]),e._v(" and "),n("code",[e._v(">")]),e._v(", and one\n    of them uses the same device again.\n  ")]),n("pre",[e._v("bs-differ ==\n          [ [ [null] [pop]]\n            [ [pop null] [pop pop []] ]\n            [ [unswons2 <] [[uncons] dip] [cons] ]\n            [ [unswons2 >] [rest] [] ]\n            [ [[rest] dip rest] [] ] ]\n          condlinrec;\n  ")]),n("p",[e._v("\n    The next definition is for "),n("kbd",[e._v("bs-delete")]),e._v(", it "),n("em",[e._v("delete")]),e._v("s a specified\n    member from a set, if it is a member at all. The only recursive case is the default\n    case.\n  ")]),n("pre",[e._v("bs-delete ==\n          [ [ [pop null] [pop] ]\n            [ [[first] dip >] [pop] ]\n            [ [[first] dip =] [pop rest] ]\n            [ [[uncons] dip] [cons] ] ]\n          condlinrec.\n  ")]),n("p",[e._v("\n    The operations of inserting or deleting members into or from a set are essentially\n    special cases of taking unions or differences with unitsets. So the following definitions\n    might have been given instead of the earlier, more efficient definitions:\n  ")]),n("pre",[e._v("    bs-insert  ==  unitlist bs-union;\n      bs-delete  ==  unitlist bs-differ;\n  ")]),n("p",[e._v("\n    A dictionary is a way of implementing finite functions as argument-value pairs. A\n    pair is best implemented in Joy as a two element list. The totality of pairs is\n    then essentially a big set, and any of the ways of implementing these is suitable\n    here. If the argument part of pairs is subject to an ordering relation, the sets\n    of pairs can be implemented as lists ordered in accordance with the first element,\n    the argument of the pairs. Not surprisingly then, some of the code to follow is\n    reminiscent of code for "),n("code",[e._v("qsort1")]),e._v(" and "),n("code",[e._v("merge1")]),e._v(". The following\n    is a library for the "),n("em",[e._v("dictionary type")]),e._v(". A new dictionary is created by "),n("kbd",[e._v("d-new")]),e._v(".\n    A predicate "),n("kbd",[e._v("d-null")]),e._v(" returns "),n("code",[e._v("true")]),e._v(" or "),n("code",[e._v("false")]),e._v(" according\n    as the parameter dictionary is empty or not. New pairs are added by "),n("kbd",[e._v("d-add")]),e._v(",\n    they are inserted in the correct place based on the ordering of the first member\n    of the pairs. The union or difference of two dictionaries is given by the two binary\n    operators "),n("kbd",[e._v("d-union")]),e._v(" and "),n("kbd",[e._v("d-differ")]),e._v(". A single pair is removed\n    by the binary operator "),n("kbd",[e._v("d-rem")]),e._v(", it removes the pair whose first member\n    matches the given query parameter. Instead of a test for membership there is a\n    binary operator\n    "),n("kbd",[e._v("d-look")]),e._v(" which extracts the first pair whose first element matches the\n    query.\n  ")]),n("p",[e._v("\n    Only the program for one of the operators will be developed here, the program for\n    "),n("kbd",[e._v("d-union")]),e._v(":\n  ")]),n("pre",[e._v("To form the union of two dictionaries D1 and D2:\n  1       If D2 is empty, pop it off and return just D1\n  2       If D1 is empty, retain D2, pop D1 and return D2\n  3       Extract    the first pairs from D1 and D2,\n                     from both pairs compare their firsts with <\n          If the comparison is true,\n                     below D2, uncons D1 into its first\n                     and rest\n                     recurse anonymously on the rest of D1 and D2\n                     cons the saved first pair from D1\n                     into the result\n  4       Extract    the first pairs from D1 and D2,\n                     from both pairs compare their firsts with >\n          If the comparison is true,\n                     uncons D2, put its first below D2\n                     recurse anonymously on D1 and the rest of D2\n                     cons the saved first pair from D2\n                     into the result\n          Default (the firsts of the first pairs of D1 and D2\n                      are =):\n                     uncons both D1 and D2 into their\n                     first and rest,\n                     recurse on the two rests to form their union,\n                     cons the two saved firsts into the result.\n  ")]),e._v("\n  In the default case both first pairs are retained, so that if one is deleted,\n  the other one, which may well have a different second component, is still available.\n  "),n("p",[e._v("\n    As may be seen, the "),n("kbd",[e._v("d-union")]),e._v(" operator is very similar to the "),n("code",[e._v("bs-union")]),e._v("  operator. The other three operators "),n("kbd",[e._v("d-differ")]),e._v(", "),n("kbd",[e._v("d-look")]),e._v(" and\n    "),n("kbd",[e._v("d-rem")]),e._v(" are similar to their counterparts for big sets. The entire library\n    is the following:\n  ")]),n("pre",[e._v('LIBRA (* dictionary *)\n\n  d_new   == [];\n  d_null  == null;\n  d_add   ==\n          [ [ [pop null] [swons] ]\n            [ [[first] dip [first] app2 >=] [swons] ]\n            [ [[uncons] dip] [cons] ] ]\n          condlinrec;\n  d_union ==\n          [ [ [null] [pop] ]\n            [ [pop null] [popd] ]\n            [ [unswons2 [first] app2 <] [[uncons] dip] [cons] ]\n            [ [unswons2 [first] app2 >] [uncons swap23] [cons] ]\n            [ [uncons2] [cons cons] ] ]\n          condlinrec;\n  d_differ ==\n          [ [ [null] [pop]]\n            [ [pop null] [pop pop []] ]\n            [ [unswons2 [first] app2 <] [[uncons] dip] [cons] ]\n            [ [unswons2 [first] app2 >] [rest] [] ]\n            [ [[rest] dip rest] [] ] ]\n          condlinrec;\n  d_look  == [dup] dip\n          [ [ [pop null] [pop pop "not found"] ]\n            [ [[first first] dip >] [pop pop "not found"] ]\n            [ [[first first] dip =] [pop first] ]\n            [ [[rest] dip] [] ] ]\n          condlinrec;\n  d_rem   ==\n          [ [ [pop null] [pop] ]\n            [ [[first first] dip >] [pop] ]\n            [ [[first first] dip =] [pop rest] ]\n            [ [[uncons] dip] [cons] ] ]\n          condlinrec.\n  ')]),e._v("\n  The definitions of big sets and dictionaries are part of the library file\n  "),n("kbd",[e._v("TYPLIB.JOY")]),e._v(".\n  "),n("h1",[e._v("Trees")]),n("p",[e._v("\n    Apart from the "),n("em",[e._v("aggregate type")]),e._v("s it is useful to have another type, the\n    "),n("em",[e._v("tree type")]),e._v(". These are lists which can contain lists as members which might\n    contain lists as members and so on. Formally define a "),n("em",[e._v(" leaf")]),e._v(" to be anything\n    which is not a list. Then a "),n("em",[e._v(" tree")]),e._v(" is defined to be either a leaf or a\n    list of trees. Sometimes one needs the concept of a "),n("em",[e._v(" proper tree")]),e._v(" -- this\n    is just a list of trees. Trees are similar to other aggregates, but since the tree\n    datatype is recursive, a special treatment is generally needed.\n  ")]),n("p",[e._v("\n    Just as there is the "),n("code",[e._v("step")]),e._v(" combinator to step through the elements\n    of an aggregate, so there is a "),n("kbd",[e._v("treestep")]),e._v(" combinator to step through the\n    leaves of a tree. For example, the following are the already familiar program for\n    computing the sum of the numbers in an aggregate and a similar program for computing\n    the sum of the numbers in a tree:\n  ")]),n("pre",[e._v("            sum  ==  0 swap [+]     step\n          treesum  ==  0 swap [+] treestep\n  ")]),e._v("\n  In the same way, the following are a familiar program and a new one for determining\n  the "),n("code",[e._v("size")]),e._v(" of an aggregate and the "),n("kbd",[e._v("treesize")]),e._v(" of a tree:\n  "),n("pre",[e._v("            size  ==  0 swap [pop succ]     step\n          treesize  ==  0 swap [pop succ] treestep\n  ")]),e._v("\n  Similarly, the following are a familiar program and a new one for shunting\n  members of an aggregate or a tree, respectively, into an initially empty list:\n  "),n("pre",[e._v("            shunt  ==  [swons]     step\n          treeshunt  ==  [swons] treestep\n  ")]),e._v("\n  For the binary operator "),n("kbd",[e._v("treeshunt")]),e._v(" the all leaves will appear in\n  the result list, but in reverse order.\n  "),n("p",[e._v("\n    A tree may be flattened completely, losing its entire internal structure but retaining\n    the order of the leaves by the unary operator\n    "),n("kbd",[e._v("treeflatten")]),e._v(":\n  ")]),n("pre",[e._v("        treeflatten  ==  [] swap treeshunt reverse\n  ")]),n("p",[e._v("\n    From a given tree we can obtain the reverse list of its leaves by\n  ")]),n("pre",[e._v("        []  swap  treeshunt\n  ")]),e._v("\n  But this may not be what is wanted. To reverse the tree while retaining its\n  structure it is necessary to reverse the top level list, reverse the second level\n  lists, reverse the third level lists and so on. For tasks such as this Joy has a\n  ternary combinator "),n("kbd",[e._v("treegenrec")]),e._v(" for general recursion through trees. It\n  is used like this:\n  "),n("pre",[e._v("        [O1]  [O2]  [C]  treerecgen\n  ")]),e._v("\n  Here "),n("code",[e._v("[O1]")]),e._v(" must be a program applicable to leaves,\n  "),n("code",[e._v("[O2]")]),e._v(" must be an operator applicable to lists, and "),n("code",[e._v("[C]")]),e._v(" must\n  be a combinator applicable to lists with operators such as "),n("code",[e._v("[O2]")]),e._v(". Different\n  choices of the three quotation parameters yield surprisingly different operators\n  for trees or combinators applicable to trees. Using this combinator the unary "),n("kbd",[e._v("treereverse")]),e._v("operator is defined by\n  "),n("pre",[e._v("        treereverse  ==  [] [reverse] [map] treegenrec\n  ")]),n("p",[e._v("\n    The same "),n("code",[e._v("treegenrec")]),e._v(" combinator can be used to define a unary combinator\n    "),n("kbd",[e._v("treemap")]),e._v(" which takes a tree and quoted program as parameters and returns\n    a tree of the same structure but with each leaf as modified by the program parameter.\n  ")]),n("pre",[e._v("        treemap  ==  [] [map] treegenrec\n  ")]),n("p",[e._v("\n    The same combinator can be used to define a unary combinator\n    "),n("kbd",[e._v("treefilter")]),e._v(" which expects a tree and a quoted predicate. What is returned\n    is a tree of the same structure but with only those leaves which pass the test\n    predicate.\n  ")]),n("pre",[e._v("        treefilter  ==  [] swap orlistfilter [map] treegenrec\n  ")]),e._v("\n  The first portion, "),n("code",[e._v("[] swap")]),e._v(" just inserts the required "),n("code",[e._v("[O1]")]),e._v("which in this case does nothing. Following that is a modification of the test predicate,\n  to be explained presently. The rest of the definition is familiar.\n  "),n("pre",[e._v("        treefilter  ==  [] swap orlistfilter [map] treegenrec\n  ")]),e._v("\n  The "),n("code",[e._v("[O2]")]),e._v(" operator to be used here is constructed from the test\n  predicate "),n("code",[e._v("[P]")]),e._v(" by "),n("kbd",[e._v("orlistfilter")]),e._v(", which constructs\n  "),n("pre",[e._v("        [ [ [list] [P] disjoin ]  filter ]\n  ")]),e._v("\n  The "),n("code",[e._v("orlistfilter")]),e._v(" is defined in two steps:\n  "),n("pre",[e._v("        orlist  ==  [list] swap disjoin\n          orlistfilter  ==  orlist [filter] cons\n  ")]),e._v("\n  An operator to remove all leaves from a tree, but retaining its list structure\n  is "),n("kbd",[e._v("treestrip")]),e._v(", defined as follows:\n  "),n("pre",[e._v("        treestrip  ==  [list] treefilter\n  ")]),n("p",[e._v("\n    Trees cannot have lists as leaves, but otherwise they are very flexible. In particular\n    they can be used as queues. The following is a small collection of operations for\n    manipulating trees when the focus is only on their leaves. A new empty tree is\n    generated by "),n("kbd",[e._v("t-new")]),e._v(". A new leaf or a whole tree of leaves is added\n    to an existing tree by the operator "),n("kbd",[e._v("t-add")]),e._v("; it always ensures that the\n    tree is of a form suitable for the remaining operators. The tree predicate "),n("kbd",[e._v("t-null")]),e._v("  tests whether the tree is empty. It first has to prepare the tree by ensuring that\n    it does not consist of lists of lists and so on which ultimately only contain the\n    empty list. Since this is also required by two other operators, the preparing is\n    done by a hidden unary operator. Two other operator "),n("kbd",[e._v("t-front")]),e._v(" and "),n("kbd",[e._v("t-rem")]),e._v("  produce, respectively, the first leaf together with the remainder of the tree,\n    or just the remainder of the tree after removing the first leaf. Both operators\n    first have to check that the tree is non-empty; if it is, then an error is reported.\n    A leaf or proper tree can be turned into a suitable form by "),n("kbd",[e._v("t-reset")]),e._v(".\n  ")]),n("p",[e._v("\n    The implementation is as follows. A proper tree is always a list, and an empty tree\n    starts off by "),n("kbd",[e._v("t-new")]),e._v(" as an empty list. Anything can be added by "),n("kbd",[e._v("t-add")]),e._v("  to an existing tree, and this has to ensure that the result has a suitable standard\n    form. The same is true for "),n("kbd",[e._v("t-reset")]),e._v(" which firstmakes a copy of an existing\n    tree. The other operators, "),n("kbd",[e._v("t-null")]),e._v(", "),n("kbd",[e._v("t-front")]),e._v(" and "),n("kbd",[e._v("t-rem")]),e._v("  all require the tree to be in a suitable standard form. This is done by "),n("code",[e._v("prepare")]),e._v("  which is defined using "),n("kbd",[e._v("condlinrec")]),e._v(". If the tree is "),n("code",[e._v("null")]),e._v(",\n    it is left as it is. If the "),n("code",[e._v("first")]),e._v(" is "),n("code",[e._v("null")]),e._v(", then the "),n("code",[e._v("rest")]),e._v("  is taken and "),n("code",[e._v("condlinrec")]),e._v(" recurses. If the "),n("code",[e._v("first")]),e._v(" of the\n    "),n("code",[e._v("first")]),e._v(" is a list, then that is "),n("code",[e._v("unswonsed")]),e._v(", "),n("code",[e._v("condlinrec")]),e._v("  recurses and on return does nothing further. In all other cases the tree is left\n    as it is.\n  ")]),n("pre",[e._v('HIDE                                                    (* tree *)\n      error        ==  "non-empty tree needed for" putchars putchars abort;\n      prepare      ==  [ [ [null] [] ]\n                       [ [first null] [rest] [] ]\n                       [ [first first list] [[unswons] infra] [] ]\n                       [ [] ] ]\n                       condlinrec\n  IN\n      t-new        ==  [];\n      t-reset      ==  dup  unitlist unitlist;\n      t-add        ==  unitlist unitlist cons;\n      t-null       ==  prepare\n                       dup null;\n      t-front      ==  prepare\n                       [null]\n                       ["t-front\\n" error]\n                       [dup first first]\n                       ifte;\n      t-rem        ==  prepare\n                       [null]\n                       ["t-rem\\n" error]\n                       [unswons unswons [swons] dip]\n                       ifte\n  END\n  ')]),n("p",[e._v("\n    The definitions of trees is partof the library file "),n("kbd",[e._v("TYPLIB.JOY")]),e._v(".\n  ")])])}]};t.a=s}});