webpackJsonp([19],{GXMS:function(e,n,t){var o=t("wBJh");"string"==typeof o&&(o=[[e.i,o,""]]),o.locals&&(e.exports=o.locals);t("rjj0")("1e1a9c16",o,!1,{sourceMap:!1})},MgQF:function(e,n,t){"use strict";var o=function(){var e=this.$createElement;this._self._c;return this._m(0)};o._withStripped=!0;var r={render:o,staticRenderFns:[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("article",[t("h1",[e._v("Recursion Theory and Joy")]),t("i",[e._v(" by Manfred von Thun ")]),t("p",[t("em",[e._v("Abstract:")]),e._v(" Joy is a functional programming language which is not based\n    on the application of functions to arguments but on the composition of functions.\n    Many topics from the theory of computability are particularly easy to handle within\n    Joy. They include the parameterisation theorem, the recursion theorem and Rice's\n    theorem. Since programs are data, it is possible to define a Y-combinator for recursion\n    and several variants. It follows that there are self-reproducing and self-describing\n    programs in Joy. Practical programs can be written without recursive definitions\n    by using several general purpose recursion combinators which are more intuitive\n    and more efficient than the classical ones.\n  ")]),t("p",[t("em",[e._v("Keywords:")]),e._v(" functional programming, functionals, computability, diagonalisation,\n    program = data, diagonalisation, self-reproducing and self-describing programs,\n    hierarchy of recursion combinators, elimination of recursive definitions.\n  ")]),t("hr"),t("h2",[e._v("Introduction")]),e._v("\n  This paper describes some aspects of the language from the perspective of recursive\n  function theory.\n  "),t("p",[e._v("\n    A deep result in the theory of computability concerns the elimination of recursive\n    definitions. To use the stock example, the\n    "),t("em",[e._v("factorial")]),e._v(" function can be "),t("em",[e._v(" defined")]),e._v(" recursively in Joy by\n  ")]),t("pre",[e._v("        factorial  ==\n              [0 =] [pop 1] [dup 1 - factorial *] ifte\n  ")]),e._v("\n  The definition is then "),t("em",[e._v(" used")]),e._v(" in programs like this:\n  "),t("pre",[e._v("        5\n          factorial\n  ")]),e._v("\n  Because in Joy programs can be manipulated as data, the factorial function\n  can also be computed recursively without a recursive definition, as follows:\n  "),t("pre",[e._v("        5\n          [ [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte ]\n          [dup cons] swap concat dup cons i\n  ")]),e._v('\n  The second line in this program does much the same as the body of the definition\n  of factorial, but it is a quoted program. The third line first transforms this into\n  another longer quoted program which performs "anonymous" recursion, and then the\n  final '),t("kbd",[e._v("i")]),e._v(" combinator essentially dequotes this program causing its execution.\n  "),t("p",[e._v("\n    The third line implements Joy's counterpart of the "),t("em",[e._v("Y\n    combinator")]),e._v(" of the lambda calculus and of combinatory logic. Exactly the same\n    line can be used to cause anonymous recursion of other functions which are normally\n    defined recursively.\n  ")]),t("p",[e._v("\n    Joy has other combinators which make recursive execution of programs more succinct.\n    (Of course it is also possible in Joy to compute the factorial function more efficiently\n    with iteration instead of recursion.)\n  ")]),t("p",[e._v("\n    The remainder of this paper deals with various aspects of the theory of computability,\n    in particular the theory of "),t("em",[e._v("recursive\n    function")]),e._v("s. The next section gives a recursive definition of a recursion combinator.\n    Following that is a section dealing with various well known and elementary theorems\n    from recursive function theory. The next section then proves a fixpoint theorem\n    for Joy. The theorem implies the existence of self-reproducing programs, as shown\n    in the following section. There is also some discussion of the effect of evaluation\n    order on termination. The topic of the next section is Rice's theorem for Joy.\n    Then there is a section describing further self-reproducing and self-describing\n    programs. Another recursion combinator is constructed in the next section. The\n    final section discusses the more practical recursion combinators of Joy. Previous\n    knowledge of the field of recursion theory is not assumed.\n  ")]),t("h2",[e._v("Recursion and its elimination")]),e._v("\n  The factorial function and the Fibonacci function are often used to illustrate two\n  different recursion patterns, although both are most efficiently computed non-recursively.\n  This section follows tradition by using these two functions. The ultimate aim is\n  to show how\n  "),t("em",[e._v("recursive definition")]),e._v("s of functions can be eliminated to obtain a (closed)\n  form of a program for "),t("em",[e._v("recursive execution")]),e._v(".\n  "),t("p",[e._v("\n    In conventional notation the "),t("em",[e._v("factorial")]),e._v(" function can be defined recursively\n    like this:\n  ")]),t("pre",[e._v("    r-fac(n)  =  if n = 0 then 1 else n * r-fac(n - 1)\n  ")]),e._v("\n  It is obvious that in conventional notation the definitions need the formal\n  parameter "),t("code",[e._v("n")]),e._v(". Joy was designed to eliminate formal parameters in definitions,\n  and the factorial function would be defined in Joy like this:\n  "),t("pre",[e._v("    r-fac1  ==  [0 =] [pop 1] [dup 1 - r-fac1 *] ifte\n  ")]),e._v("\n  The suffix "),t("code",[e._v("1")]),e._v(" serves to distinguish this definition from a later\n  version. The RHS of the definition contains three quotations: an if-part, a then-part\n  and an else-part. These serve as parameters to the "),t("kbd",[e._v("ifte")]),e._v(" combinator. The\n  if-part tests for equality with "),t("code",[e._v("0")]),e._v(", and if that is true then the then-part\n  "),t("kbd",[e._v("pop")]),e._v("s off the parameter and replaces it with the result\n  "),t("code",[e._v("1")]),e._v(". Otherwise the else-part is executed, which\n  "),t("kbd",[e._v("dup")]),e._v("licates the parameter, subtracts "),t("code",[e._v("1")]),e._v(" from the top copy,\n  calls "),t("code",[e._v("r-fac1")]),e._v(" recursively on that and, when that call has returned with\n  a value, multiplies that with the original. Using a more Joy-like idiom:\n  "),t("pre",[e._v("    r-fac1  ==  [null] [succ] [dup pred r-fac1 *] ifte\n  ")]),e._v("\n  This uses the "),t("kbd",[e._v("null")]),e._v(" predicate in the if-part, the\n  "),t("kbd",[e._v("succ")]),e._v("essor function in the then-part and the\n  "),t("kbd",[e._v("pred")]),e._v("ecessor operator in the else-part.\n  "),t("p",[e._v("\n    In conventional notation the "),t("em",[e._v("Fibonacci")]),e._v(" function is defined recursively\n    like this:\n  ")]),t("pre",[e._v("    r-fib(n)   =  if n <= 1 then n else r-fib(n - 1) + r-fib(n - 2)\n  ")]),e._v("\n  A more or less literal translation into Joy is the following:\n  "),t("pre",[e._v("    r-fib1  ==  [small] [] [pred dup [r-fib1] dip pred r-fib1 +] ifte\n  ")]),e._v("\n  The if-part uses the "),t("kbd",[e._v("small")]),e._v(" predicate, which for numeric parameters\n  yields "),t("code",[e._v("true")]),e._v(" for "),t("code",[e._v("0")]),e._v(" and for\n  "),t("code",[e._v("1")]),e._v(". The then-part is the empty quotation "),t("code",[e._v("[]")]),e._v(", when executed\n  it does nothing. In the else-part "),t("code",[e._v("r-fib1")]),e._v(" has to call itself twice, once\n  each for the two parameters that have been prepared by "),t("code",[e._v("dup")]),e._v(". The "),t("kbd",[e._v("dip")]),e._v("combinator applies the quotation "),t("code",[e._v("[r-fib1]")]),e._v(" to the earlier version, and\n  the later version, after "),t("code",[e._v("pred")]),e._v(" has done its job, is handled directly\n  by "),t("code",[e._v("r-fib1")]),e._v(". A cleaner version is\n  "),t("pre",[e._v("    r-fib2  ==  [small] [] [pred dup pred [r-fib2] app2 +] ifte\n  ")]),e._v("\n  The "),t("kbd",[e._v("app2")]),e._v(" combinator applies the quoted\n  "),t("code",[e._v("[r-fib2]")]),e._v(" twice, to each of the two numbers on top of the stack.\n  "),t("p",[e._v("\n    It will help if the minor differences between the definitions of the factorial function\n    and the Fibonacci function are eliminated. In particular this concerns the patterns\n    of the recursive calls. In the body of "),t("code",[e._v("r-fac1")]),e._v(" the direct recursive\n    call has been replaced by its quotation and "),t("kbd",[e._v("app1")]),e._v(", which applies the\n    quotation just once, to the single number. So here are two other versions, they\n    have aligned to make comparisons easier.\n  ")]),t("pre",[e._v("    r-fac2  ==  [ null] [succ] [     dup pred [r-fac2] app1 *] ifte\n      r-fib2  ==  [small] [    ] [pred dup pred [r-fib2] app2 +] ifte\n  ")]),e._v("\n  The task of eliminating the recursion in the RHS of the definitions amounts\n  to this: The occurrences of the quoted programs\n  "),t("code",[e._v("[r-fac2]")]),e._v(" and "),t("code",[e._v("[r-fib2]")]),e._v(" have to be replaced by the quoted\n  RHS. But this will introduce those same quotes again, and these have to be replaced\n  by the RHS, and so on "),t("em",[e._v(" ad\n  infinitum")]),e._v(". It seems impossible.\n  "),t("p",[e._v("\n    One part of the solution is that the programs have to be given an extra parameter\n    which is to be used when the else-part is executed. The extra parameter will have\n    to contain whatever is necessary to enable the recursion inside the else-part.\n    But this means that the extra parameter will be somewhat in the way. Consequently\n    the if-part and the then-part need an extra "),t("code",[e._v("pop")]),e._v(" to remove the unneeded\n    parameter. Furthermore, in the else-part any preparatory work before the actual\n    recursion has to be done "),t("em",[e._v(" below")]),e._v(" the extra parameter using "),t("code",[e._v("dip")]),e._v(".\n    The one or two recursions are then to be effected by "),t("code",[e._v("app1")]),e._v(" and "),t("code",[e._v("app2")]),e._v(",\n    respectively. The two programs now look like this:\n  ")]),t("pre",[e._v("?-fac:  [[pop  null] [pop succ] [[dup pred     ] dip app1 *] ifte] ?\n  ?-fib:  [[pop small] [pop     ] [[pred dup pred] dip app2 +] ifte] ?\n  ")]),e._v("\n  To indicate that these are "),t("em",[e._v(" not")]),e._v(" recursive definitions, they are not\n  given as definitions at all. The "),t("code",[e._v("?")]),e._v("-symbol is left unanalysed at this\n  point, only this much can be said about it:\n  "),t("ol",[t("li",[e._v(" it takes the entire quoted program as a parameter and then produces another quoted\n      program with a special property.\n    ")]),t("li",[e._v(" it then executes this resulting program.\n    ")])]),e._v("\n  So the "),t("code",[e._v("?")]),e._v("-symbol denotes a strange combinator.\n  "),t("p",[e._v("\n    For comparison the three versions of the factorial program are listed here:\n  ")]),t("pre",[e._v("r-fac1 == [     null] [    succ] [ dup pred        r-fac1       *] ifte\n  r-fac2 == [     null] [    succ] [ dup pred       [r-fac2] app1 *] ifte\n  ?-fac:   [[pop  null] [pop succ] [[dup pred     ] dip      app1 *] ifte] ?\n  ")]),e._v("\n  And here are the three versions of the Fibonacci program:\n  "),t("pre",[e._v("r-fib1 == [    small] [        ] [ pred dup [r-fib1] dip r-fib1 +] ifte\n  r-fib2 == [    small] [        ] [ pred dup pred  [r-fib2] app2 +] ifte\n  ?-fib:   [[pop small] [pop     ] [[pred dup pred] dip      app2 +] ifte] ?\n  ")]),t("p",[e._v("\n    The recursion combinator must do this: At the point where\n    "),t("code",[e._v("?-fac")]),e._v(" uses "),t("code",[e._v("app1")]),e._v(" and where "),t("code",[e._v("?fib")]),e._v(" uses "),t("code",[e._v("app2")]),e._v("  they expect "),t("code",[e._v("?-fac")]),e._v(" and\n    "),t("code",[e._v("?fib")]),e._v(" on top of the stack. That is why the if-parts and the then-parts\n    each need an extra "),t("code",[e._v("pop")]),e._v(", and why the else-part has to do its initial\n    work from a "),t("code",[e._v("dip")]),e._v(". It all means that a recursion combinator has to supply\n    the RHS to itself as an extra parameter. In general, a recursion combinator expects\n    a program "),t("code",[e._v("[P]")]),e._v(" and it executes it in a special way. It must call "),t("code",[e._v("P")]),e._v("  but provide the extra parameter. This is the defining law for a recursion combinator\n    "),t("code",[e._v("?")]),e._v(" :\n  ")]),t("pre",[e._v("        [P]  ?   ==   [[P] ?]  P\n  ")]),t("p",[e._v("\n    How can a recursion combinator be defined? This can be done recursively and non-recursively.\n    Once the "),t("code",[e._v("?")]),e._v(" combinator is defined, it can be used to eliminate all\n    other recursive definitions. If a recursion combinator is defined recursively,\n    then this would be the only recursive definition that is needed. Here is a step-by-step\n    development of such a definition. The development is a fairly typical example of\n    how one can write Joy programs systematically. Start with the defining law:\n  ")]),t("pre",[e._v("        [P] ?\n      ==  [[P] ?]  P\n  ")]),e._v("\n  In the second line "),t("code",[e._v("P")]),e._v(" occurred twice, in quoted and unquoted form.\n  It will be simpler if it occurs in only one form, and that has to be the quoted form.\n  So, using the "),t("code",[e._v("i")]),e._v(" combinator,\n  "),t("pre",[e._v("    ==  [[P] ?]  [P]  i\n  ")]),e._v("\n  The two quotations are not exactly the same, but they can be produced from\n  two identical quotations:\n  "),t("pre",[e._v("    ==  [[P ?]  [[P] ?]  first  i\n  ")]),e._v("\n  Now the two identical quotations can be produced by the\n  "),t("code",[e._v("dup")]),e._v(" operator:\n  "),t("pre",[e._v("    ==  [[P] ?]  dup  first  i\n  ")]),e._v("\n  All that is needed now is to extract "),t("code",[e._v("[P]")]),e._v(" to the left:\n  "),t("pre",[e._v("    ==  [P]  [?]  cons  dup  first  i\n  ")]),e._v("\n  In this construction each line was equivalent to its one or two neighbours.\n  Hence the first and the last lines of this construction are equivalent:\n  "),t("pre",[e._v("        [P]  ?   ==   [P]  [?]  cons  dup  first  i\n  ")]),e._v("\n  Hence the following is a suitable recursive definition of a recursion combinator:\n  "),t("pre",[e._v("        ?   ==   [?]  cons  dup  first  i\n  ")]),t("p",[e._v("\n    It is useful to think of the RHS as being composed of two parts: the first is\n  ")]),t("pre",[e._v("        [?]  cons  dup  first\n  ")]),e._v("\n  and the second part is just "),t("code",[e._v("i")]),e._v(". The first part is just a function\n  which takes one quoted program as a parameter and produces two quoted programs as\n  values:\n  "),t("pre",[e._v("        [P]  [?]  cons  dup  first\n          [[P]  ?]  dup  first                    (by cons)\n          [[P]  ?]  [[P]  ?]  first               (by dup)\n          [[P]  ?]  [P]                           (by first)\n  ")]),e._v("\n  The second part of the definition is "),t("code",[e._v("i")]),e._v(", which effectively dequotes\n  the topmost "),t("code",[e._v("[P]")]),e._v(" and hence executes\n  "),t("code",[e._v("P")]),e._v(". So the next reduction step depend on what\n  "),t("code",[e._v("P")]),e._v(" actually does.\n  "),t("p",[e._v("\n    An alternative recursive definition may be constructed:\n  ")]),t("pre",[e._v("        [P]  ?\n      ==  [[P] ?]  P\n      ==  [[P] ?]  [P]  i\n      ==  [P]  [?]  cons  [P]  i\n      ==  [P]  [P]  [[?] cons]  dip  i\n      ==  [P]  dup  [[?] cons]  dip  i\n  ")]),e._v("\n  The resulting alternative recursive definition is\n  "),t("pre",[e._v("        ?   ==   dup  [[?] cons]  dip  i\n  ")]),e._v("\n  It follows that the two RHSs of the two equivalent definitions are equal:\n  "),t("pre",[e._v("        [?]  cons  dup  first  i   ==   dup  [[?] cons]  dip  i\n  ")]),e._v("\n  (Note that cancellation of the trailing "),t("code",[e._v("i")]),e._v(" combinator on both\n  sides is not valid in general, though it would be valid here.)\n  "),t("p",[e._v("\n    We now have a recursive definition of recursion. Computationally this is quite adequate,\n    the recursive definition of any one of the\n    "),t("code",[e._v("?")]),e._v(" combinators really does make it possible to eliminate all other\n    recursive definitions. Some of the following sections deal with the elimination\n    of recursion even for the recursion combinators.\n  ")]),t("p",[e._v("\n    The recursive definition of a recursion combinator can of course also be given in\n    other languages. For an example in the lambda calculus see "),t("a",{attrs:{href:"refs.html#{Henson87}"}},[e._v("{Henson87}")]),e._v(".\n    For an example in ML see "),t("a",{attrs:{href:"refs.html#{Sokolowski91}"}},[e._v("{Sokolowski91}")]),e._v(".\n  ")]),t("h2",[e._v("Theorems in recursion theory")]),e._v("\n  The theory of "),t("em",[e._v("computability")]),e._v(" treats various formalisms which independently\n  aim to capture the essence of computation. These formalisms include Turing machines,\n  the lambda calculus, Markov algorithms, register machines, flow charts and any of\n  the conventional programming languages. Each formalism deals with various specifications:\n  for the Turing formalism the specifications are particular Turing machines, for the\n  Markov formalism the specifications are particular Markov algorithms, for the programming\n  languages they are particular programs, and so on. Some results in the theory concern\n  connections between the formalisms, whereas others concern connections within the\n  same formalism.\n  "),t("p",[e._v("\n    The main results in the theory can be divided into two groups: those concerned with\n    the relationships between two such formalisms and those concerned with just one.\n  ")]),t("p",[e._v("\n    The principal results in the first group are that the formalisms are all equivalent,\n    in this sense: Given any two formalisms, for any specification in the one formalism\n    there is a specification in the other formalism such that the two specifications\n    compute the same function. Proofs of such results are always constructive, by exhibiting\n    an algorithm which converts any specification in the one formalism into a specification\n    in the other.\n  ")]),t("p",[e._v("\n    Results in the second group concern just one formalism and often take this form:\n    For any specification S1 having a certain property there is another specification\n    S2 such that the two specifications S1 and S2 are related in some special way.\n    Proofs are again constructive, by exhibiting algorithms for converting S1 into\n    S2.\n  ")]),t("p",[e._v("\n    The algorithms of both groups can be expressed in any of the formalisms. The constructive\n    proofs then look like this: There is a specification S (in formalism F) with the\n    capacity of transforming any specification S1 (in formalism F1) into a specification\n    S2 (in formalism F2, not necessarily different from F1) such that the two specification\n    S1 and S2 are related in a special way. Since the formalisms are universal, the\n    algorithms can be written in the formalism itself, as another specification S.\n    The results then take this form: There is a specification S such that for every\n    specification S1 the result of applying S to S1 yields the required S2.\n  ")]),t("p",[e._v("\n    Historically the theory of computability has been mainly couched in terms of "),t("em",[e._v("recursive function")]),e._v('s,\n    a collection of functions built from a small base by means of a small number of\n    constructors. These functions take natural numbers as arguments and give natural\n    numbers as values. By means of a theoretically elegant (but computationally unfeasible)\n    mapping called Gödel numbering, linguistic entities such as expressions can be\n    assigned a unique number. In this way the functions can be made to "talk about\n    themselves". Any syntactic operation on linguistic entities has a counterpart purely\n    arithmetical operation on natural numbers which are the Gödel numbers of these\n    entities. The theorems are basic to any proper understanding of the the foundations\n    of computer science. But the proofs, when not hand-waiving by appeals to Church\'s\n    thesis, tend to be forbidding.\n  ')]),t("p",[e._v("\n    The ease of writing S depends crucially on how well the formalism can handle its\n    own specifications. Often it is necessary to use encodings of S1 and S2 into a\n    form which the formalism can handle. In the worst case the encodings are truly\n    ghastly. In the best case the formalism can handle its own specifications very\n    naturally. This is sometimes expressed by the slogan "),t("em",[e._v("program = data")]),e._v(".\n    Most formalisms fare badly on this, including most programming languages.\n  ")]),t("p",[e._v("\n    Some languages can treat their own programs as data; they are Lisp, Snobol, Prolog\n    and their descendants, some macro generators and the command languages based on\n    them. Joy does it at least as well. In these languages programs can operate on\n    other programs or on other data to produce other programs which may then be executed.\n    Because of this, arithmetisation is not necessary, functions can take programs\n    rather than Gödel numbers of programs as arguments, and metatheoretic proof become\n    much easier. "),t("a",{attrs:{href:"refs.html#{Phillips92}"}},[e._v("{Phillips92}")]),e._v(" writes\n  ")]),t("blockquote",[e._v("\n    One might wonder how differently recursion theory might be viewed if it had arisen\n    out of practical developments instead of predating them.\n  ")]),e._v("\n  Indeed, one might speculate how much more natural computability theory would have\n  been if Lisp has been invented thirty years earlier. Readers might want to pursue\n  this topic, see the discussion in\n  "),t("a",{attrs:{href:"refs.html#{Hofstadter85}"}},[e._v("{Hofstadter85}")]),e._v(" starting on p 444, and his\n  very startling conclusion on p 449.\n  "),t("p",[e._v("\n    In Joy many metatheoretic proofs are easier still because there are no named formal\n    parameters. Consequently the difficult operation of substituting actual parameters\n    for formal parameters does not occur, and everything is algebra. Reasoning about\n    Joy programs will now be illustrated with a number of classical theorems.\n  ")]),t("p",[e._v("\n    A simple form of the "),t("em",[e._v("parametrisation theorem")]),e._v(" states: there is a recursive\n    function taking the Gödel number of an "),t("em",[e._v("\n    n")]),e._v("-ary function F1 as one argument and taking the Gödel number of a numeral as\n    a further argument such that the value of this recursive function is the Gödel\n    number of an "),t("em",[e._v(" n-1")]),e._v("-ary function F2 which is obtained by substituting the\n    value of the numeral for the first argument of F1.\n  ")]),t("p",[e._v("\n    Here is the same theorem for Joy. An "),t("em",[e._v("operand")]),e._v(" is a numeral (or any other\n    constant) or a quotation.\n  ")]),t("pre",[e._v("        For any program P and operand X\n              there is a program Q such that\n                  Q   ==   [Q] i  ==  X  P\n  ")]),e._v("\n  The required program "),t("code",[e._v("Q")]),e._v(" is just the concatenation. But the theorem\n  can be strengthened:\n  "),t("pre",[e._v("        There is a program O such that\n              for any program P and operand X\n                  there is a program Q such that\n                      X [P] O  ==  [Q] and\n                      Q  ==  [Q] i  ==  X [P] i  ==  X P\n  ")]),e._v("\n  The required program "),t("code",[e._v("O")]),e._v(" is "),t("code",[e._v("cons")]),e._v(":\n  "),t("pre",[e._v("        X [P] O  ==  X [P] cons  ==  [X P]  ==  [Q]\n  ")]),e._v("\n  The theorem is rather trivial in Joy. The formalisation of the proof is an\n  overkill. However, many proofs later on will have the same structure, and it may\n  help to get used to that.\n  "),t("p",[e._v("\n    The parametrisation theorem generalises to any number "),t("em",[e._v(" m")]),e._v(" of arguments\n    that are parametrised. Consequently it is often called the\n    "),t("em",[e._v("S-m-n theorem")]),e._v(", see "),t("a",{attrs:{href:"refs.html#{Rogers67}"}},[e._v("{Rogers67}")]),e._v('. The\n    "S" stands for "substitution" - it means that '),t("em",[e._v(" m")]),e._v(" of the "),t("em",[e._v(" n")]),e._v(" formal\n    parameters are replaced by fixed values. In Joy notation repeated\n    "),t("code",[e._v("cons")]),e._v(" operations can parameterise for any "),t("em",[e._v(" m")]),e._v(", simply by repeating\n    "),t("code",[e._v("cons")]),t("em",[e._v(" m")]),e._v(" times.\n  ")]),t("p",[e._v("\n    In recursive function theory it is possible for functions to take other functions\n    as parameters, and since functions are untyped, they can take themselves as parameter.\n    One consequence ot the S-m-n theorem is the "),t("em",[e._v("diagonalisation theorem")]),e._v(":\n    There is a recursive function taking as argument the Gödel number of a function\n    which takes at least one parameter, and giving as value the Gödel number of the\n    function obtained from the given one by substituting itself for the parameter.\n  ")]),t("p",[e._v("\n    Again, the counterpart in Joy is trivial.\n  ")]),t("pre",[e._v("        For any program P\n              there is a program Q such that\n                  [Q] i  ==  Q  ==  [P] P\n  ")]),e._v("\n  The required quoted "),t("code",[e._v("[Q]")]),e._v(" is "),t("code",[e._v("[[P] P]")]),e._v(". The stronger\n  form is:\n  "),t("pre",[e._v("        There is a program O such that\n              for any program P\n                  there is a program Q such that\n                      [P] O  ==  [Q]  and\n                      [Q] i  ==  Q  ==  [P] dup i  ==  [P] P\n  ")]),e._v("\n  The required program "),t("code",[e._v("O")]),e._v(" is "),t("code",[e._v("dup cons")]),e._v(". Proof:\n  "),t("pre",[e._v("        [P] O  ==  [P] dup cons  ==  [P] [P] cons  ==  [[P] P]  ==  [Q]\n          [Q] i  ==  [[P] P] i  ==  [P] P  ==  Q\n  ")]),e._v("\n  So in Joy the short program\n  "),t("pre",[e._v("        dup  cons\n  ")]),e._v("\n  implements diagonalisation.\n  "),t("p",[e._v("\n    It may help to see diagonalisation in action for a small program:\n  ")]),t("pre",[e._v("        [dup reverse concat] dup cons i\n      ==  [dup reverse concat] [dup reverse concat] cons i       (by dup)\n      ==  [[dup reverse concat] dup reverse concat] i             (by cons)\n      ==  [dup reverse concat] dup reverse concat                 (by i)\n      ==  [dup reverse concat] [dup reverse concat] reverse concat(by dup)\n      ==  [dup reverse concat] [concat reverse dup] concat        (by reverse)\n      ==  [dup reverse concat concat reverse dup]                 (by concat)\n  ")]),e._v("\n  So the program "),t("code",[e._v("[dup reverse concat]")]),e._v(" diagonalised and run produces\n  its own palindrome. Most programs cannot be self-applied because it would breach\n  typing. But here are a few, readers might like to see what they do:\n  "),t("pre",[e._v("        []\n          [reverse 42]\n          [42 pop]\n          [pop]\n          [dup cons]\n  ")]),t("p",[e._v("\n    In "),t("a",{attrs:{href:"refs.html#{Smullyan61}"}},[e._v("{Smullyan61}")]),e._v(" theory of formal systems of\n    (character) strings, the\n    "),t("em",[e._v(" norm")]),e._v(" or diagonalisation of a string "),t("code",[e._v("X")]),e._v(" is defined to be "),t("code",[e._v("X")]),e._v("  followed by its own Gödel number in dyadic notation. In Joy the detour via Gödel\n    number is eliminated by using quotations.\n  ")]),t("p",[e._v("\n    We now consider two reductions. The first is this:\n  ")]),t("pre",[e._v("        [P]  dup  i\n      ==  [P]  [P]  i                     (by dup)\n      ==  [P]   P                         (by i)\n  ")]),e._v("\n  The second is this:\n  "),t("pre",[e._v("        [P]  dup  cons  i\n      ==  [P]  [P]  cons  i               (by dup)\n      ==  [[P]  P]  i                     (by cons)\n      ==  [P]  P                          (by i)\n  ")]),e._v("\n  So the two reductions come to the same, and hence their first lines are identical:\n  "),t("pre",[e._v("        [P]  dup  i   ==   [P]  dup  cons  i\n  ")]),e._v("\n  But this holds for all "),t("code",[e._v("[P]")]),e._v(". So we may infer\n  "),t("pre",[e._v("        dup  cons  i   ==   dup  i\n  ")]),t("h2",[e._v("The fixpoint theorem and the y combinator")]),e._v("\n  An important result in computability is the "),t("em",[e._v("recursion theorem")]),e._v(", see for\n  example\n  "),t("a",{attrs:{href:"refs.html#{Rogers67}"}},[e._v("{Rogers67}")]),e._v(". It states:\n  "),t("blockquote",[e._v("\n    For every function P there is a Gödel number of a function Q such that the result\n    of applying the function P to the Gödel number of Q is the Gödel number of a function\n    identical with Q.\n  ")]),e._v("\n  The theorem says that for every function P which is used to edit code for computing\n  functions, there is a program Q which will compute the same function before and after\n  the editing. So Q is a fixpoint, a program not affected by P. Fixpoint theorems are\n  about programs\n  "),t("code",[e._v("P")]),e._v(" (rather than about the functions which they compute).\n  "),t("p",[e._v("\n    Here is an equivalent version for Joy:\n  ")]),t("pre",[e._v("        For any program P\n              there is a program Q such that\n                  [Q] i   ==   Q   ==   [Q] P\n  ")]),e._v("\n  The required program "),t("code",[e._v("Q")]),e._v(" is\n  "),t("pre",[e._v("        [dup cons P] dup cons P\n  ")]),e._v("\n  The proof is as follows:\n  "),t("pre",[e._v("        [            Q           ]  i\n      ==  [[dup cons P]  dup cons P]  i                   (def Q)\n      ==   [dup cons P]  dup cons P                       (by i)\n      ==   [dup cons P] [dup cons P] cons P               (by dup)\n      ==  [[dup cons P]  dup cons P]  P                   (by cons)\n      ==  [            Q           ]  P                   (def Q)\n  ")]),t("p",[e._v("\n    The theorem may be strengthened. The transformation from\n    "),t("code",[e._v("P")]),e._v(" to "),t("code",[e._v("Q")]),e._v(" can be done by a simple program\n    "),t("code",[e._v("O")]),e._v(":\n  ")]),t("pre",[e._v("        There is a program O such that\n              for any program P\n                  there is a program Q such that\n                      [P] O   ==   [Q]   and\n                      [Q] i   ==   Q   ==   [Q] P\n  ")]),e._v("\n  The required program "),t("code",[e._v("O")]),e._v(" is\n  "),t("pre",[e._v("        [dup cons]  swap  concat  dup  cons\n  ")]),e._v("\n  The proof is as follows:\n  "),t("pre",[e._v("        [P] O\n      ==  [P]  [dup cons]  swap  concat  dup  cons        (def O)\n      ==  [dup cons]  [P]        concat  dup  cons        (by swap)\n      ==  [dup cons P]                   dup  cons        (by concat)\n      ==  [dup cons P]  [dup cons P]          cons        (by dup)\n      ==  [[dup cons P] dup cons P]                       (by cons)\n      ==  [Q]                                             (def Q)\n  ")]),e._v("\n  The fixpoint finding program "),t("code",[e._v("O")]),e._v(" is useful: henceforth it will\n  be called the "),t("kbd",[e._v("fix")]),e._v(" operator. We also define the\n  "),t("kbd",[e._v("y")]),e._v(" combinator for Joy:\n  "),t("pre",[e._v("        y   ==   fix  i\n  ")]),e._v('\n  This is the Joy counterpart of Curry\'s "paradoxical" '),t("em",[e._v("Y\n  combinator")]),e._v(" (uppercase), see "),t("a",{attrs:{href:"refs.html#{Curry58}"}},[e._v("{Curry58}")]),e._v(". This\n  combinator is well known in the literature on the lambda calculus and on combinatory\n  logic.\n  "),t("p",[e._v("\n    The recursion theorem traces its ancestry to Epimenides, Russell and Grelling (for\n    "),t("code",[e._v("[P]")]),e._v(" put "),t("code",[e._v("[i not]")]),e._v(", and to Gödel. In its general form\n    it is due to Kleene. Its proof is very cumbersome in just about all formalisms.\n    As can be seen from the above, in Joy the proof is very simple.\n  ")]),t("p",[e._v("\n    The S-m-n theorem is the basis for "),t("em",[e._v("partial evaluation")]),e._v(" or\n    "),t("em",[e._v("program specialisation")]),e._v(". A special case for this is the partial evaluator\n    "),t("em",[e._v("mix")]),e._v(" which can transform an interpreter into a compiler, and can transform\n    itself into a compiler generator.\n    "),t("a",{attrs:{href:"refs.html#{Jones92}"}},[e._v("{Jones92}")]),e._v(" shows that such transformations can\n    be done realistically only if the partial evaluator has primitives in terms of\n    which the fixpoint constructions of the recursion theorem can be implemented efficiently.\n    The two primitives chosen are in fact very close to Joy's "),t("code",[e._v("i")]),e._v(" combinator\n    and quotation.\n  ")]),t("p",[e._v("\n    The recursion theorem leads in a few steps to Rice's theorem, see\n    "),t("a",{attrs:{href:"refs.html#{Rogers67}"}},[e._v("{Rogers67}")]),e._v(", which encapsulates all the bad news\n    of computability theory: for example the "),t("em",[e._v("halting problem")]),e._v(", or the impossibility\n    of writing programs which check other programs - implementation, student exercises\n    - for correctness.\n  ")]),t("h2",[e._v("Some simple cases")]),e._v("\n  The theorem, in both forms, speaks of "),t("em",[e._v(" all")]),e._v(" programs\n  "),t("code",[e._v("P")]),e._v(". It is of some interest to see what happens when some simple actual\n  programs are chosen. Two particularly simple programs are\n  "),t("ol",[t("li",[e._v(" the empty program, which computes the identity function, and\n    ")]),t("li",[e._v(" the "),t("code",[e._v("i")]),e._v(" combinator program, which dequotes and executes a program on\n      top of the stack.\n    ")])]),t("p"),t("ol",[t("li",[e._v("\n      A frequently paraded corollary of the recursion theorem is the existence of "),t("em",[e._v("self-reproducing program")]),e._v("s.\n      When run, these program produce a replica of themselves. A suitably general definition\n      of self-reproducing programs is this: a program\n      "),t("code",[e._v("S")]),e._v(" is self-reproducing if this conditions holds:\n      "),t("pre",[e._v("        S  i   ==   S\n  ")]),e._v("\n      Note that "),t("code",[e._v("S")]),e._v(" is allowed to be arbitrarily complex, it does\n      not have to be just a quoted program. Such programs are obtained from the recursion\n      theorem by making "),t("code",[e._v("P")]),e._v(" compute the identity function. In Joy this is\n      represented most simply by the empty program, in quoted form "),t("code",[e._v("[]")]),e._v(".\n      (Alternatively, it is represented by the program "),t("code",[e._v("id")]),e._v(", in quoted form\n      "),t("code",[e._v("[id]")]),e._v(".)\n      "),t("pre",[e._v("        There is a program Q such that\n              [Q] i   ==   [Q]\n  ")]),e._v("\n      Proof: let "),t("code",[e._v("Q")]),e._v(" be the program\n      "),t("pre",[e._v("            [dup cons] dup cons\n  ")]),e._v("\n      Then the derivation is as follows:\n      "),t("pre",[e._v("        [[dup cons]  dup cons]  i\n      ==   [dup cons]  dup cons                           (by i)\n      ==   [dup cons] [dup cons] cons                     (by dup)\n      ==  [[dup cons]  dup cons]                          (by cons)\n  ")]),e._v("\n      Readers might like to be reminded of a self-replicating C-program:\n      "),t("pre",[e._v('  p="p=%c%s%c;main(){printf(p,34,p,34);}";main(){printf(p,34,p,34);}\n  ')]),e._v("\n      (Author unknown. Proving correctness is not easy.)\n      "),t("p",[e._v("\n        Related to self-reproducing programs are "),t("em",[e._v("self-describing\n        program")]),e._v("s. A program "),t("code",[e._v("S")]),e._v(" is self-describing if running it produces\n        a description of it. In Joy a program "),t("code",[e._v("S")]),e._v(" is self-describing if\n        this condition holds:\n      ")]),t("pre",[e._v("        S   ==   [S]\n  ")]),e._v("\n      Here is a self-describing program:\n      "),t("pre",[e._v("        [dup cons] dup cons\n      ==  [dup cons] [dup cons] cons                      (by dup)\n      ==  [[dup cons] dup cons]                           (by cons)\n  ")]),t("p")]),t("li",[e._v("\n      The other simple program to investigate is the "),t("code",[e._v("i")]),e._v(" combinator. Then\n      "),t("code",[e._v("[P]")]),e._v(" is "),t("code",[e._v("[i]")]),e._v(", and\n      "),t("code",[e._v("[Q]")]),e._v(" is "),t("code",[e._v("[[dup cons i] dup cons i]")]),e._v(". This is what happens:\n      "),t("pre",[e._v("        [[dup cons i]  dup cons i]  i\n      ==   [dup cons i]  dup cons i                       (by i)\n      ==   [dup cons i] [dup cons i]  cons i              (by dup)\n      ==  [[dup cons i]  dup cons i]  i                   (by cons)\n  ")]),e._v("\n      So this is a program that runs forever. This is the Joy counterpart of\n      what in the lambda calculus is selfapplication selfapplied. In both the reductions\n      do not terminate. In the lambda calculus the rule used is beta-reduction, the\n      substitution of actual for formal parameters. In Joy there are no formal parameters,\n      just algebraic simplification.\n      "),t("p",[e._v("\n        The "),t("code",[e._v("dup cons")]),e._v(" combination occurs so frequently that it is worth\n        introducing an operator "),t("kbd",[e._v("duco")]),e._v(" defined by\n      ")]),t("pre",[e._v("        duco   ==   dup  cons\n  ")]),e._v("\n      This will make proofs shorter both horizontally (because programs are shorter)\n      and vertically (because two steps are condensed into one).\n      "),t("p")]),t("li",[e._v("\n      The next kind of program is with "),t("code",[e._v("[P]")]),e._v(" =\n      "),t("code",[e._v("dup")]),e._v(". Then "),t("code",[e._v("[Q]")]),e._v(" is the quotation in the first line below,\n      and execution is as follows:\n      "),t("pre",[e._v("        [[duco dup] duco dup]  i\n      ==   [duco dup] duco dup                            (by i)\n      ==  [[duco dup] duco dup] dup                       (by duco)\n      ==  [[duco dup] duco dup] [[duco dup] duco dup]     (by dup)\n  ")]),e._v("\n      So this is an example of a program which when run produces two copies\n      of itself. The program in the second line is another\n      "),t("em",[e._v("self-describing program")]),e._v(", it produces two copies of itself.\n      "),t("p")]),t("li",[e._v("\n      The next program uses "),t("code",[e._v("[P]")]),e._v(" = "),t("code",[e._v("dup i")]),e._v(". Then execution starts\n      like this:\n      "),t("pre",[e._v("        [[duco dup i] duco dup i]  i\n      ==   [duco dup i] duco dup i                                (by i)\n      ==  [[duco dup i] duco dup i] dup i                         (by duco)\n      ==  [[duco dup i] duco dup i] [[duco dup i] duco dup i] i   (by dup)\n  ")]),e._v("\n      So this is another program that runs forever. In addition it leaves earlier\n      copies of itself on the stack. In an implementation it must run out of stack\n      space. The program in the second line is again self-describing, but it never\n      finishes what would be a description of infinitely many copies of itself.\n      "),t("p",[e._v("\n        Another program that does much the same is\n      ")]),t("pre",[e._v("        [[duco dup dip] duco dup dip]\n  ")]),t("p")]),t("li",[e._v("\n      In the introduction a program was given which computes the factorial function without\n      being defined recursively. Here are the first few steps in the execution of that\n      program, those that are independent of the numeric parameter that is provided\n      to the program. To save space, the "),t("code",[e._v("duco")]),e._v(" operator is used.\n      "),t("pre",[e._v("        [ [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte ]\n          y\n      ==  [ [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte ]\n          fix  i                                                  (by y)\n      ==  [ [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte ]\n          [duco] swap concat duco  i                              (def fix)\n      ==  [duco] [ [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte ]\n          concat duco  i                                          (by swap)\n      ==  [ duco [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte ]\n          duco  i                                                 (by concat)\n      ==  [[ duco [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte ]\n             duco [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte ]\n          i                                                       (by duco)\n      ==  [ duco [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte ]\n          duco [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte     (by i)\n      ==  [[ duco [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte ]\n             duco [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte ]\n          [pop 0 =] [pop pop 1] [[dup 1 -] dip i *] ifte          (by duco)\n  ")]),e._v("\n      At this point the numeric parameter for the computation will be needed.\n      The "),t("code",[e._v("ifte")]),e._v(" combinator will execute its if-part. That results in the\n      long two-line quotation being popped off the stack and the parameter being compared\n      with 0. If that evaluates to\n      "),t("code",[e._v("true")]),e._v(", the then-part is executed with the parameters and the two-line\n      quotation still on top of the stack, The then-part pops both and replaces them\n      by 1. But if the if-part returns\n      "),t("code",[e._v("false")]),e._v(", the else-part is executed, again with the parameter and the\n      two-line quotation on top of the stack.\n      "),t("p",[e._v("\n        First the two-line quotation is set aside by "),t("code",[e._v("dip")]),e._v(", the parameter\n        is duplicated and the top copy decremented. Only then the two-line quotation\n        will be executed by "),t("code",[e._v("i")]),e._v(". The effect is to construct a clone of itself\n        with "),t("code",[e._v("duco")]),e._v(", pushing the same if-part, then-part and else-part for\n        the contained\n        "),t("code",[e._v("ifte")]),e._v(". When that eventually returns, the old parameter and above\n        it the factorial of the decremented parameter copy are finally multiplied to\n        give the required factorial of the original parameter.\n      ")])])]),t("h2",[e._v("Evaluation order")]),e._v("\n  Most theoretical and practical programming languages use "),t("em",[e._v("formal\n  parameter")]),e._v("s in definitions of functions (and procedures). These functions are\n  called with expressions as the "),t("em",[e._v("actual\n  parameter")]),e._v("s. There are two ways of doing this: "),t("em",[e._v("normal\n  order")]),e._v(", also known as "),t("em",[e._v("call by name")]),e._v(", and "),t("em",[e._v("applicative\n  order")]),e._v(", also known as "),t("em",[e._v("call by value")]),e._v(". In normal order the unevaluated\n  expressions are substituted for the formal parameters, and the expressions will be\n  evaluated only if the body of the function requires it.\n  "),t("p",[e._v("\n    In applicative order the expressions are evaluated first and that value is substituted\n    for the formal parameter. If the value of a parameter expression is used repeatedly\n    in the body of the function, then normal order requires repeated evaluation of\n    the expression, whereas applicative order requires only one evaluation. On the\n    other hand, if the body does not require the value at all, then applicative order\n    will have wasted time trying to evaluate the expression. If that evaluation does\n    not terminate at all, then the call of the function will fail to terminate under\n    applicative order although it would have terminated under normal order. Consequently\n    there are some functions that are less defined under applicative order evaluation\n    than they are under normal order.\n  ")]),t("p",[e._v("\n    The Y combinator of the lambda calculus does not work at all for applicative order.\n    No matter what the function is, the call with the Y combinator will try to do the\n    unending sequence of substitutions and hence fail to terminate. Therefore a different\n    version of the Y combinator has to be used, see "),t("a",{attrs:{href:"refs.html#{Stoy77}"}},[e._v("{Stoy77}")]),e._v(",\n    "),t("a",{attrs:{href:"refs.html#{Henson87}"}},[e._v("{Henson87}")]),e._v(", "),t("a",{attrs:{href:"refs.html#{Paulson92}"}},[e._v("{Paulson92}")]),e._v(",\n    "),t("a",{attrs:{href:"refs.html#{Winskel93}"}},[e._v("{Winskel93}")]),e._v(".\n  ")]),t("p",[e._v("\n    In Joy there are no formal parameters, there is no substitution, and hence strictly\n    speaking there is no evaluation order. Joy functions take their actual parameters\n    as values from the stack, and in a way this "),t("em",[e._v(" resembles")]),e._v(" applicative order.\n    The "),t("code",[e._v("y")]),e._v(" combinator of Joy always terminates correctly provided that\n    the quoted program and any of its actual parameters did get onto the stack, and\n    provided that the quoted program terminates. So there is a difference between the\n    Y combinator of the lambda calculus under applicative order, and the "),t("code",[e._v("y")]),e._v("  combinator of Joy. What is the reason? Consider again, for an arbitrary program\n    "),t("code",[e._v("[P]")])]),t("pre",[e._v("        [P]  y\n      ==  [P]  fix  i\n      ==  [[duco P] duco P]  i\n      ==  [duco P]  duco P\n      ==  [[duco P] duco P]  P\n  ")]),e._v("\n  This point is always reached in the initial call, and it is independent of\n  what "),t("code",[e._v("P")]),e._v(" actually is. At this point there is a (double) quotation (containing\n  "),t("code",[e._v("P")]),e._v(" twice) on top of the stack, and "),t("code",[e._v("P")]),e._v(" now has it available\n  as a parameter. Quotations are never evaluated further, although they can be explicitly\n  manipulated by operators or they can be explicitly called by combinators. Consequently\n  the second "),t("code",[e._v("duco")]),e._v(" inside the quotation will "),t("em",[e._v(" not")]),e._v(" be executed\n  to yield\n  "),t("pre",[e._v("    ==  [[[duco P] duco P] duco P]  P\n  ")]),e._v("\n  Here of course the second and third "),t("code",[e._v("duco")]),e._v(" would have been the\n  next candidates for execution, and so on. So the reason for the difference is that\n  quotations in Joy are never evaluated automatically, whereas abstractions in the\n  lambda calculus will be under applicative order evaluation.\n  "),t("p",[e._v("\n    It is possible to generalise fixpoint combinators for mutual recursion. For the lambda\n    calculus this is done for example by\n    "),t("a",{attrs:{href:"refs.html#{Kogge91}"}},[e._v("{Kogge91}")]),e._v(", shows how pairs of mutually recursive\n    definitions can be eliminated by using a pair of rather complicated mutually recursive\n    combinators Y1 and Y2. A similar technique is explained in\n    "),t("a",{attrs:{href:"refs.html#{Henson87}"}},[e._v("{Henson87}")]),e._v(". Constructions such as these rely\n    on the existence of\n    "),t("em",[e._v("double fixpoints")]),e._v(", whose existence follows from a "),t("em",[e._v("double\n    recursion theorem")]),e._v(" (see for example "),t("a",{attrs:{href:"refs.html#{Smullyan94}"}},[e._v("{Smullyan94}")]),e._v(").\n    Presumably these can be translated into Joy, too.\n  ")]),t("h2",[e._v("Rice's theorem")]),e._v("\n  Consider arbitrary sets of functions, and note that this does not mean sets of programs.\n  Call such a set "),t("em",[e._v(" non-trivial")]),e._v(" if it is neither the universal set of all functions\n  nor the null set of no functions. Given a non-trivial set "),t("code",[e._v("F")]),e._v(" of partial\n  functions and a Joy program "),t("code",[e._v("[Q]")]),e._v(", the question arises whether the function\n  computed by "),t("code",[e._v("[Q]")]),e._v(" is in "),t("code",[e._v("F")]),e._v(" or not. Is there an algorithm for\n  deciding such questions? More specifically, is there a Joy program, say "),t("code",[e._v("PF")]),e._v(",\n  for deciding such questions? Such a program would have to satisfy\n  "),t("pre",[e._v("    [Q]  PF   ==   true,  if the function computed by [Q] is in F\n                ==   false, if the function computed by [Q] is not in F\n  ")]),e._v("\n  The program "),t("code",[e._v("PF")]),e._v(" is also expected to terminate for all inputs "),t("code",[e._v("[Q]")]),e._v(".\n  Can there be such a program?\n  "),t("p",[e._v("\n    No. This is "),t("em",[e._v("Rice's theorem")]),e._v(":\n  ")]),t("pre",[e._v("        For all non-trivial sets F of partial functions,\n              there is no program  PF  such that\n                  for all programs  Q\n                      PF can decide whether\n                          the function computed by  Q  is in F.\n  ")]),e._v("\n  Proof: Let "),t("code",[e._v("F")]),e._v(" be a non-trivial set of functions. Since\n  "),t("code",[e._v("F")]),e._v(" is non-trivial, there are some functions in\n  "),t("code",[e._v("F")]),e._v(" and some functions not in "),t("code",[e._v("F")]),e._v(". Let program\n  "),t("code",[e._v("[E]")]),e._v(" compute a function in "),t("code",[e._v("F")]),e._v(" and let\n  "),t("code",[e._v("[E']")]),e._v(" compute a function not in "),t("code",[e._v("F")]),e._v(".\n  "),t("p",[e._v("\n    Now assume that a program "),t("code",[e._v("PF")]),e._v(" exists, and that it always terminates.\n    Next, consider the following Joy program:\n  ")]),t("pre",[e._v("        [PF]  [pop [E']]  [pop [E]]  ifte\n  ")]),e._v("\n  The program expects an arbitrary program "),t("code",[e._v("[Q]")]),e._v(" on top of the stack\n  and then pushes the three small quotations. The\n  "),t("kbd",[e._v("ifte")]),e._v(" operator then removes them again and executes the first short quotation\n  "),t("code",[e._v("[PF]")]),e._v(". This will result in a truth value, "),t("code",[e._v("true")]),e._v(" or "),t("code",[e._v("false")]),e._v(".\n  In the first case the second short quotation is executed, it "),t("code",[e._v("pop")]),e._v("s the\n  "),t("code",[e._v("[PF]")]),e._v(" and replaces it by "),t("code",[e._v("[E']")]),e._v(". In the second case the third\n  short quotation is executed, it "),t("code",[e._v("pop")]),e._v("s the\n  "),t("code",[e._v("[PF]")]),e._v(" and replaces it by "),t("code",[e._v("[E]")]),e._v(". So, if\n  "),t("code",[e._v("[Q]")]),e._v(" is in "),t("code",[e._v("F")]),e._v(", the program returns a program not in "),t("code",[e._v("F")]),e._v(",\n  namely "),t("code",[e._v("[E']")]),e._v(". On the other hand, if "),t("code",[e._v("[Q]")]),e._v(" is not in "),t("code",[e._v("F")]),e._v(",\n  the program returns a program that is in "),t("code",[e._v("F")]),e._v(", namely "),t("code",[e._v("[E]")]),e._v(".\n  In other words, no matter what the input program "),t("code",[e._v("[Q]")]),e._v(" is, the output\n  program is opposite as far as membership in "),t("code",[e._v("F")]),e._v(" is concerned. Call the\n  above program "),t("code",[e._v("OPF")]),e._v(".\n  "),t("p",[e._v("\n    By the fixpoint theorem, the program "),t("code",[e._v("OPF")]),e._v(" must have a fixpoint, say\n    "),t("code",[e._v("FIXOPF")]),e._v(", satisfying\n  ")]),t("pre",[e._v("        FIXOPF  ==  [FIXOPF]  OPF\n  ")]),e._v("\n  But if the program on the left computes a function in "),t("code",[e._v("F")]),e._v(", then\n  the program on the right computes a function not in\n  "),t("code",[e._v("F")]),e._v(", and vice versa. But this is a contradiction. So the program "),t("code",[e._v("OPF")]),e._v("fails for at least one program, its own fixpoint "),t("code",[e._v("FIXOPF")]),e._v(". We must conclude\n  that the assumption was false. So there cannot be a program "),t("code",[e._v("PF")]),e._v(".\n  "),t("p",[e._v("\n    The above proof of Rice's theorem for Joy is adapted from a proof for recursive functions\n    in "),t("a",{attrs:{href:"refs.html#{Phillips92}"}},[e._v("{Phillips92}")]),e._v(". Several well-known\n    "),t("em",[e._v("paradox")]),e._v("es are instances of the recursion theorem, for example the "),t("em",[e._v("Liar paradox")]),e._v("  and "),t("em",[e._v("Grelling's paradox")]),e._v(" use as the program "),t("code",[e._v("[P]")]),e._v(" the simple\n    program "),t("code",[e._v("[i not]")]),e._v(". Recent discussions of the Liar and related problems\n    can be found in\n    "),t("a",{attrs:{href:"refs.html#{Martin70}"}},[e._v("{Martin70}")]),e._v(" and in "),t("a",{attrs:{href:"refs.html#{Barwise-Etchemendy87}"}},[e._v("{Barwise-Etchemendy87}")]),e._v(".\n  ")]),t("h2",[e._v("Other self-reproducing and self-describing programs")]),e._v("\n  There are variants of the programs in section 5 which are worth mentioning.\n  "),t("ol",[t("li",[e._v("\n      The following is a simplification of the first self-reproducing program. It is simpler\n      because it uses an operand parameter which it leaves intact.\n      "),t("pre",[e._v("        There is an operand Q1 and a program Q2 such that\n              Q1  [Q2]  i   ==   Q1  [Q2]\n  ")]),e._v("\n      Proof: Let "),t("code",[e._v("Q1")]),e._v(" = "),t("code",[e._v("[dup]")]),e._v(" and let\n      "),t("code",[e._v("Q2")]),e._v(" = "),t("code",[e._v("dup")]),e._v(". Then the derivation is\n      "),t("pre",[e._v("        [dup]  [dup]  i\n      ==  [dup]   dup                             (by i)\n      ==  [dup]  [dup]                            (by dup)\n  ")]),e._v("\n      This seemingly trivial self-reproducing program will be used to derive\n      a version of recursion that is actually more efficient than the one based on\n      the "),t("code",[e._v("y")]),e._v(" combinator.\n      "),t("p")]),t("li",[e._v("\n      The next uses the "),t("code",[e._v("b")]),e._v(" combinator:\n      "),t("pre",[e._v("        There are programs Q1 and Q2 such that\n              [Q1] [Q2] b   ==   [Q1] [Q2]\n  ")]),e._v("\n      Proof: let Q1 and Q2 be the programs\n      "),t("pre",[e._v("        [[] cons dup first]\n           [] cons dup first\n  ")]),e._v("\n      Then the derivation is:\n      "),t("pre",[e._v("        [[[] cons dup first]]  [[] cons dup first]  b\n      ==   [[] cons dup first]    [] cons dup first           (by b)\n      ==  [[[] cons dup first]]           dup first           (by cons)\n      ==  [[[] cons dup first]] [[[] cons dup first]] first   (by dup)\n      ==  [[[] cons dup first]]  [[] cons dup first]          (by first)\n  ")]),e._v("\n      It is useful to introduce an operator "),t("kbd",[e._v("codufi")]),e._v(" by the definition:\n      "),t("pre",[e._v("        codufi  ==  cons dup first\n  ")]),e._v("\n      The operator will be found useful in the next section.\n      "),t("p")]),t("li",[e._v("\n      The next example of a self-reproducing program again uses the\n      "),t("code",[e._v("i")]),e._v(" combinator:\n      "),t("pre",[e._v("        There is a program Q such that\n                  [Q] i i   ==   [Q]   =/=   [Q] i\n  ")]),e._v("\n      Proof: let "),t("code",[e._v("Q")]),e._v(" be the program\n      "),t("pre",[e._v("        [duco [] cons] duco [] cons\n  ")]),e._v("\n      The execution now looks like this:\n      "),t("pre",[e._v("         [[duco [] cons] duco [] cons]   i  i\n      ==    [duco [] cons] duco [] cons  i                        (by i)\n      ==   [[duco [] cons] duco [] cons] [] cons  i               (by duco)\n      ==  [[[duco [] cons] duco [] cons]]  i                      (by cons)\n      ==   [[duco [] cons] duco [] cons]                          (by i)\n  ")]),e._v("\n      Observe that the quoted programs in the first and fourth line differ by\n      just the extra quoting in line four.\n      "),t("p",[e._v("\n        There is another program with the property. Let "),t("code",[e._v("Q")]),e._v(" be the program\n      ")]),t("pre",[e._v("        [false [not] infra dup rest cons] [not] infra dup rest cons\n  ")]),e._v("\n      The combinator "),t("kbd",[e._v("infra")]),e._v(" expects a program (here\n      "),t("code",[e._v("[not]")]),e._v(") on top of the stack, and below that a quotation (here the\n      first half of the program). It temporarily turns the quotation into the stack\n      and executes the program (here it complements the truth value "),t("code",[e._v("false")]),e._v("    or "),t("code",[e._v("true")]),e._v(" at the very beginning. An outline of the derivation is:\n      "),t("pre",[e._v("    [[false [not] infra dup rest cons] [not] infra dup rest cons] i i\n      [[true  [not] infra dup rest cons] [not] infra dup rest cons] i\n      [[false [not] infra dup rest cons] [not] infra dup rest cons]\n  ")]),e._v("\n      (Each by 5 steps)\n      "),t("p",[e._v("\n        The quoted programs the first and second lines are examples of\n        "),t("em",[e._v("mutually describing programs")]),e._v(", satisfying\n      ")]),t("pre",[e._v("        P  =  [Q]       and       Q  == [P]\n  ")]),e._v("\n      In detail:\n      "),t("pre",[e._v("P  ==  [false [not] infra dup rest cons] [not] infra dup rest cons\n  Q  ==  [true  [not] infra dup rest cons] [not] infra dup rest cons\n  ")])]),t("li",[e._v("\n      The previous program keeps an internal toggle ("),t("code",[e._v("true")]),e._v(" or\n      "),t("code",[e._v("false")]),e._v(") which is thrown every time it is called. The next program\n      does the same with a counter, and consequently every generation is different\n      from all previous ones: Let "),t("code",[e._v("Q")]),e._v(" be the program\n      "),t("pre",[e._v("    [0 [1 +] infra dup rest cons] [1 +] infra dup rest cons\n  ")]),e._v("\n      Successive executions using "),t("code",[e._v("i")]),e._v(" cause the "),t("code",[e._v("0")]),e._v(" to\n      be incremented to "),t("code",[e._v("1")]),e._v(", "),t("code",[e._v("2")]),e._v(" and so on.\n      "),t("p")]),t("li",[e._v("\n      Almost all programs become ruined when maltreated. Cutting off bits and pieces would\n      generally cause malfunction. Worms of course can regenerate from small pieces,\n      but most programs are not like that. But programs can be written so that after\n      each call they become more and more insensitive to mutilation. The mutilating\n      operations are\n      "),t("code",[e._v("first")]),e._v(" and "),t("code",[e._v("rest")]),e._v(" or sequences of such operations. There\n      are programs which with every generation become less and less sensitive to longer\n      and longer sequences of mutilations. Two such "),t("code",[e._v("Q")]),e._v(" are\n      "),t("pre",[e._v("        [duco duco] duco duco\n          [cons duco] [cons duco] cons duco\n  ")]),t("p")]),t("li",[e._v("\n      Kym Horsell commented that self-reproducing programs do not do anything useful. The\n      idea would be that for a given program another program is to be found which is\n      self-reproducing and at each generation executes the original program first.\n      So the problem is to find, for arbitrary "),t("code",[e._v("P")]),e._v(", a program "),t("code",[e._v("Q")]),e._v("    such that\n      "),t("pre",[e._v("        [Q]  i  i  ..  i   ==   P  P  ..  P  [Q]\n  ")]),e._v("\n      where the "),t("code",[e._v("i")]),e._v(" on the left and the "),t("code",[e._v("P")]),e._v(" on the right\n      are repeated the same number of times. Here is one answer:\n      "),t("pre",[e._v("        There is a program O such that\n              for all programs P\n                  there is a program Q such that\n                          [P]  O   ==   [Q]   and\n                          [Q]  i   ==   Q   ==   P  [Q]\n  ")]),e._v("\n      Proof: Let "),t("code",[e._v("O")]),e._v(" be the program\n      "),t("pre",[e._v("        [dup [first i] dip rest duco] cons duco\n  ")]),e._v("\n      Then for any "),t("code",[e._v("P")]),e._v(":\n      "),t("pre",[e._v("    [P]  O\n  ==  [P] [dup [first i] dip rest duco] cons duco         (by O)\n  ==  [[P] dup [first i] dip rest duco] duco              (by cons)\n  == [[[P] dup [first i] dip rest duco] [P] dup [first i] dip rest duco]\n                                                          (by duco)\n  ")])])]),t("h2",[e._v("Another recursion combinator")]),e._v("\n  Apart from the "),t("code",[e._v("y")]),e._v(" combinator there are other recursion combinators.\n  One of them is given by the following theorem:\n  "),t("pre",[e._v("        There is a program M such that\n  (1)         [y] M  ==  [y] i  ==  y  and\n              for some programs N and O\n  (2a)             [M] [duco] swap concat  ==  [N]  and\n  (2b)             [N] duco  ==  [O] and\n  (3)              [M] y  ==  [N] dup i  ==  O  and\n                   for all programs P\n  (4)                  [P] O  ==  [P] y  and\n                       there is a program Q such that\n  (5)                     [P] [O] cons  ==  [Q]  and\n  (6)                     [Q] i  ==  Q  ==  [Q] P\n  ")]),e._v("\n  The first line, (1), says that "),t("code",[e._v("y")]),e._v(" is a fixpoint for\n  "),t("code",[e._v("M")]),e._v(". Lines (2a) and (2b) show how to construct two further programs "),t("code",[e._v("N")]),e._v("and "),t("code",[e._v("O")]),e._v(". Line (3) expresses a relationship between the three programs\n  "),t("code",[e._v("M")]),e._v(", "),t("code",[e._v("N")]),e._v(" and "),t("code",[e._v("O")]),e._v(". Line (5) shows how to construct\n  a program\n  "),t("code",[e._v("Q")]),e._v(" which depends on "),t("code",[e._v("P")]),e._v(". The last line of the theorem says\n  that the "),t("code",[e._v("Q")]),e._v(" is a fixpoint for "),t("code",[e._v("P")]),e._v(".\n  "),t("p",[t("b",[e._v("Proof:")]),e._v(" Only "),t("code",[e._v("M")]),e._v(" need be given, because\n    "),t("code",[e._v("N")]),e._v(" and "),t("code",[e._v("O")]),e._v(" are constructed. The required\n    "),t("code",[e._v("M")]),e._v(" is actually a combinator already seen in section 2:\n  ")]),t("pre",[e._v("        cons  dup  first  i\n  ")]),e._v("\n  But the first three operators can be replaced by "),t("kbd",[e._v("codufi")]),e._v(" defined\n  in the previous section. So we set:\n  "),t("pre",[e._v("        M  ==  codufi i\n  ")]),e._v("\n  This is used to construct "),t("code",[e._v("N")]),e._v(":\n  "),t("pre",[e._v("        [M] [duco] swap concat\n      ==  [codufi i] [duco] swap concat                           (def M)\n      ==  [duco] [codufi i]                                       (by swap)\n      ==  [duco codufi i]                                         (by concat)\n      ==  [N]                                                     (def N)\n  ")]),e._v("\n  So we have:\n  "),t("pre",[e._v("        N  ==  duco codufi i\n  ")]),e._v("\n  This program can be used to construct "),t("code",[e._v("O")]),e._v(":\n  "),t("pre",[e._v("        [N] duco\n      ==  [duco codufi i] duco                                    (def N)\n      ==  [[duco codufi i] duco codufi i]                         (by duco)\n      ==  [O]                                                     (def O)\n  ")]),e._v("\n  So we have:\n  "),t("pre",[e._v("        O  ==  [duco codufi i] duco codufi i\n  ")]),e._v("\n  This program can now be used to construct, for arbitrary\n  "),t("code",[e._v("[P]")]),e._v(" a corresponding "),t("code",[e._v("[Q]")]),e._v(":\n  "),t("pre",[e._v("        [P] [O] cons\n      ==  [P] [[duco codufi i] duco codufi i] cons                (def O)\n      ==  [[P] [duco codufi i] duco codufi i]                     (by cons)\n      ==  [Q]                                                     (def Q)\n  ")]),e._v("\n  So we have, for arbitrary "),t("code",[e._v("[P]")]),e._v(",\n  "),t("pre",[e._v("        Q  ==  [P] [duco codufi i] duco codufi i\n  ")]),e._v("\n  It remains to be shown that "),t("code",[e._v("Q")]),e._v(" is a fixpoint for "),t("code",[e._v("P")]),e._v(":\n  "),t("pre",[e._v("        [Q]  i\n      ==  [[P] [duco codufi i] duco codufi i]  i                  (def Q)\n      ==   [P] [duco codufi i] duco codufi i                      (by i)\n      ==  [P] [[duco codufi i] duco codufi i] codufi i            (by duco)\n      ==  [[P] [duco codufi i] duco codufi i] [P] i               (by codufi)\n      ==  [[P] [duco codufi i] duco codufi i]  P                  (by i)\n      ==  [Q]  P                                                  (def Q)\n  ")]),e._v("\n  This shows that "),t("code",[e._v("Q")]),e._v(" is indeed a fixpoint for "),t("code",[e._v("P")]),e._v(".\n  "),t("p",[e._v("\n    Different recursion combinators, and indeed a whole hierarchy of them, are well known\n    in the literature on "),t("em",[e._v("lambda calculus")]),e._v(" and\n    "),t("em",[e._v("combinatory logic")]),e._v("; see for example "),t("a",{attrs:{href:"refs.html#{Barendregt84}"}},[e._v("{Barendregt84}")]),e._v(",\n    "),t("a",{attrs:{href:"refs.html#{Henson87}"}},[e._v("{Henson87}")]),e._v(", "),t("a",{attrs:{href:"refs.html#{Revesz88}"}},[e._v("{Revesz88}")]),e._v(".\n    Possibly one of the most satisfying introductions to combinatory logic is to be\n    found in the remarkable little book "),t("a",{attrs:{href:"refs.html#{Smullyan90}"}},[e._v("{Smullyan90}")]),t("em",[e._v(" To Mock a Mockingbird")]),e._v(" in which he manages to combine humour and rigour.\n    Part III is a self-contained exposition to combinatory logic in which fancyful\n    names are given to lambda calculus combinators.\n  ")]),t("h2",[e._v("Practical recursion combinators in Joy")]),e._v("\n  Here are three recursive definitions. The function\n  "),t("code",[e._v("r-last")]),e._v(" finds the "),t("em",[e._v("last")]),e._v(" element of a list. The function "),t("code",[e._v("r-fac")]),e._v("computes the "),t("em",[e._v("factorial")]),e._v(" of a number. The function "),t("code",[e._v("r-fib")]),e._v(" computes\n  the\n  "),t("em",[e._v("Fibonacci")]),e._v(" value of a number.\n  "),t("pre",[e._v("    r-last  ==  [rest null] [first] [rest r-last] ifte\n      r-fac  ==  [0 =] [succ] [dup pred r-fac *] ifte\n      r-fib  ==  [small] [pop 1] [pred dup pred [r-fib] app2 +] ifte\n  ")]),e._v("\n  The following three functions also compute The last, the factorial and the\n  Fibonacci of their parameter. Note that there is no definition; the recursion is\n  taken care of by the "),t("code",[e._v("y")]),e._v(" combinator.\n  "),t("pre",[e._v("  [ [pop rest null] [pop first] [[rest] dip i] ifte ] y\n    [ [pop 0 =] [pop succ] [[dup pred] dip i *] ifte ] y\n    [ [pop small] [pop pop 1] [[pred dup pred] dip app2 +] ifte] y\n  ")]),t("p",[e._v("\n    But the "),t("code",[e._v("y")]),e._v(" combinator is intrisically inefficient because of the way\n    it operates. On every recursive call a certain program is popped off the stack\n    to be executed. The first task of that program is to construct a copy of itself,\n    in readiness for any further recursive calls. But this is really quite silly. It\n    would be better more efficient if the program to be executed was "),t("em",[e._v(" not")]),e._v("  popped off the stack at all but simply left there. Whereas most combinators remove\n    their parameters from the stack, a new "),t("kbd",[e._v("x")]),e._v(" combinator leaves it there\n    as a parameter for itself.\n  ")]),t("p",[e._v("\n    The following programs use the "),t("code",[e._v("x")]),e._v(" combinator instead of the "),t("code",[e._v("y")]),e._v("  combinator. They are obtained from the first two of the previous programs by replacing\n    the internal occurrences of the\n    "),t("code",[e._v("i")]),e._v(" combinator and the the external occurrence of the\n    "),t("code",[e._v("y")]),e._v(" combinator by the "),t("code",[e._v("x")]),e._v(" combinator.\n  ")]),t("pre",[e._v("  [ [pop rest null] [pop first] [[rest] dip x] ifte ] x\n    [ [pop 0 =] [pop succ] [[dup pred] dip x *] ifte ] x\n  ")]),e._v("\n  The "),t("code",[e._v("x")]),e._v(" combinator "),t("em",[e._v(" might")]),e._v(" have been defined by\n  "),t("pre",[e._v("        x  ==  dup i\n  ")]),t("p",[e._v("\n    Similar lambda calculus constructions are discussed in "),t("a",{attrs:{href:"refs.html#{Tennent76}"}},[e._v("{Tennent76}")]),e._v(",\n    "),t("a",{attrs:{href:"refs.html#{Bauer-Woessner82}"}},[e._v("{Bauer-Woessner82}")]),e._v(", "),t("a",{attrs:{href:"refs.html#{Schmidt86}"}},[e._v("{Schmidt86}")]),e._v("  and "),t("a",{attrs:{href:"refs.html#{Tennent91}"}},[e._v("{Tennent91}")]),e._v(".\n  ")]),t("p",[e._v("\n    The remainder of this section describes some further general and particular combinators\n    of Joy which can be used to avoid recursive definitions.\n  ")]),t("p"),t("ol",[t("li",[e._v("\n      The "),t("kbd",[e._v("genrec")]),e._v(" combinator takes four program parameters in addition to\n      whatever data parameters it needs. Fourth from the top is an if-part, followed\n      by a then-part. If the if-part yields true, then the then-part is executed and\n      the combinator terminates. The other two parameters are the rec1-part and the\n      rec2part. If the if-part yields "),t("code",[e._v("false")]),e._v(", the rec1-part is executed.\n      Following that the four program parameters and the combinator are again pushed\n      onto the stack bundled up in a quoted form. Then the rec2-part is executed, where\n      it will find the bundled form. Typically it will then execute the bundled form,\n      either with "),t("code",[e._v("i")]),e._v(" or with\n      "),t("code",[e._v("app2")]),e._v(", or some other combinator.\n      "),t("pre",[e._v("    g-fac == [null ] [succ] [dup pred     ] [i *   ] genrec;\n      g-fib == [small] [    ] [pred dup pred] [app2 +] genrec;\n  ")]),t("p")]),t("li",[e._v("\n      The "),t("kbd",[e._v("linrec")]),e._v(" combinator also takes four program parameters and is otherwise\n      very similar to the "),t("code",[e._v("genrec")]),e._v(" combinator. The essential difference\n      is that the bundled up quotation is immediately called before the rec2-part.\n      Consequently it can only be used for "),t("em",[e._v("linear recursion")]),e._v(". Here are programs\n      for finding the\n      "),t("code",[e._v("last")]),e._v(" of an aggregate or the Fibonacci value of a natural number:\n      "),t("pre",[e._v("    l-last == [rest null] [first] [rest    ] [ ] linrec;\n      l-fac  == [null     ] [succ ] [dup pred] [*] linrec\n  ")]),t("p")]),t("li",[e._v("\n      The "),t("kbd",[e._v("binrec")]),e._v(" combinator is again similar, but it applies the bundled\n      quotation twice, once to each of the two top values which the rec1-part has left\n      on the stack. It implements "),t("em",[e._v("binary\n      recursion")]),e._v(". Below it is used for the Fibonacci function and for a\n      "),t("em",[e._v("quicksort")]),e._v(" program for lists (or strings).\n      "),t("pre",[e._v("  b-fib == [small] [] [pred dup pred   ] [+                 ] binrec;\n  b-qsort == [small] [] [uncons [>] split] [swap23 cons concat] binrec;\n  ")]),t("p")]),t("li",[e._v("\n      The "),t("kbd",[e._v("tailrec")]),e._v(" combinator is similar to the\n      "),t("code",[e._v("linrec")]),e._v(" combinator, except that it does not have a rec2-part. It\n      can only be used for "),t("em",[e._v("tail recursion")]),e._v(", such as in the program below which\n      returns the last element of an aggregate.\n      "),t("pre",[e._v("    t-last == [rest null] [first] [rest] tailrec;\n  ")]),t("p")]),t("li",[e._v("\n      The "),t("kbd",[e._v("primrec")]),e._v(" combinator is for "),t("em",[e._v("primitive\n      recursion")]),e._v(", it has the typical if-part built in. For numeric parameters and for\n      aggregate parameters it tests for\n      "),t("code",[e._v("null")]),e._v(". The rec1-part is also built in, for numeric parameters it\n      returns the parameter and its predecessor, for aggregate parameters it returns\n      the "),t("code",[e._v("first")]),e._v(" of the aggregate and the\n      "),t("code",[e._v("rest")]),e._v(" of the aggregate. Recursion then occurs respectively on the\n      predecessor or the rest, and the rudimentary rec2-part typically combines the\n      results.\n      "),t("p",[e._v("\n        The first program below computes the factorial (again!). The second turns any aggregate\n        into a list. The third turns a suitable list of small numbers into a set. The\n        fourth and fifth capitalise lists or strings of lowercase letters and produce,\n        respectively, a list or string of corresponding capital letters. The last program\n        takes an aggregate as parameter and produces a list of every second element\n        in the original order and then the other elements in the reverse order.\n      ")]),t("pre",[e._v('    p-fac      ==  [1 ]  [*              ]  primrec\n      agg2list   ==  [[]]  [cons           ]  primrec\n      list2set   ==  [{}]  [cons           ]  primrec\n      capstring  ==  [""]  [[32 -] dip cons]  primrec\n      caplist    ==  [[]]  [[32 -] dip cons]  primrec\n      fancy      ==  [[]]  [reverse  cons  ]  primrec\n  ')])])]),t("hr")])}]};n.a=r},SXzG:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o=t("MgQF"),r=!1;var i=function(e){r||t("GXMS")},a=t("VU/8")(null,o.a,!1,i,"data-v-5c36311d",null);a.options.__file="pages/papers-on-joy/recursion-theory-and-joy.vue",n.default=a.exports},wBJh:function(e,n,t){(e.exports=t("FZ+f")(!1)).push([e.i,"p[data-v-5c36311d]{margin-top:16px;margin-bottom:16px}hr[data-v-5c36311d]{margin-bottom:16px}pre[data-v-5c36311d]{margin-bottom:auto}code[data-v-5c36311d],kbd[data-v-5c36311d],pre[data-v-5c36311d]{font-family:Roboto Mono,monospace}",""])}});