webpackJsonp([18],{B9e1:function(e,n,t){var i=t("qVhh");"string"==typeof i&&(i=[[e.i,i,""]]),i.locals&&(e.exports=i.locals);t("rjj0")("18bfa3e4",i,!1,{sourceMap:!1})},qVhh:function(e,n,t){(e.exports=t("FZ+f")(!1)).push([e.i,"p[data-v-633d4131]{margin-top:16px;margin-bottom:16px}hr[data-v-633d4131]{margin-bottom:16px}pre[data-v-633d4131]{margin-bottom:auto}code[data-v-633d4131],kbd[data-v-633d4131],pre[data-v-633d4131]{font-family:Roboto Mono,monospace}",""])},w0td:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var i=t("wD66"),o=!1;var r=function(e){o||t("B9e1")},s=t("VU/8")(null,i.a,!1,r,"data-v-633d4131",null);s.options.__file="pages/papers-on-joy/survey-of-reproducing-programs.vue",n.default=s.exports},wD66:function(e,n,t){"use strict";var i=function(){var e=this.$createElement;this._self._c;return this._m(0)};i._withStripped=!0;var o={render:i,staticRenderFns:[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("article",[t("p",[e._v("\n    by Manfred von Thun\n    "),t("br"),e._v(" 3-MAY-05\n  ")]),t("p",[t("b",[e._v("Abstract")]),e._v(" A program is said to be reproducing if running it produces another\n    program whichh is also reproducing. A program is said to be self-reproducing if\n    running it produces another program identical to itself. This note surveys reproducing\n    programs, with emphasis on those in which the produced program is different from\n    producing program. Starting with the simplest self-reproducing program, two kinds\n    of additions are considered: an internal state which changes with every reproduction\n    step, and a contained program which affects the stack. There can also be interaction\n    between the state and the stack, under control of the contained program. The contained\n    program can also use the state as a count-down to self-destruction of the reproducing\n    program. Some reproducing programs can call themselves recursively, and the ones\n    constructed here differ from the ones normally used for the y-combinator in that\n    they survive even after they return from the initial call. For convenience some\n    operators are defined which facilitate the definitions of such recursive programs.\n    A final discussions deals with achieving similar effects without the use of reproducing\n    programs.\n  ")]),t("p",[t("a",{attrs:{name:"CONT"}},[e._v("Content")]),e._v(":\n    "),t("br"),t("a",{attrs:{href:"#TOC-1"}},[e._v("Introduction - reproducing programs")]),t("br"),t("a",{attrs:{href:"#TOC-2"}},[e._v("Four basic programs")]),t("br"),t("a",{attrs:{href:"#TOC-3"}},[e._v("Streams or infinite lists")]),t("br"),t("a",{attrs:{href:"#TOC-4"}},[e._v("Interaction and termination")]),t("br"),t("a",{attrs:{href:"#TOC-6"}},[e._v("Reproduction for recursion")]),t("br"),t("a",{attrs:{href:"#TOC-7"}},[e._v("Convenience operators")]),t("br"),t("a",{attrs:{href:"#TOC-8"}},[e._v("Final remarks")]),t("br"),t("a",{attrs:{href:"#TOC-9"}},[e._v("foo9")]),t("br"),t("a",{attrs:{name:"TOC-1"}})]),t("h2",[t("a",{attrs:{name:"TOC-1"}},[e._v("Introduction - reproducing programs")])]),t("p",[e._v("\n    Reproducing programs and self-reproducing programs can be written in any programming\n    language; indeed the web offers many examples. Such programs can be very simple\n    or quite complex, depending on whether the language makes it easy to speak about\n    itself. This note is a survey of some techniques for writing such programs which\n    go beyond basic reproduction, by combining reproduction with two principal additions.\n  ")]),t("p",[e._v('\n    The first addition is an internal state of the reproducing program. This state can\n    change during each reproductive step. The change may depend only on the reproducing\n    program, or it may depend also on what the programs finds on the stack at each\n    reproductive step. Examples of the first kind are various forms of streams or infinite\n    ("lazy") lists. Examples of the second kind are programs which use their internal\n    state to collect information about the stack as they were reproducing.\n  ')]),t("p",[e._v("\n    The second addition is an internal program which on each reproducing step does something\n    to the stack at each reproductive step. This internal program is quite distinct\n    from the reproducing part. Better known examples are those programs which eliminate\n    explicit recursion by using the y combinator. But a similar technique can also\n    be used for non-recursive programs.\n  ")]),t("p",[e._v("\n    The remainder of this note deals with a new library, a test file and its output.\n    The library is in the file\n    "),t("a",{attrs:{href:"joy/replib.joy"}},[e._v("replib.joy")]),e._v(". The test file is in\n    "),t("a",{attrs:{href:"joy/reptst.joy"}},[e._v("reptst.joy")]),e._v(". The output from the test program is in\n    "),t("a",{attrs:{href:"joy/reptst.out"}},[e._v("reptst.out")]),e._v(". The present note consists of comments\n    and discussions added to the last mentioned file.\n  ")]),t("p",[e._v('\n    The library essentially defines one single module called rep (for "reproduction").\n    The actual definitions occur in the place marked "...", but for ease of reading\n    this note they are here given separately where they are being discussed. The outline\n    of the library is as follows:\n  ')]),t("pre",[e._v('(* FILE:   replib.joy *)\n\n  "agglib" libload.\n\n  LIBRA\n\n      _replib == true;\n\n  MODULE rep  # "reproducing programs"\n\n  PUBLIC\n\n      ...\n\n  END;     # MODULE rep\n\n      REPLIB == "replib.joy - for survey of reproducing programs"\n\n  END      # LIBRA\n\n  "replib  is loaded\\n" putchars.\n\n  (* END   replib.joy *)\n  ')]),t("p",[e._v("\n    The bulk of this note consists of commented output from the test file. Each section\n    of the test file is preceded by the relevant definitions from the module library.\n  ")]),t("p",[e._v("\n    Back to "),t("a",{attrs:{href:"#CONT"}},[e._v("Content")]),t("a",{attrs:{name:"TOC-2"}})]),t("h2",[t("a",{attrs:{name:"TOC-2"}},[e._v("Four basic programs")])]),t("p",[e._v("\n    This section deals with four very simple reproducing programs in the library wich\n    illustrate the basic ideas of this note. The first five definitions in the library\n    are just utilities used throughout the library.\n  ")]),t("pre",[e._v("    duco == dup cons;\n      dureco == dup rest cons;\n      durereco == dup rest rest cons;\n\n      count == [0 [succ] infra] swoncat;\n      deposit == [dup [first] dip] swoncat;\n\n      self == [duco]         duco;      exe   == [dip duco]   cons       duco;\n      ints == [dureco] count dureco;    exe-c == [dip dureco] cons count dureco;\n  ")]),e._v("\n  The last two lines contain definitions for the four basic programs; they are\n  here written in a way which displays their similarities. Starting with the simple\n  definition of self in the first line, moving to the right adds dip and cons in both\n  programs in the right column, moving down adds count and replaces duco by dureco\n  in both programs on the second line. What exactly these programs do is illustrated\n  by the test file:\n  "),t("p",[e._v("\n    First, there is a definition of selfr in terms of its counterpart self in the module\n    rep from the library.\n  ")]),t("pre",[e._v(" DEFINE \n        selfr == rep.self. \n     \n    selfr. \n  [[duco] duco]\n     \n    selfr i i i. \n  [[duco] duco]\n  ")]),e._v("\n  Following the definition, there is a call to selfr, which just shows the (quoted)\n  program which is constructed by selfr. Finally, the program is called by the i combinator,\n  which executes it, inn readyness for two further executions by the i combinator.\n  Each of the executions just produces the same quotation. So selfr produces a self-reproducing\n  program.\n  "),t("p",[e._v("\n    The next definition in the test file defines a self-reproducing program which on\n    every call by the i combinator will square whatever number it finds on the stack.\n    The definitioon uses the program exe from the module rep in the library.\n  ")]),t("pre",[e._v("    \n    DEFINE \n        squaring == [dup *] rep.exe. \n     \n    squaring. \n  [[[dup *] dip duco] [dup *] dip duco]\n     \n    2 squaring i pop. \n  4\n     \n    2 squaring i i pop. \n  16\n     \n    2 squaring i i i pop. \n  256\n  ")]),t("p",[e._v("\n    Following the definition, the first call to squaring the quotation is constructed\n    and the result is shown. In the other three calls the quotation is executed once,\n    twice or thrice by the i combinator. This does not change the quotation, so it\n    is here just popped off. What remains on the stack is the result of squaring 2\n    once, twice or thrice.\n  ")]),t("p",[e._v("\n    The next definition defines a function integers in terms of the function ints from\n    the module rep in the library. The function produces a quotation containing an\n    internal state which changes at every reproduction; for convenience the state can\n    be accessed through the auxiliary function state.\n  ")]),t("pre",[e._v(" DEFINE \n        state == first first; \n        integers == rep.ints. \n     \n    integers. \n  [[0 [succ] infra dureco] [succ] infra dureco]\n     \n    integers i i i i i state. \n  5\n     \n    integers i i i i i i. \n  [[6 [succ] infra dureco] [succ] infra dureco]\n  ")]),e._v("\n  The first call to integers just shows the quotation that has been produced,\n  including its initial state 0. The second call shows the state after 5 executions\n  by the i combinator, the third shows the quotation after 6 executions.\n  "),t("p",[e._v("\n    The next definition is an example which combines what the second and third definitions\n    did: it contains a program which does something to the stack, and also contains\n    an internal state which changes after each execution:\n  ")]),t("pre",[e._v("    \n    DEFINE \n        times10-c ==  [10 *] rep.exe-c. \n     \n    times10-c. \n  [[0 [succ] infra [10 *] dip dureco] [succ] infra [10 *] dip dureco]\n     \n    3 times10-c i i i i i pop. \n  300000\n     \n    3 times10-c i i i i i popd state. \n  5\n  ")]),e._v("\n  The reproducing program constructed by times10-c will multiply any number\n  it finds on the stack by 10. The first call to times10-c shows the quotation that\n  has been constructed; the second shows just the stack after 5 executions by i, and\n  the third shows just the state after 5 executions by i.\n  "),t("p",[e._v("\n    Back to "),t("a",{attrs:{href:"#CONT"}},[e._v("Content")]),t("a",{attrs:{name:"TOC-3"}})]),t("h2",[t("a",{attrs:{name:"TOC-3"}},[e._v("Streams or infinite lists")])]),t("p",[e._v('\n    This section deals with reproducing programs which are essentially generalisations\n    of the integers program of the previous section. These programs implement streams\n    or infinite or "lazy" lists. First, here are four definitions inside the module\n    rep from the library. The function c-stream produces programs which implement infinite\n    lists in which all members are identical. The function n-stream produces programs\n    in which the next member is defined in terms of the previous member by means of\n    an internal operation. Both functions have a variant "..-d" which simultaneously\n    deposits the current member and computes the next member. So these variants can\n    be thought of as computing the uncons function.\n  ')]),t("pre",[e._v("    c-stream == [dureco] cons dureco;\n      c-stream-d == [dureco] deposit cons dureco;\n\n      n-stream == [infra dureco] cons cons dureco;\n      n-stream-d == [infra dureco] cons deposit cons dureco;\n  ")]),e._v("\n  The first definition in the test file defines the infinite stream whose members\n  are the constant 1:\n  "),t("pre",[e._v(" DEFINE \n        ones == 1 rep.c-stream. \n     \n    ones. \n  [[1 dureco] dureco]\n\n    ones i i i i i. \n  [[1 dureco] dureco]\n\n    ones i i i i i state. \n  1\n  ")]),e._v("\n  The first call to ones shows the quotation that is produced, the second shows\n  the (identical) quotation after 5 executions by the i combinator, the third call\n  shows the unchanged state after 5 executions.\n  "),t("p",[e._v("\n    The next definition defines a stream which starts with the member 1.0 and on successive\n    executions by the i combinator halves it.\n  ")]),t("pre",[e._v(" DEFINE \n        halving == 1.0 [2 /] rep.n-stream. \n     \n    halving. \n  [[1 [2 /] infra dureco] [2 /] infra dureco]\n     \n    halving i i i. \n  [[0.125 [2 /] infra dureco] [2 /] infra dureco]\n     \n    halving i i i state. \n  0.125\n  ")]),e._v("\n  The first call to halving shows the original quotation, the second and third\n  show the resultant quotation and the internal state after three executions by i.\n  "),t("p",[e._v("\n    The next definition in the test file defines a variant of the integers program of\n    the previous secction, with the difference that the first member can be chosen\n    to be other than 0.\n  ")]),t("pre",[e._v(" DEFINE \n        integers-from == [succ] rep.n-stream. \n     \n    42 integers-from. \n  [[42 [succ] infra dureco] [succ] infra dureco]\n     \n    42 integers-from i i i i i state. \n  47\n  ")]),e._v("\n  The first call shows the quotation that is produced when the parameter is\n  42, the second call shows the state after five executions by the i combinator.\n  "),t("p",[e._v("\n    The next definition gives an example of a constant stream which deposits its first\n    member on every execution.\n  ")]),t("pre",[e._v(" DEFINE \n        ones-d == 1 rep.c-stream-d. \n     \n    ones-d. \n  [[1 dup [first] dip dureco] dup [first] dip dureco]\n     \n    ones-d i i i pop. . . \n  1\n  1\n  1\n  ")]),e._v("\n  The first call shows the quotation, the second call shows the three instances\n  of 1 deposited on the stack by the three executions.\n  "),t("p",[e._v("\n    The next definition shows the depositing variant of the halving stream shown earlier.\n  ")]),t("pre",[e._v("  \n    DEFINE \n        halving-d == 1.0 [2 /] rep.n-stream-d. \n     \n    halving-d. \n  [[1 dup [first] dip [2 /] infra dureco] dup [first] dip [2 /] infra dureco]\n     \n    halving-d i i i i i pop. . . . . \n  0.0625\n  0.125\n  0.25\n  0.5\n  1\n  ")]),e._v("\n  As before, the first call shows the quotation, the second call shows the states\n  that have been deposited on the stack.\n  "),t("p",[e._v("\n    The next definition is for a depositing version of a primes stream. Note how the\n    enclosed operation for computing the next member can be arbitrarily complex.\n  ")]),t("pre",[e._v(" DEFINE \n        primes-d == 2 [succ [prime not] [succ] while] rep.n-stream-d. \n     \n    primes-d. \n  [[2 dup [first] dip [succ [prime not] [succ] while] infra dureco]\n      dup [first] dip [succ [prime not] [succ] while] infra dureco]\n     \n    primes-d i i i i i pop. . . . . \n  11\n  7\n  5\n  3\n  2\n  ")]),e._v("\n  The output from the first call shows the quotation minimally formatted to\n  make reading easier. The other call shows the five primes that have been deposited\n  from the five executions by the i combinator.\n  "),t("p",[e._v("\n    In the streams so far successive members were related by a simple function which\n    was used to compute the next member (trivially this is also true of the constant\n    streams). But this is not always possible, namely when there is no simple function\n    to do the job. For this reason the module rep in the library provides another kind\n    of stream in which there are two functions: one (here called [N]) to compute an\n    internal next value from its predecessor, and another (here called [F]) to compute\n    the final value. Two such streams are defined, and both use the same preparatory\n    auxiliary function:\n  ")]),t("pre",[e._v("    f-stream-prepare ==                 # s [N] [F]\n          swap                            # s [F] [N]\n          [dip] cons concat               # s [F [N] dip]\n          cons                            # [s F [N] dip]\n          [dup] infra                     # [s s F [N] dip]\n          dup rest rest infra             # [Fs Ns F [N] dip]\n          uncons uncons                   # Fs Ns [F [N] dip]\n          [pop dup] swoncat               # Fs Ns [pop dup F [N] dip]\n          [infra durereco] cons;          # Fs Ns [[pop .. dip] infra durereco]\n\n      f-stream == f-stream-prepare cons cons durereco;\n      f-stream-d == f-stream-prepare deposit cons cons durereco;\n  ")]),t("p",[e._v("\n    The test file defines the stream of squares ([dup *]) of even numbers ([2 +]) starting\n    with 0.\n  ")]),t("pre",[e._v(" DEFINE \n        even-squares == 0 [2 +] [dup *] rep.f-stream. \n     \n    even-squares. \n  [[0 2 [pop dup dup * [2 +] dip] infra durereco]\n        [pop dup dup * [2 +] dip] infra durereco]\n     \n    even-squares state. \n  0\n     \n    even-squares i state. \n  4\n     \n    even-squares i i state. \n  16\n     \n    even-squares i i i state. \n  36\n     \n    even-squares i i i i state. \n  64\n  ")]),e._v("\n  The first call shows the quotation slightly formatted. The other calls show\n  the squares of the first five even numbers.\n  "),t("p",[e._v("\n    The next definition is for a depositing stream in which the internal state is a list\n    of two elements: a power of 10 produced by [10 *] and its logarithm base 10. The\n    remainder of the quotation constructs the list.\n  ")]),t("pre",[e._v("  \n    DEFINE \n        ten-powers-log10 == \n             1  [10 * ] [[] cons [dup log10] infra]  rep.f-stream-d. \n     \n    ten-powers-log10. \n  [[[0 1] 10 dup [first] dip [pop dup [] cons [dup log10]\n              infra [10 *] dip] infra durereco]\n             dup [first] dip [pop dup [] cons [dup log10]\n              infra [10 *] dip] infra durereco]\n     \n    ten-powers-log10 i i i i i i pop. . . . . . \n  [5 100000]\n  [4 10000]\n  [3 1000]\n  [2 100]\n  [1 10]\n  [0 1]\n  ")]),e._v("\n  The first call shows the quotation that is produced, here formatted to extend\n  over four lines. The second call shows the five lists that have been deposited from\n  the five executions by i.\n  "),t("p",[e._v("\n    A different and more complete treatment of infinite lists in Joy is in the library\n    "),t("a",{attrs:{href:"joy/lazlib.joy"}},[e._v("\n    lazlib.joy")]),e._v(", with testfile\n    "),t("a",{attrs:{href:"joy/laztst.joy"}},[e._v("\n    laztst.joy")]),e._v(" and output\n    "),t("a",{attrs:{href:"joy/laztst.out"}},[e._v("\n    laztst.out")]),e._v(". Another, more theoretical treatment closer to the present\n    note is in\n    "),t("a",{attrs:{href:"joy/jp-reprod.html"}},[e._v("\n    jp-reprod.html")]),e._v(".\n  ")]),t("p",[e._v("\n    Back to "),t("a",{attrs:{href:"#CONT"}},[e._v("Content")]),t("a",{attrs:{name:"TOC-4"}})]),t("h2",[t("a",{attrs:{name:"TOC-4"}},[e._v("Interaction and termination")])]),t("p",[e._v("\n    The previous section dealt with streams, reproducing programs which contain an internal\n    state which can change by successive executions. These were generalisations of\n    the integers program which was one of the four basic programs. Another of the basic\n    reproducing programs provided a facility for an internal program which on every\n    reproduction could affect the stack below. This section deals with reproducing\n    programs in which there is some kind of interaction between the state of the reproducing\n    program and the stack below. (This is more general than those versions of streams\n    which merely deposit the internal state.)\n  ")]),t("p",[e._v("\n    The rep module in the library contains a useful definition for constructing programs\n    which on every reproduction step allow two-way interaction between the state and\n    the stack:\n  ")]),t("pre",[e._v("    inter ==                            #  s [P]\n          [dip cons dureco] cons          #  s [[P] dip cons dureco]\n          [uncons] swoncat                #  s [uncons [P] dip cons dureco]\n          cons dureco;\n  ")]),e._v("\n  The definition of inter is used in the following three definitions in the\n  test file:\n  "),t("pre",[e._v(" DEFINE \n        accu-list == [] [cons] rep.inter; \n        accu-sum == 0 [+] rep.inter; \n        accu-product-list == [] [[*] dip cons] rep.inter. \n     \n    accu-list. \n  [[[] uncons [cons] dip cons dureco]\n       uncons [cons] dip cons dureco]\n     \n    1 2 3 4 5 accu-list i i i i i state. \n  [1 2 3 4 5]\n     \n    accu-sum. \n  [[0 uncons [+] dip cons dureco]\n      uncons [+] dip cons dureco]\n     \n    1 2 3 4 5 accu-sum i i i i i state. \n  15\n\n    accu-product-list. \n  [[[] uncons [[*] dip cons] dip cons dureco]\n       uncons [[*] dip cons] dip cons dureco]\n     \n    1 10 2 100 3 1000 4 10000 accu-product-list i i i i state. \n  [10 200 3000 40000]\n  ")]),e._v("\n  Each of the three definitions is used twice: once to show the (slightly formatted)\n  quotation that it produces, and once with its state after a number of executions\n  by i. The first, accu-list, just accumulates whatever single items it finds and enters\n  them into its state which is a list. The second, accu-sum, accumulates single into\n  its state by adding them to its initial value 0. The third accu-product list accumulates\n  in a list the products of pairs of numbers.\n  "),t("p",[e._v("\n    The remainder of this section deals with reproducing programs which have a limited\n    life span. This is implemented by a downwards counter; when that reaches 0 the\n    program no longer does what it did before but degenerates into the bland self-reproducing\n    program selfr. Such reproducing programs terminate their activity. The definition\n    below is from the library:\n  ")]),t("pre",[e._v("    exe-t ==                            # N [P] => [[N [I] [T] [E] ifte] ..]\n          [dip dureco] cons               # N [[P] dip dureco]\n          [[pred] infra] swoncat          # N [[pred] infra [P] dip dureco]\n          [ifte] cons                     # N [[E] ifte]\n          [pop [[duco] duco]] swons        # N [[pop [[duco] duco] [E] ifte]\n          [first null] swons              # N [[first null] [T] [E] ifte]\n          cons dureco;                    # [[N [I] [T] [E] ifte] ..]\n  ")]),e._v("\n  The definition of exe-t in the library is used in each of these two definitions\n  in the test file: The first will add numbers on the stack up to three times and then\n  terminate, the second will do the same up to four times.\n  "),t("pre",[e._v(" DEFINE \n        max-3-adds == 3 [+] rep.exe-t; \n        max-4-adds == 4 [+] rep.exe-t. \n     \n              max-3-adds. \n  [[3 [first null] [pop [[duco] duco]] [[pred] infra [+] dip dureco] ifte] [first null] [pop [[duco] duco]] [[pred] infra [+] dip dureco] ifte]\n     \n     \n          2 1 max-3-adds i pop. \n  3\n     \n        3 2 1 max-3-adds i i pop. \n  6\n     \n      4 3 2 1 max-3-adds i i i pop. \n  10\n     \n    5 4 3 2 1 max-3-adds i i i i pop. . \n  10\n  5\n     \n    5 4 3 2 1 max-4-adds i i i i pop. \n  15\n  ")]),e._v("\n  The first call to max-3-adds just shows the reproducing program that has been\n  constructed, and the first three executions by the i combinator show the results\n  of up to three additions. The fourth shows that max-3-adds wil not perform the fourth\n  addition, and the last shows that max-4-adds does.\n  "),t("p",[e._v("\n    Back to "),t("a",{attrs:{href:"#CONT"}},[e._v("Content")]),t("a",{attrs:{name:"TOC-6"}})]),t("h2",[t("a",{attrs:{name:"TOC-6"}},[e._v("Reproduction for recursion")])]),t("p",[e._v("\n    The programs in the previous sections all did their specific tasks before their actual\n    reproduction. The programs in the remaining sections do this in the reverse order:\n    first they reproduce, then they do their specific tasks. This has the consequence\n    that the task may include a recursive call to themselves. The simplest programs\n    of this kind essentially perform the y combinator that is well known in the literature.\n    The more elaborate programs perform various additional tasks.\n  ")]),t("p",[e._v("\n    The four definitions below are from the rep module in the library. The simplest is\n    fix, which is for implementing anonymous recursion. The second adds a counter as\n    an internal state; the counter is incremented on every call whether direct or recursive.\n    The third is more complex, it takes as parameters a program [P] for recursion,\n    a state s and a program [I] for interaction. The fourth is a special case of the\n    third: the state is an empty list and the interaction program simply conses a copy\n    of the top of stack into that list to record a trace of calls.\n  ")]),t("pre",[e._v("    fix == [duco] swoncat duco;\n      fix-c == [0 [succ] infra dureco] swoncat dureco;\n      fix-i ==                            # [P] s [I]\n          [dip cons dureco] cons          # [P] s [[I] dip cons dureco]\n          [uncons] swoncat                # [P] s [uncons [I] dip cons dureco]\n          cons                            # [P] [s uncons [I] dip cons dureco]\n          swoncat                         # [s uncons [I] dip cons dureco P]\n          dureco;\n      fix-a == [] [[cons] unary] fix-i;\n  ")]),e._v("\n  In the test file there are the following two definitions for the factorial\n  function in terms of the fix constructor. The first is for the usual form like the\n  y combinator, where the program only reproduces on the way down during recursion\n  and is deleted (by one of the pop's) when the recursion bottoms out. Consequently\n  the reproducing program is no longer in the way of the multiplication on the way\n  up. In the second version the reproducing program survives all the way, and after\n  the final result has been produced it is still available for another computation.\n  "),t("pre",[e._v(" DEFINE \n       fact0 == [[pop null] [pop pop 1  ] [[dup pred] dip i  *     ] ifte]; \n       fact  == [[pop null] [[pop 1] dip] [[dup pred] dip i [*] dip] ifte]. \n     \n    6 fact0 rep.fix i. \n  720\n     \n    6 fact  rep.fix i. . \n  [[duco [pop null] [[pop 1] dip] [[dup pred] dip i [*] dip] ifte]\n    duco [pop null] [[pop 1] dip] [[dup pred] dip i [*] dip] ifte]\n  720\n     \n    3 fact  rep.fix i i. . \n  [[duco [pop null] [[pop 1] dip] [[dup pred] dip i [*] dip] ifte]\n    duco [pop null] [[pop 1] dip] [[dup pred] dip i [*] dip] ifte]\n  720\n  ")]),e._v("\n  The first example shows the conventional calculation of factorial(6). The\n  second shows the same with the surviving program (slightly formatted) still on the\n  stack. The third shows the calculation of factorial(factorial(3)). The program that\n  survived the first call by the i combinator is used again for a second call by the\n  i combinator.\n  "),t("p",[e._v("\n    In the test file the first three definitions below give variants of the reproducing\n    factorial program. The first is just the plain version already seen above. The\n    second also has a counter for the calls, and the third also has an accumulator\n    for the parameters on the stack. The final two definitions are just utilities for\n    showing the counter or the accumulator.\n  ")]),t("pre",[e._v(' DEFINE \n        fact-fix   == fact rep.fix; \n        fact-fix-c == fact rep.fix-c; \n        fact-fix-a == fact rep.fix-a; \n     \n        steps == "steps: " putchars state putln; \n        trace == "trace: " putchars state putln. \n     \n    3 4 5  fact-fix   i swap put i swap put i swap putln pop. \n  120 24 6 \n     \n    3 4 5  fact-fix-c i swap put i swap put i swap putln steps. \n  120 24 6 \n  steps: 15 \n     \n    3 4 5  fact-fix-a i swap put i swap put i swap putln trace. \n  120 24 6 \n  trace: [0 1 2 3 0 1 2 3 4 0 1 2 3 4 5] \n  ')]),e._v("\n  The call to fact-fix just gives the factorials for three numbers, 3, 4 and\n  5. The call to fact-fix-c also gives the count of all calls made, and the third also\n  gives a trace of the parameters.\n  "),t("p",[e._v('\n    Also in the test file are the following definitions for computing the Fibonacci function.\n    This function can be implemented very efficiently to run in linear time, but it\n    is often defined using binary recursion, running in exponential time, to illustrate\n    one or the other matter. This latter for is often called the "naive Fibonacci",\n    and this explains the leading "n" in the names below. The first definition just\n    defines the quotation parameter for the other three, similar to the preceding thre\n    factorial function.\n  ')]),t("pre",[e._v(" DEFINE \n        nfib == \n            [ [ pop small ] \n              [ [pop 1] dip ] \n              [ [pred dup pred] dip \n                dip swap i \n                [+] dip ] \n              ifte ]; \n     \n        nfib-fix == nfib rep.fix; \n        nfib-fix-c == nfib rep.fix-c; \n        nfib-fix-a == nfib rep.fix-a. \n     \n    nfib-fix. \n  [[duco [pop small] [[pop 1] dip]\n       [[pred dup pred] dip dip swap i [+] dip] ifte]\n    duco [pop small] [[pop 1] dip]\n       [[pred dup pred] dip dip swap i [+] dip] ifte]\n     \n    6 nfib-fix i pop. \n  13\n     \n    6 nfib-fix-c i swap putln steps. \n  13 \n  steps: 25 \n     \n    6 nfib-fix-a i swap putln trace. \n  13 \n  trace: [0 1 2 1 0 1 2 3 4 1 0 1 2 3 0 1 2 1 0 1 2 3 4 5 6] \n     \n    0 __settracegc. \n     \n    30 nfib-fix-c i swap putln steps. \n  1346269 \n  steps: 2692537 \n     \n  ")]),e._v("\n  The first call, to nfib-fix, just shows the reproducing program, sligtly formatted.\n  The next three show the results of calls with the parameter 13. Finally, there is\n  a call with the parameter 30 to show the very large number of reproducing steps.\n  Because these steps required many garbage collections, the usual trace information\n  has been switched off beforehand.\n  "),t("p",[e._v("\n    Back to "),t("a",{attrs:{href:"#CONT"}},[e._v("Content")]),t("a",{attrs:{name:"TOC-7"}})]),t("h2",[t("a",{attrs:{name:"TOC-7"}},[e._v("Convenience operators")])]),t("p",[e._v("\n    The two functions factorial and Fibonacci in the preceding section were chosen because\n    they are well known examples of linear and binary recursion. In both cases three\n    versions were given, in both cases based on the core quotation containing three\n    quotations and the ifte combinator. Much of the complexity of the core quotations\n    is due to the fact that these are not recursive definitions but use a reproducing\n    program. It would be convenient if there were more natural ways of writing the\n    core quotation. This can indeed be done, by two program constructors whose program\n    parameters are identical to those used by the linrec and binrec combinators that\n    are built into Joy. Both constructors use a common and quite complex feature which\n    here is called _expand. (The leading underscore in the name is just to indicate\n    that it is not a function likely to be wanted elsewhere.) Here is the definition,\n    in the rep module of the library. Following it are the definitions of the linear\n    and binary constructors. As may be seen, the two definitions only differ in often\n    the internal recursion occurs.\n  ")]),t("pre",[e._v("    _expand ==                          # [I] [T] [R1] [R2] [r]  ==>\n                            # [ [pop I] [[T] dip] [[R1] dip r [R2] dip] ifte ]\n          swap                            # [I] [T] [R1] [r] [R2]\n          [dip] cons                      #  .. .. .. .. [[R2] dip]\n          concat                          #  .. .. .. [r [R2] dip]\n          [dip] swoncat                   #  .. .. .. [dip r [R2] dip]\n          cons                            #  .. .. [[R1] dip r [R2] dip]\n          [ [dip] cons                    #  .. [[T] dip] ..\n            [ [pop] swoncat] dip ]        #  [pop [I]] .. ..\n          dip\n          [ifte] cons cons cons;          # [ .. .. .. ifte ]\n\n      linear == [i] _expand;\n      binary == [dip swap i] _expand\n  ")]),t("p",[e._v("\n    In the test file the constructors linear and binary are used to define the more readable\n    versions of three core quotations, one for factorial, one for the length of sequences,\n    and one for naive Fibonacci. The syntactic similarity of the parameters to the\n    parameters for the inbuilt linrec andd binrec combinators should be noted. These\n    are then used to construct the three reproducing programs, the one for length with\n    an accumulator, the other two plain vanilla.\n  ")]),t("pre",[e._v(" DEFINE \n        fact-lin == [null] [pop 1] [dup pred] [*] rep.linear; \n        length-lin == [null] [pop 0] [rest] [succ] rep.linear; \n        nfib-bin == [small] [pop 1] [pred dup pred] [+] rep.binary; \n     \n        fact-fix == fact-lin rep.fix; \n        length-fix-a == length-lin rep.fix-a; \n        nfib-fix == nfib-bin rep.fix. \n     \n    4 fact-fix i pop. \n  24\n     \n    [2 5 3 7 6] [a b c] length-fix-a i swap put i swap putln trace. \n  3 5 \n  trace: [[] [6] [7 6] [3 7 6] [5 3 7 6] [2 5 3 7 6] [] [c] [b c] [a b c]] \n     \n    6 nfib-fix i pop. \n  13\n     \n    6 nfib-bin [] [[dup put] dip] rep.fix-i i newline pop. \n  6 5 4 3 2 1 0 1 2 1 0 3 2 1 0 1 4 3 2 1 0 1 2 1 0 \n  13\n  ")]),t("p",[e._v("\n    In the calls, the reproducing factorial program is tested just once, the length program\n    twice in succession on two lists, with a trace of what the accumulated parameters\n    were. The Fibonacci program is called twice with the parameter 6. The second version\n    uses the interactive fix-i constructor from the library to construct a reproducing\n    program which writes ([dup put]) the current parameter to the output. This gives\n    the trace of the parameters in the reverse order than they would be given if an\n    acumulator had been used.\n  ")]),t("p",[e._v("\n    Also in the test file are a a readable definition of the core quotation for quicksort,\n    followed by a definition of a reproducing version with a counter of the calls.\n    The third definition is for tests which will show the counter.\n  ")]),t("pre",[e._v(' DEFINE \n        qsort-bin == [small] [] [uncons [>] split] [enconcat] rep.binary; \n        qsort-fix-c == qsort-bin rep.fix-c; \n        qtest == qsort-fix-c i state. \n     \n    [5 10 9 14 7 18 1 4 15 3 20 19 8 11 2 6 12 13 16 17] qtest. . \n  29\n  [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20]\n     \n    [10 5 3 2 4 1 8 7 9 6 15 13 12 14 11 18 17 19 16 20] qtest. . \n  25\n  [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20]\n     \n    [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20] qtest. . \n  39\n  [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20]\n     \n    [20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1] qtest. . \n  39\n  [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20]\n     \n    "You can also sort strings, of course" qtest. . \n  55\n  "      ,Yaaccefgilnnooooorrrsssssttuu"\n  ')]),e._v("\n  In all the calls except the last, qtest is used on a list of the first 20\n  positive integers. In each case the same sorted list is produced, but the number\n  of calls needed to produce the result depends a great deal on the distribution in\n  the original list. In the first call the original is more or less random, and 29\n  calls are required. In the second call the original has been carefully constructed\n  to minimise calls to 25. In the last two calls the original lists are strictly ascending\n  or descending, requiring 39 calls both. This is a familiar feature of the quicksort\n  algorithm. The very last call to quicksort shows that it also sorts strings.\n  "),t("p",[e._v("\n    Back to "),t("a",{attrs:{href:"#CONT"}},[e._v("Content")]),t("a",{attrs:{name:"TOC-8"}})]),t("h2",[t("a",{attrs:{name:"TOC-8"}},[e._v("Final remarks")])]),e._v("\n  How efficient are reproducing programs? To start, here again is the first, the selfreproducing\n  program:\n  "),t("pre",[e._v("        [[duco] duco]  i   ==>   [[duco] duco]\n  ")]),e._v("\n  The steps required for one reproductions are:\n  "),t("pre",[e._v("    1. Execute the i combinator to activate the outer quotation\n      2. Push the inner quotation [duco]\n      3. Execute the duco (from the outer quotation)\n      4. This expands to duplicating what has just been pushed,\n      5. followed by consing the two together.\n  ")]),e._v("\n  Hence a total of five steps. This could be optimised by inlining the duco:\n  "),t("pre",[e._v("        [[dup cons] dup cons]  i   ==>   [[dup cons] dup cons]   \n  ")]),e._v("\n  In this way step 3 is eliminated, and only four steps are required. For the\n  more complex programs in this note the actual reproducing steps are much the same:\n  1. execute the i combinator, 2. push the inner quotation, a step which is independent\n  of the size of the inner quotation. then 3. execute duco or dureco or durereco, in\n  2 or 3 or 4 further steps. Again step 3. could be eliminated by inlining. By turning\n  the three operators duco, dureco and durereco into Joy primitives, each reproduction\n  would be executed in three steps: the i combinator, the push for the internal quotation,\n  and then the new primitive. So reproduction of itself is not an intrinsically expensive\n  operation.\n  "),t("p",[e._v("\n    Of course the more complex programs did other things apart from just reproducing,\n    so they are longer in the first place. But half their actual length is due to their\n    internal quotation, which always has to be pushed - in one simple step. The remainder\n    of their length is due to two sources: doing their intended job, and doing some\n    additional work to fit in with the implementation by reproduction. The part due\n    to the intended job varies with the nature of the job, of course. And the additional\n    work is probably much the same with any other implementation.\n  ")]),t("p",[e._v("\n    But it is worth considering which several things done in this note by reproduction\n    could also be done in other ways. Most of the reproducing programs discussed here\n    added either an internal state or an internal program or both to a simple repoducing\n    program. Can their effects be achieved by other means? Clearly the internal state\n    could be replaced by an item on the stack, and the internal program which does\n    the principal job could well be an ordinary one which does not have to reproduce.\n    Now the question does arise whether extra jobs such as keeping a count of the number\n    of calls or maintaining an accumulator can be done in a clean manner. If the programs\n    are designed that way from the start they clearly can. However, some of the constructions\n    for reproducing programs in this note have been more flexible than that: they supplied\n    the basis for an ordinary program, such as for sorting, together with several ways\n    of executing it: Either plain vanilla, or with an execution count, or with an accumulator.\n  ")]),t("p",[e._v("\n    So in some respects these constructions behaved like combinators, in that various\n    basic programs could be mixed with various ways of executing them. There seems\n    to be a superficial difference: ordinary combinators do not change the actual code\n    inside the quotation, whereas these constructions seem to do just that. But firstly,\n    this difference would be more than superficial, and secondly, this is not what\n    actually occurs. This needs some elaboration.\n  ")]),t("p",[e._v("\n    Let X be one of the reproducing recursive programs of the previous section, for factorial,\n    Fibonacci or sorting, together with the various constructions that enabled plain\n    vanilla execution, or execution with a call count or with a trace. They all consisted\n    of a basic program, say basic-X, specific to one of the three functions, and then\n    the constructions that created three varieties, say do-X, do-counting-X and do-tracing-X,\n    each to be called by the i combinator. For the counting and the tracing versions\n    the basic code was substantially modified, but mostly this involved replacing a\n    simple quotation [Q] by a quotation [[Q] dip]. So [Q] was not touched at all. A\n    few other modifications involved replacing a quotation [Q] by [pop Q], but again\n    without changing [Q]. Therefore the only difference between ordinary combinators\n    and the constructions here was that the result of the construction was to be called\n    by the i combinator - something which is not true of ordinary combinators.\n  ")]),t("p",[e._v("\n    It is probably true that any of the effects achieved by reproducing programs can\n    also be achieved by other means. Instead of making the state a part of the reproducing\n    program, the state could be an additional item on the stack - and as such it does\n    not need to be extracted from, and later re-incorporated into the reproducing program\n    at every step. The additional code required to produce a call count or to trace\n    or anything similar can be incorporated mechanically into just about any ordinary\n    recursive Joy program. For such features in non-recursive programs there is also\n    the less often used x combinator, which might have been defined by dup i.\n  ")]),t("p",[e._v("\n    In conclusion, although this survey might not have unearthed any techniques dramatically\n    different from more conventional ones, the topic of reproducing programs is of\n    some intrinsic interest. After all, many woes of computer security are precisely\n    due to malicious reproducing programs that infect our systems.\n  ")])])}]};n.a=o}});