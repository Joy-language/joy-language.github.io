webpackJsonp([15],{F2Fa:function(e,t,n){"use strict";var o=function(){var e=this.$createElement;this._self._c;return this._m(0)};o._withStripped=!0;var i={render:o,staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("article",[n("p",[e._v("\n    Joy is a purely functional language, and yet it is often useful to think in imperative\n    mode when writing Joy programs. This rsults from the fact that Joy is based on\n    the composition of functions, and not on the application of functions. This was\n    first made explicit by Billy Tanksley (2000) in his preamble to the mailing group\n    concatenative:\n    "),n("br"),n("a",{attrs:{href:"http://groups.yahoo.com/group/concatenative"}},[e._v("\n    http://groups.yahoo.com/group/concatenative")]),n("br")]),n("p",[e._v("\n    This note illustrates imperative thinking for five Joy programs. In the literature\n    these are often written recursively. But they either are tail recursive or can\n    be rewritten in a tail recursive form, possibly using accumulators. Consequently\n    these programs can also be written in an imperative style without recursion but\n    using loops. In this note the imperative version is used as the starting point\n    which is then translated into purely functional Joy.\n  ")]),n("p",[e._v("\n    The first two programs are for computing the "),n("strong",[e._v("factorial")]),e._v(" and the\n    "),n("strong",[e._v("Fibonacci")]),e._v(" functions. Both use the "),n("strong",[e._v("times")]),e._v(" combinator\n    of Joy. The third and fourth program are for computing the greatest common divisor\n    function "),n("strong",[e._v("gcd")]),e._v(" and the predicate for determining whether a number\n    is "),n("strong",[e._v("prime")]),e._v(". Both use the "),n("strong",[e._v("while")]),e._v(" combinator of Joy.\n    The last program is a combinator for Newton's method of finding arguments for which\n    a given function returns a zero value. The method works by starting with a guessed\n    argument and improving it until it has the required magnitude. This Joy program\n    also uses the "),n("strong",[e._v("while")]),e._v(" combinator. The method can also be used to\n    compute inverses of functions, for example for finding cube-roots when given a\n    cubing function.\n  ")]),n("p",[e._v("\n    All five programs were developed using corresponding Scheme programs in Abelson and\n    Sussman (19??) as a guide.\n  ")]),n("h2",[e._v("The "),n("em",[e._v("times")]),e._v(" combinator for the "),n("em",[e._v("factorial")]),e._v(" function")]),e._v('\n  The factorial function is often given a recursive definition to illustrate either\n  recursion in general or definitions in a particular language. But it is well known\n  that recursion is not necessary, and that at least a "tail-recursive" variant is\n  more efficient. For a given positive integer N, the factorial of N is just the product\n  of the first N positive integers. The product of no numbers should be the identity\n  element for multiplication, so the factorial of 0 is set to 1. Hence for any non-negative\n  N the factorial can be computed by a simple imperative program (here in a fantasy\n  language):\n  '),n("br"),n("pre",[e._v("      factorial(N) =\n    VAR P := 1\n    VAR I\n    FOR I := 1 TO N DO\n        P := P * I\n          RETURN P\n  ")]),e._v("\n  The upper limit N ensures that the body of the loop will be executed exactly\n  N times. In addition, the FOR-loop will increment the variable I exactly as required.\n  But we could do the incrementing explicitly:\n  "),n("br"),n("pre",[e._v("      factorial(N) =\n    VAR P := 1\n    VAR I := 1\n    N TIMES DO\n        P := P * I\n        I := I + 1\n    RETURN P\n  ")]),e._v("\n  To translate this into Joy, here is a first draft. The TIMES-loop will be\n  executed by the times combinator of Joy. The body of the loop will need to be expressed\n  in Joy, but we do that later. Before the loop there will need to be some initialisation\n  corresponding to the imperative program. And after the loop there will need to be\n  some finalisation corresponding to the RETURN.\n  "),n("br"),n("pre",[e._v('    factorial  ==\n    "initialise"\n    [ "body of loop" ]\n    times\n    "finalise"\n  ')]),e._v("\n  A call to the factorial function will be of the form\n  "),n("br"),n("pre",[e._v(" N  factorial\n  ")]),e._v("\n  where the N will have to be available for the times combinator. That means\n  that the simulation initialisation of the two variables P and I will have to be below\n  the N. In the imperative program both were initialised to 1. So below the parameter\n  N there will need to be two further stack elements, both 1, that are pushed under\n  the control of the dip combinator. Hence the initialisation is:\n  "),n("br"),n("pre",[e._v(" [ 1 1 ]  dip\n  ")]),e._v("\n  The body of the Joy loop has to do what the body of the imperative loop does:\n  "),n("br"),n("pre",[e._v("     P := P * I\n        I := I + 1\n  ")]),e._v("\n  The counterpart of P has to be multiplied by the counterpart of I, but there\n  has to be another copy of I available to be incremented by 1. So the body of the\n  Joy loop has to start with a dup operator to make that copy. Then thecounterpart\n  of P has to be multiplied by the original counterpart of I, and this has to occur\n  below the new copy of the counterpart of I. That is easily done by the combination\n  [*] dip. Finally, corresponding to the incrementing of I, the successor of the top\n  element is taken. Hence the body of the Joy loop is\n  "),n("br"),n("pre",[e._v(" dup  [*]  dip  succ\n  ")]),e._v("\n  The loop is executed N times, and when that is done the imperative program\n  returns P, whose counterpart is the second element from the top of the stack. So\n  the finalisation of the Joy program is\n  "),n("br"),n("pre",[e._v(" pop\n  ")]),e._v("\n  Putting the three pieces together, we have the definition\n  "),n("br"),n("pre",[e._v("    factorial  ==\n    [1 1] dip\n    [ dup [*] dip succ ]\n    times\n    pop\n  ")]),e._v("\n  This completes the Joy program. In the Joy library numlib.joy it is just a\n  one-liner:\n  "),n("br"),n("pre",[e._v("    fact == [1 1] dip [dup [*] dip succ] times pop;\n  ")]),n("h2",[e._v("The "),n("em",[e._v("times")]),e._v(" combinator for the "),n("em",[e._v("Fibonacci")]),e._v(" function")]),n("p",[e._v("\n    The Fibonacci function is also often given a recursive definition, generally just\n    to test efficiency of an implementation because a non-recursive definition would\n    be more efficient. The usual recursive definition is inefficient because the same\n    values have to be computed many times over. The following is a design of a non-recursive\n    version.\n  ")]),n("p",[e._v("\n    The Fibonacci function for the first two natural numbers 0 and 1 as arguments has\n    the values 0 and 1, and for any larger numbers as arguments it values is just the\n    sum of its values for the two preceding numbers. The following gives the arguments\n    and the values:\n    "),n("br")]),n("pre",[e._v("        arguments     0   1   2   3   4   5   6   7   8   ...\n          values        0   1   1   2   3   5   8  13  21   ...\n  ")]),e._v("\n  Note that to compute the later values only the values for the "),n("em",[e._v("two")]),e._v("preceding numbers are needed. This helps in the following consideration, where the\n  values are now arranged in a staircase:\n  "),n("br"),n("pre",[e._v("        arguments     values\n                  0     0   1\n      1         1   1\n      2             1   2\n      3                 2   3\n      4                     3   5\n      5                         5   8\n      6                             8  13\n  ")]),e._v("\n  Each step of the staircase consists of two numbers, the left and the right,\n  hereafter called L and R. Three observations can be made: (1) In the first, topmost\n  step L and R are respectively the Fibonacchi values for 0 and 1. (2) The two numbers\n  L and R of any step other than the first are obtained from the L and R of the preceding\n  step - the two numbers L and R are interchanged and then a new R is obtained by adding\n  L to it. (3) The Fibonacci value of N is on the N-th step from the top in the L number.\n  The three observations suffice for the following program. Again it uses a TIMES-loop\n  to execute (2) as often as required by the parameter N.\n  "),n("br"),n("pre",[e._v("    fibonacchi(N) =\n    VAR L := 0\n    VAR R := 1\n    N TIMES DO\n        L =:= R\n        R := L + R\n    RETURN L\n  ")]),e._v('\n  The mutual assignment operator "=:=" swaps the values of the two variables.\n  It might be implemented instead by\n  '),n("br"),n("pre",[e._v(" TEMP := L; L := R; R ;= TEMP\n  ")]),n("p",[e._v("\n    The program translates readily into Joy. A call to the Joy program will be of the\n    form\n    "),n("br")]),n("pre",[e._v(" N  fibonacci\n  ")]),e._v("\n  and hence the N will have to be available for the times loop. So the initialisation\n  has to take place just below the parameter N, with\n  "),n("br"),n("pre",[e._v(" [0  1]  dip\n  ")]),e._v("\n  Now the N will be consumed by the times combinator, and that will expose two\n  numbers corresponding to the values of L and R, with the value of R topmost. The\n  times combinator requires a quotation which corresponds to the body of the imperative\n  TIMES loop. The quotation has to swap the two numbers on top of the stack, and then\n  replace the top value by two sum of the two, but without consuming the second value.\n  This replacement can be done by [+] unary. So the quotation required is\n  "),n("br"),n("pre",[e._v(" [ swap  [+]  unary ]\n  ")]),e._v("\n  Finally, the value to be returned is what corresponds to L in the imperative\n  program, and that is the second value from the top of the stack. So the finalisation\n  is simply\n  "),n("br"),n("pre",[e._v(" pop\n  ")]),n("p",[e._v("\n    Putting the pieces together, this is the definition:\n    "),n("br")]),n("pre",[e._v("    fibonacchi  ==\n           [1 0] dip\n           [swap [+] unary]\n           times\n           pop\n  ")]),e._v("\n  In the Joy library numlib.joy this is also just a one-liner:\n  "),n("br"),n("pre",[e._v("    fib == [1 0] dip [swap [+] unary] times pop;\n  ")]),n("h2",[e._v("The "),n("em",[e._v("while")]),e._v(" combinator for the "),n("em",[e._v("gcd")]),e._v(" function")]),e._v("\n  The greatest common divisor (gcd) of two natural numbers is that number which divides\n  the two given numbers without remainder. Euclid's famous algorithm for finding the\n  gcd is based on the observation that\n  "),n("br"),n("pre",[e._v(" gcd(I,J)   ==   gcd(J, I rem J)\n  ")]),e._v("\n  where "),n("kbd",[e._v("I rem J")]),e._v(" is the remainder of dividing I by J. For J = 0 the\n  gcd is I. The steps for finding the gcd of 48 and 90 are:\n  "),n("br"),n("pre",[e._v("      step     values\n            1     48  90\n      2         90  48\n      3             48  42\n      4                 42   6\n      5          6   0\n  ")]),e._v("\n  Again there is a staircase with two values on each step, hereafter L and R.\n  The first step consists of the two arguments. On every succeeding step L is what\n  was the R of the preceding step, and the R is L rem R of the preceding step. This\n  might be written in an imperative language with a WHILE-loop as\n  "),n("br"),n("pre",[e._v("    gcd(L, R)  =\n    VAR TEMP\n    WHILE R > 0 DO\n        TEMP := R\n        R := L rem R\n        L := TEMP\n    RETURN L\n  ")]),e._v("\n  The program might even be written without the TEMP variable but with mutual\n  assignment like this:\n  "),n("br"),n("pre",[e._v("    gcd(L, R)  =\n    WHILE R > 0 DO\n        L := L rem R\n        L =:= R\n    RETURN L\n  ")]),e._v("\n  We now have to translate this into Joy. The call to the gcd program in Joy\n  will look like this:\n  "),n("br"),n("pre",[e._v(" 48  90  gcd\n  ")]),e._v("\n  Joy has a while combinator with takes two quotation parameters, a while-part\n  and a do-part. The structure of the program will be\n  "),n("br"),n("pre",[e._v('    gcd  ==\n    [ "while-part" ]\n    [ "do-part" ]\n    while\n    "finalise"\n  ')]),e._v("\n  So the while-part will have to test whether the number on top of the stack\n  is positive, and that is done with the quotation\n  "),n("br"),n("pre",[e._v(" [ 0 > ]\n  ")]),e._v("\n  The do-part will have to take the two parameters on top of the stack and simulate\n  the effect of the assignment statements of one or the other of the imperative versions.\n  (1) The top element on the stack will have to become the result of the rem operation.\n  (2) The second element on the stack will have to be what was the first element. Since\n  the rem operattion in (1) consumes the top element, but (2) needs it, that top element\n  will have to be saved by a dup (similar to using the TEMP). After the dup the second\n  and third element will have to available for the rem operation, and below the result\n  of that will have to be the saved or duplicated first element. So before the rem\n  the top three elements have to be shuffled by rollup, which moves the second and\n  third element up by one and the first element down by two. Thus the do-part is\n  "),n("br"),n("pre",[e._v(" [ dup  rollup  rem ]\n  ")]),e._v("\n  The finalisation of course just pops off the 0 which is now on top of the\n  stack.\n  "),n("p",[e._v("\n    So the entire definition is:\n    "),n("br")]),n("pre",[e._v("    gcd  ==\n    [ 0 >]\n    [ dup rollup rem ]\n    while\n    pop\n  ")]),e._v("\n  In the Joy library numlib.joy this is also just a one-liner:\n  "),n("br"),n("pre",[e._v("    gcd == [0 >] [dup rollup rem] while pop;\n  ")]),n("h2",[e._v("The "),n("em",[e._v("while")]),e._v(" combinator for the "),n("em",[e._v("prime")]),e._v(" predicate")]),n("p",[e._v("\n    One number N has another D as a divisor if and only if N divided by D leaves no remainder,\n    or a remainder of 0. A number N has a proper divisor D if and only if N has a divisor\n    D where D is other than 1 or N. A number N is prime if and only if it has no proper\n    divisors. If a number is not prime, then it has a proper divisor D no greater than\n    the square root of N, or equivalently the square of D is no greater than N.\n  ")]),n("p",[e._v("\n    So, given a number N, the search for a proper divisor could start with a test integer\n    T = 2 and go up to that value of T for which N is greater than the square of T.\n    During each step a test needs to be made to determine whether the remainder of\n    dividing N by T is positive. After each step T is incremented. The loop continues\n    while N is greater than the square of T AND T is not a divisor of N. The loop stops\n    when the preceding conjunction becomes false. Since there are two conjuncts, there\n    are two possible reasons why the conjunction has become false. If the second conjunct\n    fails then N is not prime, even if the first conjunct, N > T * T, is true. On\n    the other hand, if the first conjunct failed, then T has already been incremented\n    beyond the search range and hence N is prime. So N is prime if and only if the\n    loop has terminated with N < T * T. This algorithm can be expressed in an imperative\n    language as:\n    "),n("br")]),n("pre",[e._v("    prime(N) =\n    VAR T := 2\n    WHILE (N > T * T) AND (N rem T > 0) DO\n        T := T + 1;\n    RETURN N < T * T\n  ")]),n("p",[e._v("\n    The program translates well into Joy. Clearly it must have the structure\n    "),n("br")]),n("pre",[e._v('    prime ==\n    "initialise"\n    [ "termination-conjunction" ]\n    [ "increment-test-value" ]\n    while\n    "finalise"\n  ')]),e._v("\n  It is important that the conjunction and the incrementation of the loop be\n  done efficiently. This affects whether the initial test value 2 should be inserted\n  above or below the given number on top of the stack. Individually the two conjuncts\n  for the termination are best written as\n  "),n("br"),n("pre",[e._v(" dup * >\n    rem 0 >\n  ")]),e._v("\n  which suggests that the test value is above the argument. Hence the initialisation\n  should simply push the inital test value 2. Also, the test value should remain above\n  the argument, and the incrementing is done simply by the succ operator. But the termination\n  has to be a conjunction of the two conjuncts above, so they have to produce a truth\n  value each which are then conjoined by the and operator. One way is to use the nullary\n  combinator on the first conjunct to produce the first truth value without using up\n  the two arguments. Then the two arguments can be used for the other conjunct with\n  the dip combinator. So the entire termination conjunction is\n  "),n("br"),n("pre",[e._v(" [ [dup * >] nullary  [rem 0 >] dip  and ]\n  ")]),e._v("\n  The finalisation translates easily from the imperative program:\n  "),n("br"),n("pre",[e._v(" dup  *  <\n  ")]),n("p",[e._v("\n    So the entire program is as follows, as it appears in the library numlib.joy:\n    "),n("br")]),n("pre",[e._v("    prime ==\n    2\n    [ [dup * >] nullary  [rem 0 >] dip  and ]\n    [ succ ]\n    while\n    dup * < ;\n  ")]),n("h2",[e._v("The "),n("em",[e._v("while")]),e._v(" combinator for the "),n("em",[e._v("newton")]),e._v(" combinator")]),n("p",[e._v("\n    Given a differentiable function F of one variable, one sometimes needs to find its\n    roots, those values x for which F(x) = 0. One famous method, due to Newton, is\n    the following: Start with a guess G for what that value x might be. Compute F(G),\n    and if that is close enough to zero, take G to be the solution. Otherwise, use\n    the current guess and the function F to find a better guess. Repeat this process\n    until the latest guess is acceptable. This is essentially a WHILE loop.\n  ")]),n("p",[e._v("\n    So Newton's method is a general algorithm which takes two parameters, an initial\n    guess G and a function F. In imperative style an outline is this:\n    "),n("br")]),n("pre",[e._v('    newton(G,F) =\n    WHILE "F(G) is not close enough to 0" DO\n        "Use F and G to find a new G"\n    RETURN G\n  ')]),e._v("\n  For the WHILE-part it is necessary to specify a criterion for what counts\n  as close enough to 0. Some small value can be built into the algorithm. It is also\n  possible to make the value a further parameter. For simplicity this version will\n  select the value 0.0001 hardwired into the program. Since the function F can return\n  a positive or a negative value for the current guess, it is necessary to take the\n  absolute value instead. So the refinement for the WHILE-part is this:\n  "),n("br"),n("pre",[e._v(" abs(F(G)) > 0.0001\n  ")]),e._v("\n  The DO-part is more complicated. To find a better guess, it is necessary use\n  the old guess to determine whether the new guess should be larger or smaller, and\n  by how much. In Newton's method the slope of the function F at the old guess is used.\n  The new guess is then computed by subtracting from the old guess a value that depends\n  on (1) the value of F at the old guess, and (2) the slope of F at the old guess.\n  It is the slope that determines how close the new guess will be to the old guess.\n  The slope of F at the old guess is of course the value of the derivative of F, which\n  might be written as deriv(F). So the DO-part refines to\n  "),n("br"),n("pre",[e._v(" G  :=  G - F(G)/deriv(F,G)\n  ")]),e._v("\n  Combining the parts the imperative version of Newton's method is the following.\n  "),n("br"),n("pre",[e._v("    newton(G,F) =\n    WHILE  abs(F(G)) > 0.0001  DO\n        G   :=  G  -  F(G)/deriv(F,G)\n    RETURN G\n  ")]),e._v('\n  For the derivative of the function F we again have to select a small number\n  - ideally "infinitesimal" - say 0.001. Then F has to be applied to two values, x\n  plus 0.001 and x. The difference between the two results is divided by 0.001 to get\n  an approximation to the true slope of F at x. A definition might look like this:\n  '),n("br"),n("pre",[e._v("    deriv(F,x) =\n    (F(x + 0.001) - F(x)) / 0.001\n  ")]),e._v("\n  The imperative newton program and the second order derivative function are\n  now to be translated into Joy. It so turns out that the derivative of a function\n  F is useful elsewhere. The most general form would be one which takes as a parameter\n  a quotation, say [F], and which returns a quotation [D]. Both quotations would have\n  to compute unary functions, and either quotation would be used by some combinator,\n  quite possibly the i combinator. From the above formula we see that F is to be applied\n  separately to two arguments, firstly to x + 0.001, and secondly to just x alone.\n  Since x is needed twice, the argument has to be duplicated, and the small value 0.001\n  added to one of them. That is essentially\n  "),n("br"),n("pre",[e._v(" dup  0.001  +\n  ")]),e._v("\n  After the given quotation [F] has been applied to these two arguments, their\n  difference has to be divided by 0.001. But the difference has to be computed in the\n  right order, so a swap is needed before the subtraction. This fragment of the program\n  thus is:\n  "),n("br"),n("pre",[e._v(" app2  swap  -  0.001  /\n  ")]),e._v("\n  A call to the derivative program takes a parameter [F] as argument and it\n  produces another quotation:\n  "),n("br"),n("pre",[e._v(" [F]  deriv   ==> [ dup 0.001 + [F] app2 swap - 0.001 / ]\n  ")]),e._v("\n  The required quotation is constructed from [F] by the following program:\n  "),n("br"),n("pre",[e._v("    deriv == [app2 swap - 0.001 /] cons  [dup 0.001 +] swoncat;\n  ")]),e._v("\n  For example, the value of the derivative of the cube function for the argument\n  3.14 can be computed by\n  "),n("br"),n("pre",[e._v(" 3.14   [ dup dup * * ]  deriv  i     ==>     29.5882\n  ")]),n("p",[e._v("\n    We now return to the construction of the newton program. The functional argument\n    F will be a quotation, and the guess argument will be a number. Since the Joy program\n    takes a quotation as an argument, it is really a combinator, and combinators generally\n    expect the quotation to be on top of the stack, and any further arguments below.\n    So a call to the Joy program newton will normally take the form\n    "),n("br")]),n("pre",[e._v(" G  [F]  newton\n  ")]),e._v("\n  When the program exits it must leave behind a number on top of the stack which\n  could be fed into F to yield a small number very close to zero,\n  "),n("br"),n("pre",[e._v(" G  [F]  newton  F            ==>   0  (+/- 0.0001)\n  ")]),e._v("\n  The Joy program will have the structure\n  "),n("br"),n("pre",[e._v('    newton ==\n    "initialise"\n    [ "while-part" ]\n    [ "do-part" ]\n    while\n    "finalise"\n  ')]),e._v("\n  The do-part will require the quotation [F] and another quotation [D] for computing\n  the derivative at the current guess. The quotation [D] is best constructed once and\n  for all, and of course it needs to be constructed from [F]. This has to be done in\n  the initialisation, so before the loop is entered and after it exits the stack looks\n  like this:\n  "),n("br"),n("pre",[e._v(" G  [F]  [D]\n  ")]),e._v("\n  with [D] topmost. When the loop exits the [F] and [D] quotations are no longer\n  needed, and the stack element below them is the value to be returned. This already\n  settles the finalistion:\n  "),n("br"),n("pre",[e._v(" pop  pop\n  ")]),e._v("\n  In the initialisation the [D] quotation has to be constructed from the [F]\n  parameter using the deriv program. Now the initialisation can bewritten quite simply\n  as\n  "),n("br"),n("pre",[e._v(" dup  deriv\n  ")]),e._v("\n  The while-part has to determine whether the current guess, the third element\n  from the top of the stack, when supplied as an argument to F, gives a value close\n  enough to zero. The first element on the stack is actually the quotation [D], so\n  that has to be popped off. Below that are [F] and the current guess, just in the\n  right order for the i combinator. The result value might be positive or negative,\n  so the absolute value is taken and compared with 0.0001. So the transliteration of\n  the imperative program gives the following while-part for the Joy program:\n  "),n("br"),n("pre",[e._v(" [ pop i abs 0.0001 > ]\n  ")]),e._v("\n  The do-part is more complicated than that. This is partly because the computation\n  of the new guess has to use the two quotations [F] and [G] but also retain them for\n  possible further use. Another reason is that, as can be seen from the DO-part of\n  the imperative version, the current guess is needed three times to compute the new\n  guess. It so turns out that it only has to be duplicated once, but that has to be\n  done below the [F] and the [D], by [[dup] dip] dip, or equivalently by\n  "),n("br"),n("pre",[e._v(" [ dupd ]  dip\n  ")]),e._v("\n  Following that, the two quotations [F] and [D] have to be duplicated for future\n  use by a special duplication operator dup2. So the stack at this point looks like\n  this:\n  "),n("br"),n("pre",[e._v(" guess  guess  [F]  [D]  [F]  [D]\n  ")]),e._v("\n  After these preliminaries the new guess has to be computed so that afterwards\n  the stack looks like this:\n  "),n("br"),n("pre",[e._v(" newguess  [F]  [D]\n  ")]),e._v("\n  in readiness for possibly another sweep through the loop. Following the assignment\n  statement of the imperative version, the quotations [F] and [D] can be applied to\n  the uppermost copy of current guess to produce two values whose ratio is to be subtracted\n  from the lower copy of the current guess. The result is the new guess:\n  "),n("br"),n("pre",[e._v(" cleave  /  -\n  ")]),e._v("\n  But the preceding fragment has to be executed below the two quotations [F]\n  and [D] that were saved for possible later use. So the fragment has to be executed\n  under the control of a double dip:\n  "),n("br"),n("pre",[e._v(" [ [cleave / -]  dip]\n    dip\n  ")]),e._v("\n  This concludes the design of the do-part, which now is the following:\n  "),n("br"),n("pre",[e._v(" [ [dupd] dip\n      dup2\n      [[cleave / -] dip]\n      dip ]\n  ")]),e._v("\n  Finally, assembling the initialisation, the while-part, the do-part and the\n  finalisation we have the entire newton program as it appears in the numlib.joy standard\n  library.\n  "),n("br"),n("pre",[e._v("    newton ==    (*  Usage: guess [F] newton   *)\n    dup deriv   (* guess [F] [D]    *)\n    [ pop i abs 0.0001 > ] (* too big ?      *)\n    [ [dupd] dip        (* guess guess [F] [D]    *)\n      dup2      (* guess guess [F] [D] [F] [D]  *)\n      [[cleave / - ] dip]\n      dip  ]    (* newguess [F] [D]   *)\n    while\n    pop pop;\n  ")]),n("p",[e._v("\n    Newton's algorithm finds arguments for which given function has a value close to\n    zero. It is easy enough to use the algorithm to find arguments for which the given\n    function has a particular value other than zero. For such usage the desired particular\n    value has to be subtracted from the value given by Newton's method. Also, a quite\n    arbitrary initial guess has to be supplied. In this way Newton's method can be\n    used to compute the inverse of a given function. In Joy the required program is\n    "),n("br")]),n("pre",[e._v("    use-newton == [[-] cons] dip  swoncat  1 swap newton;\n  ")]),e._v("\n  For example, the cube-root function is the inverse of the cube function, and\n  we can define\n  "),n("br"),n("pre",[e._v("    cube-root == [dup dup * *] use-newton;\n  ")])])}]};t.a=i},ZmGD:function(e,t,n){(e.exports=n("FZ+f")(!1)).push([e.i,"p[data-v-77b74484]{margin-top:16px;margin-bottom:16px}hr[data-v-77b74484]{margin-bottom:16px}pre[data-v-77b74484]{margin-bottom:auto}code[data-v-77b74484],kbd[data-v-77b74484],pre[data-v-77b74484]{font-family:Roboto Mono,monospace}",""])},"b8+9":function(e,t,n){var o=n("ZmGD");"string"==typeof o&&(o=[[e.i,o,""]]),o.locals&&(e.exports=o.locals);n("rjj0")("fa127c74",o,!1,{sourceMap:!1})},lGpw:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var o=n("F2Fa"),i=!1;var a=function(e){i||n("b8+9")},r=n("VU/8")(null,o.a,!1,a,"data-v-77b74484",null);r.options.__file="pages/papers-on-joy/imperative-thinking-for-joy-programs.vue",t.default=r.exports}});