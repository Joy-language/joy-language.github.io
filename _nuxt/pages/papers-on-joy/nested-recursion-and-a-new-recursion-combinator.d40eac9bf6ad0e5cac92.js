webpackJsonp([20],{"3sga":function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=t("jfyH"),o=!1;var a=function(n){o||t("Zz+z")},r=t("VU/8")(null,i.a,!1,a,"data-v-5890672a",null);r.options.__file="pages/papers-on-joy/nested-recursion-and-a-new-recursion-combinator.vue",e.default=r.exports},Dtbp:function(n,e,t){(n.exports=t("FZ+f")(!1)).push([n.i,"p[data-v-5890672a]{margin-top:16px;margin-bottom:16px}hr[data-v-5890672a]{margin-bottom:16px}pre[data-v-5890672a]{margin-bottom:auto}code[data-v-5890672a],kbd[data-v-5890672a],pre[data-v-5890672a]{font-family:Roboto Mono,monospace}",""])},"Zz+z":function(n,e,t){var i=t("Dtbp");"string"==typeof i&&(i=[[n.i,i,""]]),i.locals&&(n.exports=i.locals);t("rjj0")("11afd06d",i,!1,{sourceMap:!1})},jfyH:function(n,e,t){"use strict";var i=function(){var n=this.$createElement;this._self._c;return this._m(0)};i._withStripped=!0;var o={render:i,staticRenderFns:[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("article",[t("p",[n._v("\n    Contents:\n  ")]),t("ol",[t("li",[t("a",{attrs:{href:"#TOC_1"}},[n._v("Introduction")])]),t("li",[t("a",{attrs:{href:"#TOC_2"}},[n._v("Recursive Definitions")])]),t("li",[t("a",{attrs:{href:"#TOC_3"}},[n._v("Self-application")])]),t("li",[t("a",{attrs:{href:"#TOC_4"}},[n._v("Partially explicit recursion")])]),t("li",[t("a",{attrs:{href:"#TOC_5"}},[n._v("A nested recursion combinator")])])]),t("a",{attrs:{name:"TOC_1"}},[t("h2",[t("strong",[n._v("Introduction")])])]),t("p",[n._v("\n    This note was prompted by Nick Forde's version of a Joy operator which computes the\n    Ackermann function which is one of the few well-known functions that use nested\n    recursion. He was trying to avoid explicit recursion in the definition, but found\n    that none of the recursion combinators of Joy "),t("em",[n._v("at the time")]),n._v(" were up to\n    the task. His finding prompted the inclusion of a new Joy combinator\n    "),t("em",[n._v("condnestrec")]),n._v(" into the language.\n  ")]),t("p",[n._v("\n    This note gives definitions of (the common simplification of) Ackermann's function,\n    of McCarthy's 91-function, of a function producing a Hamiltonian path over a hypercube,\n    of a function producing Gray sequences, and of the Hanoi problem. All involve nested\n    recursion. Several possible definition methods are used.\n  ")]),t("p",[n._v("\n    The definitions and the output of the examples in this note were obtained by running\n    the file\n    "),t("a",{attrs:{href:"joy/jp-nestrec.joy"}},[n._v("\n    jp-nestrec.joy")]),n._v(". Only the descriptive text in\n    this note was added later.\n    "),t("a",{attrs:{name:"TOC_2"}})]),t("h2",[t("a",{attrs:{name:"TOC_2"}},[t("strong",[n._v("Recursive Definitions")])])]),t("p",[n._v("\n    The following is the more or less standard definition of the factorial function:\n    "),t("br")]),t("pre",[n._v("     fact(n) = \n      IF n = 0 \n      THEN 1 \n      ELSE  n * fact(n-1) \n  ")]),n._v("\n  Here is the corresponding recursive definition in Joy:\n  "),t("br"),t("pre",[n._v(" DEFINE\n        r-fact == \n      [ null ] \n      [ pop 1] \n      [ dup pred r-fact *] \n      ifte. \n  ")]),n._v("\n  The following tests this definition - redundantly, of course. Note that the\n  response from Joy is indented to the left. The same style will be used in all later\n  tests.\n  "),t("pre",[n._v(" [ 0 1 2 3 4 5 6 ]  [r-fact]  map. \n  [1 1 2 6 24 120 720]\n  ")]),t("p",[n._v('\n    The next definition is of a not so familiar function originally due to McCarthy,\n    his intriguing "91 function":\n  ')]),t("pre",[n._v("     mcc91(i) = \n      IF i > 100 \n      THEN i - 10 \n      ELSE mcc91(mcc91(i + 11)) \n  ")]),n._v("\n  Note one very important feature not shared with the factorial function: In\n  the ELSE-part the recursive call to itself relies on the result of another recursive\n  call to itself. There are very few function definitions in which this pattern appears.\n  The following is the corresponding definition in Joy, note the double recursive call\n  in the second last line:\n  "),t("pre",[n._v(" DEFINE \n        r-mcc91 == \n      [ 100 > ] \n      [ 10 - ] \n      [ 11 + r-mcc91 r-mcc91 ] \n      ifte. \n  ")]),n._v("\n  Here is a simple test for some representative values:\n  "),t("br"),t("pre",[n._v(" [ -7 42 99 100 101 102 345 ]  [r-mcc91]  map. \n  [91 91 91 91 91 92 335]\n  ")]),t("p",[n._v("\n    The Ackermann function widely quoted in the literature is actually a simplification\n    of the function originally defined by Ackermann to show that there are terminating\n    recursive functions that are not primitive recursive. Both the original and the\n    descendent due to Peters grow at an extraordinary rate. Here is the now common\n    definition:\n  ")]),t("pre",[n._v("     ack(m, n) = \n      IF m = 0  THEN n + 1 \n      ELSEIF n = 0  THEN ack(m - 1, 1) \n      ELSE ack(m - 1, ack(m, n - 1)) \n  ")]),n._v("\n  and its counterpart in Joy:\n  "),t("br"),t("pre",[n._v(" DEFINE \n        r-ack == \n    # stack putln \n      [ [ [pop null]  popd succ ] \n        [ [null]  pop pred 1 r-ack ] \n        [ [dup pred swap] dip pred r-ack r-ack ] ] \n      cond. \n  ")]),n._v("\n  The line that has been commented out with the hash character is useful if\n  one wants to see a trce of what is sitting on the stack. The following tests are\n  complete from (0,0) up to (3,5), and give some indication of the behaviour. The final\n  line only gives the value for (4,0) because computation for (4,1) crashes the Joy\n  stack (and also, it seems, calculations in other languages).\n  "),t("pre",[n._v(" [ [0 0] [0 1] [0 2] [0 3] [0 4] [0 5] ]   [i r-ack]  map  putln \n    [ [1 0] [1 1] [1 2] [1 3] [1 4] [1 5] ]   [i r-ack]  map  putln \n    [ [2 0] [2 1] [2 2] [2 3] [2 4] [2 5] ]   [i r-ack]  map  putln \n    [ [3 0] [3 1] [3 2] [3 3] [3 4] [3 5] ]   [i r-ack]  map  putln \n    [ [4 0]                               ]   [i r-ack]  map. \n  [1 2 3 4 5 6] \n  [2 3 4 5 6 7] \n  [3 5 7 9 11 13] \n  [5 13 29 61 125 253] \n  [13]\n  ")]),t("p",[n._v("\n    In the Towers of Hanoi puzzle the disks have to be moved in a particular order. Ignoring\n    what the target peg is, for three disks the order is 1 2 1 3 1 2 1. In general\n    for n disks it is a sequence of (2^n)-1 steps. In the usual implementation of the\n    Hanoi program the disks that have to be moved are not mentioned at all. The sequence\n    of steps is also one that performs a Hamiltonian path on an n-dimensional hypercube.\n    The following is the Joy program:\n  ")]),t("pre",[n._v("  \n    DEFINE \n        r-hamilhyp ==   #  [] n  =>  [...] \n      [ null ] \n      [ pop ] \n      [ dup rollup pred       r-hamilhyp \n        dupd cons swap pred   r-hamilhyp ] \n      ifte. \n  ")]),n._v("\n  Note that unlike the program for the 91-function and the Ackermann function,\n  the two recursive calls are not consecutive. Since the sequences are less known than\n  the Hanoi program, here are several test outputs:\n  "),t("br"),t("pre",[n._v(" []  3  r-hamilhyp. \n  [1 2 1 3 1 2 1]\n    []  4  r-hamilhyp. \n  [1 2 1 3 1 2 1 4 1 2 1 3 1 2 1]\n    []  5  r-hamilhyp. \n  [1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1]\n  ")]),t("a",{attrs:{name:"TOC_3"}},[t("h2",[t("strong",[n._v("Self-application")])])]),t("p",[n._v('\n    One way to get by without recursive definitions is by using Curry\'s "paradoxical"\n    Y combinator which can also be defined in Joy. Another way would use what is known\n    as "self-application", giving a function a parameter which is also a function -\n    e.g. itself. In Joy there is an inbuilt combinator to this effect, but it might\n    have been defined by\n  ')]),t("pre",[n._v("        DEFINE\n              x == dup i.\n  ")]),n._v("\n  Using this combinator a non-recursive definition of the factorial function\n  is this:\n  "),t("br"),t("pre",[n._v(" DEFINE \n        x-fact == \n      [ [ pop null ] \n        [ pop pop 1] \n        [ [dup pred] dip x *] \n        ifte ] \n      x. \n  ")]),n._v("\n  Here is a test, and keep in mind that because the definition of "),t("kbd",[n._v("x-fact")]),n._v("is not recursive, as a parameter to the "),t("kbd",[n._v("map")]),n._v(" combinator instead of using\n  the quotation "),t("kbd",[n._v("[x-fact]")]),n._v(" it would have been possible to use quotation of\n  the body of the definition.\n  "),t("pre",[n._v(" [ 0 1 2 3 4 5 6 ]  [x-fact]  map. \n  [1 1 2 6 24 120 720]\n  ")]),t("p",[n._v("\n    In the recursive definition of the 91-function the recursive branch used a double\n    recursion. For a non-recursive version it is necessary to have a double self-call\n    with the x-combinator. Such a double call is useful elsewhere, so here we have\n    a definition:\n  ")]),t("pre",[n._v(" DEFINE \n        twice-x == \n      dup [x] dip x. \n  ")]),n._v("\n  Below is a non-recursive definition of the 91-function and the same test set\n  as before:\n  "),t("br"),t("pre",[n._v(" DEFINE \n        x-mcc91 == \n      [ [ pop 100 > ] \n        [ pop 10 - ] \n        [ [11 +] dip twice-x ] \n        ifte ] \n      x. \n     \n    [ -7 42 99 100 101 102 345 ]  [x-mcc91]  map. \n  [91 91 91 91 91 92 335]\n  ")]),t("p",[n._v("\n    Exactly the same technique can be used to give a non-recursive definition of the\n    Ackermann function using th x-combinator. Only one row of the test matrix is used\n    here:\n  ")]),t("pre",[n._v(" DEFINE \n        x-ack == \n      [ [ [ [pop pop null]  pop popd succ ] \n          [ [pop null]  [pop pred 1] dip x ] \n          [ [[dup pred swap] dip pred] dip twice-x ] ] \n      cond ] \n      x. \n     \n    [ [3 0] [3 1] [3 2] [3 3] [3 4] [3 5] ]   [i x-ack]  map. \n  [5 13 29 61 125 253]\n  ")]),n._v("\n  Whatever may be achieved with the x-combinator can also be achieved with the\n  less efficient but more familiar y-combinator, which needs to be defined first:\n  "),t("pre",[n._v(" DEFINE\n        y ==\n      [dup cons] swoncat dup cons i;\n        twice-i ==\n      dup [i] dip i.\n    DEFINE\n        y-ack ==\n      [ [ [ [pop pop null]  pop popd succ ]\n          [ [pop null]  [pop pred 1] dip i ]\n          [ [[dup pred swap] dip pred] dip twice-i ] ]\n      cond ]\n      y.\n    \n    [ [3 0] [3 1] [3 2] [3 3] [3 4] [3 5] ]   [i y-ack]  map.\n  [5 13 29 61 125 253]\n  ")]),t("p",[n._v("\n    Here is the non-recursive definition, using the x-combinator, of the function that\n    generates the hamiltonian path sequence on a hypercube, together with one of the\n    tests:\n    "),t("br")]),t("pre",[n._v(" DEFINE \n        x-hamilhyp == \n      [ [ pop null ] \n        [ pop pop ] \n        [ dup [ [dup rollup pred] dip  x ] dip \n          [dupd cons] dip \n          [swap pred] dip  x ] \n        ifte ] \n      x. \n     \n    []  5  x-hamilhyp. \n  [1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1]\n  ")]),t("a",{attrs:{name:"TOC_4"}},[t("h2",[t("strong",[n._v("Partially explicit recursion")])])]),t("p",[n._v("\n    Nick Forde suggested writing the Ackermann function by using the linrec combinator\n    to achieve one recursion, and to use explicit recursion for the other. For reasons\n    that do not concern us here, his version computes the "),t("em",[n._v("converse")]),n._v(" of the\n    text book definition. For that reason, in the tests below the call is to\n    "),t("kbd",[n._v("swap ack")]),n._v(":\n  ")]),t("pre",[n._v("  \n    DEFINE ack == (* I:n I:m -> I:a *) \n        [ [ [0 =] [pop 1 +] ] \n          [ [swap 0 =] [popd 1 - 1 swap] [] ] \n          [ [dup rollup [1 -] dip] [swap 1 - ack] ] ] \n        condlinrec. \n     \n    [ [0 0] [0 1] [0 2] [0 3] [0 4] [0 5] ]   [i swap ack]  map  putln \n    [ [1 0] [1 1] [1 2] [1 3] [1 4] [1 5] ]   [i swap ack]  map  putln \n    [ [2 0] [2 1] [2 2] [2 3] [2 4] [2 5] ]   [i swap ack]  map  putln \n    [ [3 0] [3 1] [3 2] [3 3] [3 4] [3 5] ]   [i swap ack]  map  putln \n    [ [4 0]                               ]   [i swap ack]  map. \n  [1 2 3 4 5 6] \n  [2 3 4 5 6 7] \n  [3 5 7 9 11 13] \n  [5 13 29 61 125 253] \n  [13]\n  ")]),t("p",[n._v("\n    In the same style we may define the 91-function using only a partially recursive\n    definition:\n    "),t("br")]),t("pre",[n._v(" DEFINE \n        l-mcc91 == \n      [ 100 > ] \n      [ 10 - ] \n      [ 11 + ] \n      [ l-mcc91 ] \n      linrec. \n     \n    [ -7 42 99 100 101 102 345 ]  [l-mcc91]  map. \n  [91 91 91 91 91 92 335]\n  ")]),t("p",[n._v("\n    The following partially recursive definition of the Ackermann function also uses\n    just the explicitly recursive call in the quotation for the double recursion:\n  ")]),t("pre",[n._v(" DEFINE \n        clr-ack == \n      [ [ [pop null]  [popd succ] ] \n        [ [null]  [pop pred 1]  [] ] \n        [ [[dup pred swap] dip pred]  [clr-ack] ] ] \n      condlinrec. \n     \n    [ [3 0] [3 1] [3 2] [3 3] [3 4] [3 5] ]   [i clr-ack]  map. \n  [5 13 29 61 125 253]\n  ")]),t("p",[n._v("\n    In the same style here is the partially recursive definition of the function for\n    the Hamiltonian path on a hypercube. But since there is only a two way branching,\n    the linrec combinator is used rather than the slightly more complex (and hence\n    more flexible) condlinrec combinator. Remember that the implicit recursion occures\n    between the third and fourth quotation.\n  ")]),t("pre",[n._v(" DEFINE  \n        lr-hamilhyp == \n      [ null ] \n      [ pop ] \n      [ dup rollup pred ] \n      [ dupd cons swap pred lr-hamilhyp ] \n      linrec. \n     \n    []  5  lr-hamilhyp. \n  [1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1]\n  ")]),t("p",[n._v("\n    Using almost the same definition with only a small change we obtain a definition\n    for something seemingly quite different. In the following only the commented line\n    has been inserted. The definition generates Gray sequences of subsets of small\n    numbers. Each subset is generated from its predecessor by having just one number\n    added or removed. This step is here done by an operation called "),t("em",[n._v("toggle")]),n._v(",\n    which takes a set of small numbers and another small number as parameters and returns\n    a set. If the number was in the original set then it is removed, if the number\n    was not in the original set then it is added. Here is the definition and some examples:\n  ")]),t("pre",[n._v(" DEFINE \n        toggle ==   #   {..} i  ->  {..] \n      [has]  [[not] dip swons not]  [swons]  ifte. \n     \n    {}  4  toggle. \n  {4}\n    {1 2 7}  2 toggle. \n  {1 7}\n  ")]),n._v("\n  Here is the function which constructs Gray sequences, and three examples:\n  "),t("br"),t("pre",[n._v(" DEFINE \n        lr-grayseq == \n      [ null ] \n      [ pop ] \n      [ dup rollup pred ] \n      [ dupd \n        dup [first swap toggle] dip  # inserted line \n        cons swap pred lr-grayseq ] \n      linrec. \n     \n    [{}]  3  lr-grayseq. \n  [{3} {1 3} {1 2 3} {2 3} {2} {1 2} {1} {}]\n    [{3}]  3  lr-grayseq. \n  [{} {1} {1 2} {2} {2 3} {1 2 3} {1 3} {3}]\n    [{1 2 3}]  3 lr-grayseq. \n  [{1 2} {2} {} {1} {1 3} {3} {2 3} {1 2 3}]\n  ")]),t("a",{attrs:{name:"TOC_5"}},[t("h2",[t("strong",[n._v("A nested recursion combinator")])])]),t("p",[n._v("\n    Nested recursion occurs not only in contrived functions like the Ackermann function\n    and the 91-function, but also in some others. Since one of the aims of Joy is to\n    emphasise common patterns, a new recursion combinator called "),t("kbd",[n._v("condnestrec")]),n._v("  was added to Joy. It resembles the "),t("kbd",[n._v("condlinrec")]),n._v(" combinator in that it\n    takes just one parameter which is a list of cases. Each case is a list, all but\n    the last have a quoted test predicate as their first element. All other elements\n    in a case list are again quotations. But whereas "),t("kbd",[n._v("condlinrec")]),n._v(" allows at\n    most two other quotations, "),t("kbd",[n._v("condnestrec")]),n._v(" allows any number. For both combinators\n    an implicit recursion occurs between any consecutive other quotations.\n  ")]),t("p",[n._v("\n    Here is the example for the Hamiltonian path on a hypercube. Note that the parameter\n    to the combinator is a list of just two cases. The first case consists of a test\n    quotation and another quotation, so there is no recursion here. The second case\n    is also the last, so it is the default, and it has no test quotation. There are\n    three quotations, so the implicit recursion occurs between them, so it occurs twice.\n  ")]),t("pre",[n._v(" DEFINE \n        cnr-hamilhyp == \n      [ [ [null] [pop] ] \n        [ [dup rollup pred] \n          [dupd cons swap pred] \n          [] ] ] \n      condnestrec. \n     \n    [] 4 cnr-hamilhyp. \n  [1 2 1 3 1 2 1 4 1 2 1 3 1 2 1]\n  ")]),t("p",[n._v("\n    In the following definition of the Ackermann function implicit recursion occurs once\n    in the second case, and twice in the third, default case. In each of the three\n    places the quotation following the implicit recursion is actually empty.\n  ")]),t("pre",[n._v(" DEFINE \n        cnr-ack == \n      [ [ [pop null]  [popd succ] ] \n        [ [null]  [pop pred 1]  [] ] \n        [ [[dup pred swap] dip pred]  []  [] ] ] \n      condnestrec. \n     \n    3 4 cnr-ack. \n  125\n  ")]),t("p",[n._v("\n    The program for Gray sequences is again obtained from the one for the Hamiltonian\n    path on a hypercube by inserting one line as indicated:\n  ")]),t("pre",[n._v(" DEFINE \n        cnr-grayseq == \n      [ [ [null]  [pop] ] \n        [ [dup rollup pred] \n          [dupd \n           dup [first swap toggle] dip # inserted \n           cons swap pred] \n          [] ] ] \n      condnestrec. \n     \n    [{}] 3 cnr-grayseq. \n  [{3} {1 3} {1 2 3} {2 3} {2} {1 2} {1} {}]\n  ")]),t("p",[n._v("\n    Since the Hamiltonian path sequence is also the sequence of the disk numbers in the\n    Hanoi problem, it is perhaps not too surprising that the solution to the Hamoi\n    problem is so similar. The solution of course has to specify the pegs: each move\n    has to specify from which peg the top disk is to be removed and to which peg it\n    is to be moved. However, the number of the disk is not normally mentioned. In the\n    following program the number of the disk directs the recursion just as in the Hamiltonian\n    problem, but the number of the disk does not appear in the output.\n  ")]),t("p",[n._v('\n    In this particular version of the program the user specifies a list of the names\n    of the three pegs, and the number of disks on the first peg. The disks on the first\n    peg are to be moved to the peg whose name is the second on the list, and the peg\n    whose name is the third item can be used as a temporary. The user chose to call\n    the pegs "source" "destination" and "temp" in the first example, and "S" "D" and\n    "T" in the second example.\n  ')]),t("pre",[n._v(" DEFINE \n        cnr-hanoi == \n      [[rolldown] infra] dip \n      [ [ [null] [pop pop] ] \n        [ [dup2 [[rotate] infra] dip pred] \n          [ [dup rest put] dip \n            [[swap] infra] dip pred ] \n          [] ] ] \n      condnestrec. \n     \n    [source destination temp]  2  cnr-hanoi. \n  [source temp] [source destination] [temp destination]\n    [S D T]  5  cnr-hanoi. \n  [S D] [S T] [D T] [S D] [T S] [T D] [S D] [S T] [D T] [D S] [T S] [D T] [S D] [S T] [D T] [S D] [T S] [T D] [S D] [T S] [D T] [D S] [T S] [T D] [S D] [S T] [D T] [S D] [T S] [T D] [S D]      \n  ")]),n._v("\n  It is interesting to note that although the Gray sequence program and the\n  Hanoi program are based on the same program, the Hamiltonian path program, the Gray\n  sequence produced consists of 2^n members and the Hanoi move sequence consists of\n  (2^n)-1 members.\n  "),t("p",[n._v("\n    Since this note started with the recursive definitions of the factorial function\n    and the 91-function, This section would not be complete without the corresponding\n    definitions using the "),t("em",[n._v("condnestrec")]),n._v(" combinator:\n    "),t("br")]),t("pre",[n._v(" DEFINE \n        cnr-fact == \n      [ [ [null] [pop 1] ] \n        [ [dup pred] [*] ] ] \n      condnestrec; \n     \n        cnr-mcc91 == \n      [ [ [100 >] [10 -] ] \n        [ [11 +] [] [] ] ] \n      condnestrec. \n     \n    [ 0 1 2 3 4 5 6 ]  [cnr-fact]  map. \n  [1 1 2 6 24 120 720]\n    [ -7 42 99 100 101 102 345 ]  [cnr-mcc91]  map. \n  [91 91 91 91 91 92 335]\n  ")]),t("p",[n._v("\n    In fact, "),t("kbd",[n._v("condnestrec")]),n._v(" is a veritable swiss army knife combinator. In\n    the following definitions of the "),t("kbd",[n._v("even")]),n._v(" predicate and the "),t("kbd",[n._v("abs")]),n._v("  (absolute value) operator,\n    "),t("kbd",[n._v("condlinrec")]),n._v(" is used just for conditionals without making use of the possibility\n    of recursion. For the "),t("kbd",[n._v("abs")]),n._v(" operator the default is actually empty.\n  ")]),t("pre",[n._v(" DEFINE \n        cnr-even == \n      [ [ [2 rem null] [pop true] ] \n        [ [pop false] ] ] \n      condnestrec; \n     \n        cnr-abs == \n      [ [ [0 <] [0 swap -] ] \n        [ [] ] ] \n      condnestrec. \n     \n    3 cnr-even. \n  false\n    4 cnr-even. \n  true\n    -5 cnr-abs. \n  5\n    6 cnr-abs. \n  6\n  ")]),t("p",[n._v("\n    The use of nested recursion in Joy has not yet been explored beyond these examples.\n    All the examples took a numeric parameter to guide the recursion, and one obvious\n    alternative to investigate is the use of lists.\n  ")]),t("p",[n._v("\n    MYNOTE: Bauer and Woessner, functions ble and morris. Manna, Ackermann for strings.\n  ")])])}]};e.a=o}});