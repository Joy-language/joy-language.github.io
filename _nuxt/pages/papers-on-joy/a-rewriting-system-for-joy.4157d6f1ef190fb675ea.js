webpackJsonp([28],{GxBv:function(e,t,n){var a=n("NzIn");"string"==typeof a&&(a=[[e.i,a,""]]),a.locals&&(e.exports=a.locals);n("rjj0")("787d869c",a,!1,{sourceMap:!1})},NzIn:function(e,t,n){(e.exports=n("FZ+f")(!1)).push([e.i,"p[data-v-0faefc04]{margin-top:16px;margin-bottom:16px}hr[data-v-0faefc04]{margin-bottom:16px}pre[data-v-0faefc04]{margin-bottom:auto}code[data-v-0faefc04],kbd[data-v-0faefc04],pre[data-v-0faefc04]{font-family:Roboto Mono,monospace}",""])},S1ZD:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=n("YiHI"),o=!1;var s=function(e){o||n("GxBv")},r=n("VU/8")(null,a.a,!1,s,"data-v-0faefc04",null);r.options.__file="pages/papers-on-joy/a-rewriting-system-for-joy.vue",t.default=r.exports},YiHI:function(e,t,n){"use strict";var a=function(){var e=this.$createElement;this._self._c;return this._m(0)};a._withStripped=!0;var o={render:a,staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("article",[n("i",[e._v(" by Manfred von Thun ")]),n("p",[e._v("\n    This paper describes a conditional term rewriting system for Joy based on the two\n    constructors concatenation and quotation.\n  ")]),n("p",[e._v("\n    A "),n("em",[e._v("rewriting system")]),e._v(" consists of a set of syntactic rules for performing\n    replacements on certain suitable entities. The best known such system is the one\n    we learnt at school for evaluating arithmetic expressions. Any programming language\n    can be given a rewriting system, but for Joy it is particularly simple. The basic\n    binary rewriting relation will be written in infix notation as "),n("code",[e._v("=>")]),e._v(',\n    pronounced "can be rewritten as". The following are some sample rules for the '),n("kbd",[e._v("+")]),e._v("  operator, the "),n("kbd",[e._v("<")]),e._v(" predicate and the "),n("kbd",[e._v("dip")]),e._v(" combinator.\n  ")]),n("pre",[e._v("        2  3  +   =>   5\n          2  3  <   =>   true\n          a  [P]  dip   =>   P  a\n  ")]),e._v("\n  In the last example,\n  "),n("code",[e._v("P")]),e._v(" is any program and "),n("code",[e._v("a")]),e._v(" is any literal (such as a number)\n  or a program whose net effect is to push exactly one item onto the stack. The rewriting\n  relation is extended to allow rewriting in appropriate contexts, further extended\n  to accomodate several rewriting steps, and finally extended to become a congruence\n  relation, an equivalence relation compatible with program concatenation. This congruence\n  relation between programs is essentially the same as the identity relation in the\n  algebra of of functions which the programs denote. Although Joy functions take a\n  stack as argument and value, in the rewrite rules the stack is never mentioned.\n  "),n("p",[e._v("\n    The following are rewriting rules for arithmetic expressions in four different notations:\n    infix, functional, prefix and postfix:\n  ")]),n("pre",[e._v("        2 + 3  =>  5                    +(2,3)  =>  5\n          + 2 3  =>  5                    2 3 +   =>  5\n  ")]),e._v("\n  In each case on the left the operands are "),n("code",[e._v("2")]),e._v(" and "),n("code",[e._v("3")]),e._v(",\n  and the operator or "),n("em",[e._v("constructor")]),e._v(" is "),n("code",[e._v("+")]),e._v(", so they all refer to\n  the same arithmetic term. Since Joy uses what looks like postfix notation, it might\n  be thought that one should attempt a term rewriting system with rules just like the\n  second one in the last line. That would treat the short program "),n("code",[e._v("2 3 +")]),e._v("as being composed of two operands and one operator or constructor. It would also\n  treat the gap between "),n("code",[e._v("2")]),e._v(" and "),n("code",[e._v("3")]),e._v(" as quite different from the\n  gap between "),n("code",[e._v("3")]),e._v(" and "),n("code",[e._v("+")]),e._v(". The difference would be explained\n  away as a syntactic coincidence due to the choice of notation. Apart from "),n("code",[e._v("+")]),e._v("there would be very many term constructors.\n  "),n("p",[e._v("\n    However, Joy has operators for manipulating the top few elements of the stack, such\n    as "),n("kbd",[e._v("swap")]),e._v(", "),n("kbd",[e._v("dup")]),e._v(" and "),n("kbd",[e._v("pop")]),e._v(". These are also found in\n    the language "),n("em",[e._v("Forth")]),e._v(", see for example \\AX{Salman {\\it et al}}{1984}{Salman-etal:84}\n    and \\AX{Kelly {\\it et al}}{1986}{Kelly-etal:86}. These operators take a stack as\n    argument and yield a stack as value, and their presence forces all other operators\n    to be of the same type. For example, the following is a rewrite rule for "),n("kbd",[e._v("swap")]),e._v(":\n  ")]),n("pre",[e._v("        a  b  swap   =>   b  a\n  ")]),e._v("\n  Unlike Forth, Joy also has quotations and combinators. These features also\n  force the conclusion that the appropriate rewriting system is a string rewriting\n  system. Consider the following four programs:\n  "),n("pre",[e._v("        [2] [3 +] b                     [2] [3 +] concat i\n          [2 3] [+] b                     [2 3] [+] concat i\n  ")]),e._v("\n  They all eventually have to reduce to "),n("code",[e._v("5")]),e._v(", just like the earlier\n  Joy program "),n("code",[e._v("2 3 +")]),e._v(". It suggests that in the latter the gaps have to be\n  treated in the same way, the program is a concatenation of three atomic symbols,\n  and it denotes the composition of three functions. So, at least for Joy programs\n  without quotations and combinators, the appropriate system is a string rewriting\n  system. Such a system is equivalent to a term rewriting system with a "),n("em",[e._v("concatenation constructor")]),e._v("for programs as the only constructor. To handle combinators, a "),n("em",[e._v("quotation constructor")]),e._v("has to be introduced as a second constructor.\n  "),n("p",[e._v("\n    The remainder of this paper is organised as follows: The next section introduces\n    rewriting systems in general. Then follows a section on the principal concepts\n    of a rewriting system for Joy. The next two sections give details of rewriting\n    rules for operators and for combinators. Two other sections re-examine the stack\n    and the quotation constructor. It is argued that the stack is not just an optimisation\n    useful in an inmplementation, but that it is almost essential for understanding\n    the semantics of Joy. The possibility of an extensional version of the quotation\n    constructor is discussed but dismissed as unnecessarily restrictive. A final section\n    is an outline of a rewriting system for Joy types; the system resembles a categorial\n    grammar.\n  ")]),n("h1",[e._v("String and term rewriting systems")]),n("p",[e._v("\n    Rewriting systems can be classified according to the entities that are being rewritten.\n    In a "),n("em",[e._v("string rewriting system")]),e._v(" those entities are linear sequences of\n    symbols or strings of symbols. In a "),n("em",[e._v("term rewriting system")]),e._v(" these entities\n    are expressions or terms build from operands and operators. In a "),n("em",[e._v("graph rewriting system")]),e._v("  they are graphs of various kinds.\n  ")]),n("p",[e._v("\n    A "),n("em",[e._v("string rewriting system")]),e._v(" is based on an "),n("em",[e._v("alphabet")]),e._v(" which is just\n    a set of symbols. Strings over a given alphabet are arbitrary sequences of symbols,\n    each taken from the alphabet. The empty sequence or null string is included. A\n    rewriting rule is of the form\n  ")]),n("pre",[e._v("        x   =>   y\n  ")]),e._v("\n  where both x and y are strings. A string rewriting system consists of an alphabet\n  and a relation "),n("kbd",[e._v("=>")]),e._v(", a set of such pairs or rules. A wider relation "),n("kbd",[e._v("==>")]),e._v("is defined as follows: For strings "),n("code",[e._v("w")]),e._v(", "),n("code",[e._v("x")]),e._v(", "),n("code",[e._v("y")]),e._v("and "),n("code",[e._v("z")]),e._v(",\n  "),n("pre",[e._v("        w x z   ==>   w y z\n  ")]),e._v("\n  if and only if "),n("code",[e._v("x => z")]),e._v(". This relation allows replacement of\n  "),n("code",[e._v("x")]),e._v(" by "),n("code",[e._v("y")]),e._v(" in arbitrary contexts "),n("code",[e._v("w..z")]),e._v(".\n  "),n("p",[e._v("\n    A "),n("em",[e._v("term rewriting system")]),e._v(" also requires an alphabet of symbols. Each symbol\n    has an associated "),n("em",[e._v("arity")]),e._v(" which is a natural number (0, 1, 2, ...). Symbols\n    of arity 0 are nullary symbols or operands, symbols of positive arity are unary,\n    binary, ternary and so on symbols or operators. A "),n("em",[e._v("term")]),e._v(" over such an alphabet\n    is either an operand or it is an operator of arity $n$ together with $n$ further\n    terms. Terms are really abstract syntax trees, and various notations can be used\n    for their concrete linear representation. A rewriting rule is again a pair of the\n    form\n  ")]),n("pre",[e._v("        x   =>   y\n  ")]),e._v("\n  where "),n("code",[e._v("x")]),e._v(" and "),n("code",[e._v("y")]),e._v(" now have to be terms. A term rewriting\n  system consists of an alphabet of symbols, each with their own arity, and a set of\n  such rules. A wider relation "),n("kbd",[e._v("==>")]),e._v(" is defined as follows:\n  "),n("pre",[e._v("        y   ==>   z\n  ")]),e._v("\n  if and only if "),n("code",[e._v("y")]),e._v(" and "),n("code",[e._v("z")]),e._v(" are alike terms except that\n  "),n("code",[e._v("y")]),e._v(" contains a subterm "),n("code",[e._v("u")]),e._v(" where "),n("code",[e._v("z")]),e._v(" contains a\n  subterm "),n("code",[e._v("w")]),e._v(" such that "),n("code",[e._v("u => w")]),e._v(".\n  "),n("p",[e._v("\n    In any rewriting system it is useful to define "),n("kbd",[e._v("==>>")]),e._v(" as the reflexive\n    transitive closure of "),n("code",[e._v(" ==> ")]),e._v(".\n  ")]),n("pre",[e._v("        x   ==>>   z\n  ")]),e._v("\n  if and only if "),n("code",[e._v("x = z")]),e._v(" or for some "),n("code",[e._v("y")]),e._v(",\n  "),n("code",[e._v("x ==> y")]),e._v(" and "),n("code",[e._v("y ==>> z")]),e._v(".\n  "),n("p",[e._v("\n    Here is an example for a fragment of a rewriting system for arithmetical expressions\n    in Joy:\n  ")]),n("pre",[e._v("        2 3 +       =>   5\n          7 2 3 + *   ==>    7 5 *\n          7 2 3 + *   ==>>   35\n  ")]),e._v("\n  In the second line the subexpression "),n("code",[e._v("2 3 +")]),e._v(" on the left is called\n  a reducible expression or "),n("em",[e._v("redex")]),e._v(" since it can be reduced using the rule in\n  the first line.\n  "),n("p",[e._v("\n    There are two distinct ways in which a string rewriting system can be interpreted\n    as a term rewriting system. On the first interpretation, the term system has exactly\n    one operand. It has as unary constructors all the symbols of the string system.\n    It has no other constructors. The single operand is just the null string, and any\n    symbol, say "),n("code",[e._v("s")]),e._v(" from the string alphabet is interpreted as a unary\n    operator "),n("em",[e._v(" append")]),n("code",[e._v("s")]),e._v(". The appending is either uniformly on\n    the left or uniformly on the right.\n  ")]),n("p",[e._v("\n    On the second interpretation, the term system has as operands all the symbols from\n    the string system. It has only one binary constructor, concatenation. This interpretation\n    is most useful for a rewriting system for Joy because it is now possible to add\n    the unary "),n("em",[e._v("quotation constructor")]),e._v(" which is needed for the combinators.\n  ")]),n("p",[e._v("\n    Rewriting systems can be based just on unconditional rules of the form "),n("code",[e._v("x => y")]),e._v(",\n    but they can also have "),n("em",[e._v("conditional rule")]),e._v("s. Such rules state that certain\n    rewritings are permitted provided certain other rewritings are permitted. The next\n    sections give a "),n("em",[e._v("conditional rewriting system")]),e._v(" for Joy.\n  ")]),n("p",[e._v("\n    A short general introduction to rewriting systems is in \\AX{Salomaa}{1985}{Salomaa:85}.\n    String rewriting systems in particular are discussed in \\AX{Book}{1985}{Book:85}.\n    A general survey of rewriting systems is in \\AX{Schmitt}{1987}{Schmitt:87}. %\n  ")]),n("h1",[e._v("A conditional rewriting system for Joy")]),n("p",[e._v("\n    This section describes the basis of a conditional rewriting system for Joy using\n    a notation similar to Prolog.\n  ")]),n("p",[e._v("\n    A rewriting system for Joy will be a collection of syntactic rules for rewriting\n    Joy programs. Such a system must be based on the two principal program constructors,\n    "),n("em",[e._v("program concatenation")]),e._v(" and "),n("em",[e._v("program quotation")]),e._v(". The system to be\n    presented here uses (unconditional) axioms of the form\n  ")]),n("pre",[e._v("        P   =>   Q\n  ")]),e._v("\n  where "),n("code",[e._v("P")]),e._v(" and "),n("code",[e._v("Q")]),e._v(" are programs. There are also conditional\n  rules of the following forms, where "),n("code",[e._v("R")]),e._v(", "),n("code",[e._v("S")]),e._v(", "),n("code",[e._v("T")]),e._v("and "),n("code",[e._v("U")]),e._v(" are further programs.\n  "),n("pre",[e._v("        P  =>  Q   :-   R  =>  S.\n          P  =>  Q   :-   R  =>  S,  T  => U.\n  ")]),e._v("\n  The rules are written in a "),n("em",[e._v("Prolog")]),e._v("-like syntax. The turnstyle "),n("kbd",[e._v(":-")]),e._v('is pronounced "if". On its left is the conclusion or '),n("em",[e._v("consequent")]),e._v(". On the\n  right is a premise or "),n("em",[e._v("antecedent")]),e._v(". The antecedent can be a conjunction, as\n  in the second form above, and the comma "),n("kbd",[e._v(",")]),e._v(' is pronounced "and". So the\n  second of the above rules can be read as: "\n  '),n("code",[e._v("P")]),e._v(" can be replaced by "),n("code",[e._v("Q")]),e._v(" if\n  "),n("code",[e._v("R")]),e._v(" can be replaced by "),n("code",[e._v("S")]),e._v(" and\n  "),n("code",[e._v("T")]),e._v(" can be replaced by "),n("code",[e._v("U")]),e._v('". Details of these rules are given\n  in the next two sections.\n  '),n("p",[e._v("\n    Using the same notation, the relation "),n("kbd",[e._v("==>")]),e._v(" is defined by the three\n    rules\n  ")]),n("pre",[e._v("          P  ==>  Q     :-   P  =>  Q.\n          P Q  ==>  P R   :-   Q  ==>  R.\n          P R  ==>  Q R   :-   P  ==>  Q.\n  ")]),e._v("\n  The last two clauses allow rewriting in a context --- "),n("code",[e._v("P")]),e._v(" on the\n  left or "),n("code",[e._v("R")]),e._v(" on the right.\n  "),n("p",[e._v("\n    The next rules for "),n("code",[e._v(" ==> ")]),e._v(" concern combinators. In the following,\n    "),n("code",[e._v("C")]),e._v("$i$ is any combinator expecting at least $i$ quotation parameters.\n  ")]),n("pre",[e._v("        [P] C1  ==>  [Q] C1   :-   P ==> Q.\n          [P] [R] C2  ==>  [Q] [R] C2   :-   P  ==> Q.\n          [P] [S] [R] C3  ==>  [Q] [S] [R] C3   :-   P  ==> Q.\n          [P] [T] [S] [R] C4  ==>  [Q] [T] [S] [R] C4   :-   P  ==>  Q.\n  ")]),n("p",[e._v("\n    Note that there is no rewrite rule\n  ")]),n("pre",[e._v("        [P]  ==>  [Q]   :-   P  ==>  Q.\n  ")]),e._v("\n  The reason for this is further explained in section 7.\n  "),n("p",[e._v("\n    The final relation to be introduced is "),n("kbd",[e._v("==>>")]),e._v(", the reflexive transitive\n    closure of "),n("code",[e._v("==>")]),e._v(". It is defined by\n  ")]),n("pre",[e._v("        P  ==>>  P.\n          P  ==>>  R   :-   P  ==>  Q,  Q  ==>> R.\n  ")]),n("p",[e._v("\n    The simplest examples of rewriting axioms are those generated by "),n("em",[e._v("definition")]),e._v("s.\n    If an atom "),n("code",[e._v("name")]),e._v(" has been defined using "),n("kbd",[e._v("==")]),e._v(" as program "),n("code",[e._v("P")]),e._v(",\n    in the form\n  ")]),n("pre",[e._v("        name   ==   P\n  ")]),e._v("\n  then "),n("code",[e._v("name")]),e._v(" may be rewritten as "),n("code",[e._v("P")]),e._v(":\n  "),n("pre",[e._v("        name   =>   P\n  ")]),n("p",[e._v("\n    The stack is normally a sequence of values of various types. This sequence is just\n    a special list which is modified by programs. The first general operator is "),n("kbd",[e._v("newstack")]),e._v(",\n    which clears the stack. Clearing twice is the same as clearing just once. If literals\n    were pushed before the clearing, this has the same effect as just clearing. So\n    "),n("code",[e._v("newstack")]),e._v(" is in fact the "),n("em",[e._v("right zero")]),e._v(" element for program concatenation.\n  ")]),n("pre",[e._v("        newstack  newstack   =>   newstack.\n          P  newstack   =>   newstack.\n  ")]),e._v("\n  Since the stack is a list, it should be possible to put this list on top of\n  the stack --- that is to say, on top of itself. Also, it should be possible to make\n  the list on top of the stack become the stack. There are two operators that do just\n  that: The "),n("kbd",[e._v("stack")]),e._v(" operator pushes onto the stack a list containing all the\n  elements of the stack. The "),n("kbd",[e._v("unstack")]),e._v(" operator expects a list on top of the\n  stack and makes that the stack. The "),n("code",[e._v("unstack")]),e._v(" operator undoes what the\n  "),n("code",[e._v("stack")]),e._v(" operator does, but the reverse is true only in special cases.\n  "),n("pre",[e._v("        newstack stack  =>  newstack [].\n          [] unstack   =>   newstack.\n          newstack  L   =>  [L]  reverse  unstack.\n  ")]),e._v("\n  In the last rule, "),n("code",[e._v("L")]),e._v(" has to be a list of literals. Also, it should\n  be noted that the stack is not always a sequence of values, it can also contain operators\n  and combinators. So, strictly speaking the stack is always a quotation, and the "),n("code",[e._v("stack")]),e._v("operator pushes a quotation onto the stack, and the "),n("code",[e._v("unstack")]),e._v(" operator\n  expects a quotation on the stack and makes that the new stack.\n  "),n("p",[e._v("\n    Although the stack was mentioned in these informal explanations, it should be noted\n    that it is not referred to at all in the rewrite rules. The same will be true in\n    the sections to follow. Rewrite rules are purely syntactic, and the stack is a\n    semantic entity. Joy symbols denote functions from stacks to stacks. But syntax\n    does not concern semantic concepts such as denotation. rem\n  ")]),n("h1",[e._v("Rules for operators")]),e._v("\n  An "),n("em",[e._v("operator")]),e._v(" denotes a function which expects as argument one stack whose\n  top few elements satisfy some condition and which returns a stack in which the top\n  few elements have been replaced by something else, and which otherwise is like the\n  argument stack. This section gives rewrite rules for Joy operators. The first ones\n  given are for general operators that can be used for any stack. Then follow rules\n  for operators on "),n("em",[e._v("simple type")]),e._v("s such as truth values, characters and integers.\n  These are then followed by rules for operators on "),n("em",[e._v("aggregate type")]),e._v("s such as\n  sets, strings and lists.\n  "),n("p",[e._v("\n    The unary operators "),n("kbd",[e._v("pop")]),e._v(" and "),n("kbd",[e._v("dup")]),e._v(" are defined on all stacks\n    containing at least one element. In the rewrite rules to follow, let "),n("code",[e._v("a")]),e._v("  be any literal or a program whose net effect is to push exactly one value onto\n    the stack.\n  ")]),n("pre",[e._v("        a  pop   =>   id.\n          a  dup   =>   a  a.\n  ")]),e._v("\n  The generalisation that "),n("code",[e._v("a")]),e._v(" may be not just a literal but can be\n  a program whose effect is to push a single value is needed for rare cases like the\n  following:\n  "),n("pre",[e._v("        [*] first  dup   =>   [*] first  [*] first.\n  ")]),e._v("\n  The two programs on the left and right of the arrow have the net effect of\n  pushing two occurrences of the multiplication operator "),n("code",[e._v("*")]),e._v(" onto the stack.\n  "),n("p",[e._v("\n    The binary operators "),n("kbd",[e._v("swap")]),e._v(", "),n("kbd",[e._v("popd")]),e._v(", and "),n("kbd",[e._v("dupd")]),e._v(" are\n    defined on all stacks containing at least two elements. Let "),n("code",[e._v("a")]),e._v(" and\n    "),n("code",[e._v("b")]),e._v(" be any literals or equivalent programs.\n  ")]),n("pre",[e._v("        a  b  swap   =>   b  a.\n          a  b  popd   =>   b.\n          a  b  dupd   =>   a  a  b.\n  ")]),e._v("\n  The ternary operators "),n("kbd",[e._v("swapd")]),e._v(", "),n("kbd",[e._v("rollup")]),e._v(", "),n("kbd",[e._v("rolldown")]),e._v("and "),n("kbd",[e._v("rotate")]),e._v(" are defined on all stacks containing at least three elements.\n  Let "),n("code",[e._v("a")]),e._v(", "),n("code",[e._v("b")]),e._v(" and "),n("code",[e._v("c")]),e._v(" be any literals or equivalent\n  programs.\n  "),n("pre",[e._v("        a  b  c  swapd      =>   b  a  c.\n          a  b  c  rollup     =>   c  a  b.\n          a  b  c  rolldown   =>   b  c  a.\n          a  b  c  rotate     =>   c  b  a.\n  ")]),n("p",[e._v("\n    The ternary operator "),n("kbd",[e._v("choice")]),e._v(" also expects three elements, but the third\n    element has to be a truth value. Let "),n("code",[e._v("a")]),e._v(" and "),n("code",[e._v("b")]),e._v(" be any literals\n    or equivalent.\n  ")]),n("pre",[e._v("        true   a  b  choice   =>   a.\n          false  a  b  choice   =>   b.\n  ")]),n("p",[e._v("\n    The "),n("em",[e._v("simple type")]),e._v("s of Joy are the\n    "),n("em",[e._v("truth value type")]),e._v(", the "),n("em",[e._v("character type")]),e._v(" and the "),n("em",[e._v("integer type")]),e._v(".\n    The next rules are for the operators on these types.\n  ")]),n("p",[e._v("\n    Rewrite rules for the "),n("em",[e._v("unary operator")]),e._v("s\n    "),n("kbd",[e._v("succ")]),e._v(", "),n("kbd",[e._v("pred")]),e._v(", "),n("kbd",[e._v("abs")]),e._v(" and "),n("kbd",[e._v("sign")]),e._v(" for integer\n    operands is given by the following rules. Since characters are just small positive\n    integers, the operators can also be applied to characters. The last two operators\n    can also be applied to truth values. In what follows, let "),n("code",[e._v("i")]),e._v(", "),n("code",[e._v("j")]),e._v("  and "),n("code",[e._v("k")]),e._v(" be any integers.\n  ")]),n("pre",[e._v("        i  succ   =>   j.               ( j = i+1 )\n          i  pred   =>   j.               ( j = i-1 )\n          i  abs    =>   j.               ( j = abs(i) )\n          i  sign   =>   j.               ( j = sign(i) )\n  ")]),n("p",[e._v("\n    Rewrite rules for the "),n("em",[e._v("binary operator")]),e._v("s\n    "),n("kbd",[e._v("+")]),e._v(", "),n("kbd",[e._v("-")]),e._v(", "),n("kbd",[e._v("*")]),e._v(", "),n("kbd",[e._v("/")]),e._v(", "),n("kbd",[e._v("rem")]),e._v(",\n    "),n("kbd",[e._v("max")]),e._v(" and "),n("kbd",[e._v("min")]),e._v(" for integers operands are as follows.\n  ")]),n("pre",[e._v("        i  j  +     =>   k.             ( k = i+j )\n          i  j  -     =>   k.             ( k = i-j )\n          i  j  *     =>   k.             ( k = i*j )\n          i  j  /     =>   k.             ( k = i/j )\n          i  j  rem   =>   k.             ( k = i mod j )\n          i  j  max   =>   k.             ( k = max(i,j) )\n          i  j  min   =>   k.             ( k = min(i,j) )\n  ")]),e._v("\n  Again these binary operators can be applied to characters as well as integers.\n  In the mixed case the type of the result "),n("code",[e._v("k")]),e._v(" is the same as the type of\n  the second parameter "),n("code",[e._v("i")]),e._v(".\n  "),n("p",[e._v("\n    Most implementations of Joy will also provide many other arithmetical operations.\n    Since these will be defined in a library, no reduction rules should be given here.\n  ")]),n("p",[e._v("\n    The type of truth values is one of the Boolean types. The "),n("em",[e._v("binary operator")]),e._v("s\n    are "),n("kbd",[e._v("and")]),e._v(", "),n("kbd",[e._v("or")]),e._v(" and "),n("kbd",[e._v("xor")]),e._v(" (exclusive or). The "),n("em",[e._v("unary operator")]),e._v("  is "),n("kbd",[e._v("not")]),e._v(". Let "),n("code",[e._v("p")]),e._v(" and "),n("code",[e._v("q")]),e._v(" be truth values\n    "),n("code",[e._v("true")]),e._v(" or "),n("code",[e._v("false")]),e._v(".\n  ")]),n("pre",[e._v("        p  q  and   =>   r.             ( r = p and q )\n          p  q  or.   =>   r              ( r = p or  q )\n          p  q  xor.  =>   r              ( r = p xor q )\n          p  not      =>   r.             ( r = not p )\n  ")]),n("p",[e._v("\n    A "),n("em",[e._v("predicate")]),e._v(" is a function which leaves a truth value on the stack. The\n    "),n("em",[e._v("unary predicate")]),e._v("s\n    "),n("kbd",[e._v("null")]),e._v(", "),n("kbd",[e._v("small")]),e._v(", "),n("kbd",[e._v("odd")]),e._v(", "),n("kbd",[e._v("even")]),e._v(", "),n("kbd",[e._v("positive")]),e._v("  and "),n("kbd",[e._v("negative")]),e._v(" are defined for all numeric types:\n  ")]),n("pre",[e._v("        i  null       =>   p.           ( p = (i=0) )\n          i  small      =>   p.          ( p = (i<2) )\n          i  odd        =>   p.           ( p = odd(i) )\n          i  even       =>   p.           ( p = even(i) )\n          i  positive   =>   p.           ( p = positive(i) )\n          i  negative   =>   p.           ( p = negative(i) )\n  ")]),n("p",[e._v("\n    The "),n("em",[e._v("binary predicate")]),e._v("s\n    "),n("kbd",[e._v("=")]),e._v(", "),n("kbd",[e._v("!=")]),e._v(", "),n("kbd",[e._v("<")]),e._v(", "),n("kbd",[e._v("<=")]),e._v(", "),n("kbd",[e._v(">")]),e._v("  and "),n("kbd",[e._v(">=")]),e._v(" have the obvious rewrite rules:\n  ")]),n("pre",[e._v("        i  j  =    =>   p.              ( p = (i = j) )\n          i  j  !=   =>   p.              ( p = not(i = j) )\n          i  j  <    =>   p.              ( p = (i < j) )\n          i  j  <=   =>   p.              ( p = (i <= j) )\n          i  j  >    =>   p.              ( p = (i > j) )\n          i  j  >=   =>   p.              ( p = (i >= j) )\n  ")]),n("p",[e._v("\n    The remainder of this section deals with "),n("em",[e._v("aggregate type")]),e._v("s: sets, strings\n    and quotations, with lists as a special case. The "),n("em",[e._v("unary operator")]),e._v("s\n    "),n("kbd",[e._v("first")]),e._v(", "),n("kbd",[e._v("second")]),e._v(", "),n("kbd",[e._v("third")]),e._v(" and "),n("kbd",[e._v("rest")]),e._v(" expect\n    a non-empty aggregate on top of the stack. The following are the rules for list\n    aggregates:\n  ")]),n("pre",[e._v("        [a L]      first    =>   a.\n          [a b L]    second   =>   b.\n          [a b c L]  third    =>   c.\n          [a L]      rest     =>   [L].\n  ")]),n("p",[e._v("\n    Here "),n("code",[e._v("[a L]")]),e._v(" is a non-empty list or quotation whose first member is\n    "),n("code",[e._v("a")]),e._v(" and whose rest is "),n("code",[e._v("[L]")]),e._v(". For strings an analogous notation\n    can be used to obtain analogous rules. For example\n  ")]),n("pre",[e._v('        "cS"  first   =>   \'c.\n          "cS"  rest    =>   "S".\n  ')]),e._v('\n  Here "cS" denotes a non-empty string whose first character is '),n("code",[e._v("'c")]),e._v("and whose remaining characters are the string "),n("code",[e._v('"S"')]),e._v(".\n  "),n("p",[e._v("\n    For sets the rules are entirely analogous, except that the numeric ordering of the\n    members is used. One possible notation is the following:\n  ")]),n("pre",[e._v("        {a S}  first   =>   a.\n          {a S}  rest    =>   {S}.\n  ")]),e._v("\n  Here "),n("code",[e._v("{a S}")]),e._v(" denotes a non-empty set whose smallest member is "),n("code",[e._v("a")]),e._v("and whose other members are those of "),n("code",[e._v("{S}")]),e._v(".\n  "),n("p",[e._v("\n    The "),n("em",[e._v("binary operator")]),e._v("s "),n("kbd",[e._v("cons")]),e._v(" and "),n("kbd",[e._v("swons")]),e._v(" expect an aggregate\n    and a potential member on top of the stack. These are the rules for list aggregates:\n  ")]),n("pre",[e._v("        a  [L]  cons    =>   [a L].\n          [L]  a  swons   =>   [a L].\n  ")]),e._v("\n  The rules for strings and sets are analogous.\n  "),n("p",[e._v("\n    The "),n("em",[e._v("unary operator")]),e._v("s "),n("kbd",[e._v("uncons")]),e._v(" and "),n("kbd",[e._v("unswons")]),e._v(" also expect\n    a non-empty aggregate. The rules for list aggregates are:\n  ")]),n("pre",[e._v("        [a L]  uncons    =>   a  [L].\n          [a L]  unswons   =>   [L]  a.\n  ")]),e._v("\n  So for strings and sets some of the rules are\n  "),n("pre",[e._v('        \'c "S"  cons   =>   "cS".\n          {S} a  swons   =>   {a S}.\n          {a S} uncons   =>   a  {S}.\n  ')]),n("p",[e._v("\n    The two "),n("em",[e._v("binary operator")]),e._v("s "),n("kbd",[e._v("at")]),e._v(" and "),n("kbd",[e._v("of")]),e._v(" are for "),n("em",[e._v("index")]),e._v("ing\n    into aggregates. For list the rules might be written:\n  ")]),n("pre",[e._v("        [l1 l2 ... li ... ln]  i  at   =>   li.\n          i  [l1 l2 ... li ... ln]  of   =>   li.\n  ")]),e._v("\n  So the two operators are converses of each other. For both operators in the\n  case of sequences the sequence ordering is used, and for sets the underlying ordering\n  is used. But the notation with the dots "),n("code",[e._v("...")]),e._v(" is not satisfactory. Here\n  is a better version for "),n("code",[e._v("at")]),e._v(" applied to lists:\n  "),n("pre",[e._v("        [a L]  1  at   =>   a.\n          [a L]  n  at   =>   b   :-   [L]  (n-1)  at  =>  b.\n  ")]),e._v("\n  And here is a version for "),n("code",[e._v("of")]),e._v(" applied to sets:\n  "),n("pre",[e._v("        1  {a S}  of   =>   a.\n          n  {a S}  of   =>   b   :-   (n-1)  {S}  of  =>  b.\n  ")]),n("p",[e._v("\n    The unary operator "),n("kbd",[e._v("size")]),e._v(" takes an aggregate and determines the number\n    of elements:\n  ")]),n("pre",[e._v("           []  size  =>   0.\n          [a L]  size  =>  (n+1)   :-   L  size   =>   n.\n  ")]),n("p",[e._v("\n    The unary operator "),n("kbd",[e._v("reverse")]),e._v(" can be applied to any aggregate but it is\n    useful only for sequences:\n  ")]),n("pre",[e._v("           []  reverse  =>  [].\n          [a L]  reverse  =>  [M a]   :-   L reverse  =>  M.\n  ")]),e._v("\n  These rules for "),n("code",[e._v("reverse")]),e._v(" are correct but inefficient since appending\n  to the right to produce "),n("code",[e._v("[M a]")]),e._v(" requires copying --- at least for the\n  obvious implementation of lists. Most implementations would use an "),n("em",[e._v("accumulating parameter")]),e._v("to optimise the "),n("code",[e._v("reverse")]),e._v(" operator. It is of some interest that this optimisation\n  can be expressed in rewrite rules:\n  "),n("pre",[e._v("        reverse   =>   []  swap  shunt.\n          [L]  []  shunt   =>   [L].\n          [L]  [a M]  shunt   =>   [a L]  [M]  shunt.\n  ")]),n("p",[e._v("\n    The binary operator "),n("kbd",[e._v("concat")]),e._v(" can be applied to two sequences which are\n    either both lists or both strings.\n  ")]),n("pre",[e._v("    []    [L]  concat  =>  [L].\n      [a L] [M]  concat  =>  [a N]   :-  [L] [M]  concat  =>  [N].\n  ")]),n("p",[e._v("\n    The operators "),n("kbd",[e._v("and")]),e._v(", "),n("kbd",[e._v("or")]),e._v(", "),n("kbd",[e._v("xor")]),e._v(" and "),n("kbd",[e._v("not")]),e._v("  can be applied not only to truth values but also to values of the "),n("em",[e._v("set type")]),e._v(".\n    The reduction rules look exactly as for the truth values, except that the operations\n    have to be performed bitwise. So they compute the "),n("em",[e._v("intersection")]),e._v(", "),n("em",[e._v("union")]),e._v(",\n    "),n("em",[e._v("symmetric difference")]),e._v(" and "),n("em",[e._v("complement")]),e._v(" with respect to the largest\n    set.\n  ")]),n("p",[e._v("\n    The two "),n("em",[e._v("unary predicate")]),e._v("s "),n("kbd",[e._v("null")]),e._v(" and "),n("kbd",[e._v("small")]),e._v(" can also\n    be applied to aggregates. These are the rules for lists, those for strings and\n    sets are analogous.\n  ")]),n("pre",[e._v("        []       null    =>   true.\n          [a L]    null    =>   false.\n          []       small   =>   true.\n          [a]      small   =>   true.\n          [a b L]  small   =>   false.\n  ")]),n("p",[e._v("\n    The two binary predicates "),n("kbd",[e._v("in")]),e._v(" and "),n("kbd",[e._v("has")]),e._v(" test aggregates for\n    members.\n  ")]),n("pre",[e._v("        a  []  in   =>   false.\n          a  [a L]  in   =>   true.\n          a  [b L]  in   =>   a  [L]  in\n  ")]),e._v("\n  The "),n("kbd",[e._v("has")]),e._v(" predicate is just the converse:\n  "),n("pre",[e._v("        []     a  has   =>   false.\n          [a L]  a  has   =>   true.\n          [b L]  a  has   =>   [L]  a  has.\n  ")]),n("p",[e._v("\n    Most implementations of Joy will provide an operator for "),n("kbd",[e._v("sort")]),e._v("ing a sequence\n    and a binary operator "),n("kbd",[e._v("merge")]),e._v(" for combining two already sorted sequences.\n    Since these will be implemented in a library, no reduction rules are given here.\n    The same applies to many other operators for aggregates. %\n  ")]),n("p",[e._v("\n    Sometimes it is necessary to test a parameter for its type. The "),n("em",[e._v("unary predicate")]),e._v("s\n    "),n("kbd",[e._v("logical")]),e._v(", "),n("kbd",[e._v("char")]),e._v(", "),n("kbd",[e._v("integer")]),e._v(",\n    "),n("kbd",[e._v("set")]),e._v(", "),n("kbd",[e._v("string")]),e._v(" and "),n("kbd",[e._v("list")]),e._v(" are true if the parameter\n    is a truth value, character, integer, set, string or list, respectively. The predicate\n    "),n("kbd",[e._v("leaf")]),e._v(" is true if the parameter is not a list.\n  ")]),n("pre",[e._v("        false       logical  =>   true.\n          123         logical  =>   false.\n          123         integer  =>   true.\n          ['A 'B 'C]  leaf     =>   false.\n  ")]),n("p",[e._v("\n    There is another operator for multi-choices. It expects a non-empty list of non-empty\n    lists on top of the stack and below that one further item. The "),n("kbd",[e._v("opcase")]),e._v("  operator matches the type of the item with the "),n("code",[e._v("first")]),e._v(" members of the\n    lists. When a match is found, the "),n("code",[e._v("rest")]),e._v(" of that list is pushed onto\n    the stack. If no match is found, then the last list is used as the default.\n  ")]),n("pre",[e._v('        123      [ [0 P] [\'a Q] ["" R] ... ]  opcase   =>   123     [P].\n          \'c       [ [0 P] [\'a Q] ["" R] ... ]  opcase   =>   \'c      [Q].\n          "Hello"  [ [0 P] [\'a Q] ["" R] ... ]  opcase   =>   "Hello" [R].\n  ')]),n("h1",[e._v("Rules for combinators")]),n("p",[e._v("\n    The simplest "),n("em",[e._v("unary combinator")]),e._v("s are "),n("kbd",[e._v("i")]),e._v(" and "),n("kbd",[e._v("x")]),e._v(", they\n    require the top of the stack to be "),n("em",[e._v(" one")]),e._v(" quotation. Let "),n("code",[e._v("P")]),e._v("  be any program.\n  ")]),n("pre",[e._v("        [P]  i   =>   P.\n          [P]  x   =>   [P]  P.\n  ")]),n("p",[e._v("\n    The next unary combinators, "),n("kbd",[e._v("dip")]),e._v(", "),n("kbd",[e._v("dip2")]),e._v(" and "),n("kbd",[e._v("dip3")]),e._v(",\n    allow manipulation of the stack below the top few elements. Let "),n("code",[e._v("P")]),e._v("  be any program, let "),n("code",[e._v("a")]),e._v(", "),n("code",[e._v("b")]),e._v(" and "),n("code",[e._v("c")]),e._v(" be any literals\n    or equivalent.\n  ")]),n("pre",[e._v("        a        [P]  dip   =>   P  a.\n          a  b     [P]  dip2  =>   P  a  b.\n          a  b  c  [P]  dip3  =>   P  a  b  c.\n  ")]),n("p",[e._v("\n    Another unary combinator is "),n("kbd",[e._v("nullary")]),e._v(". Its rewrite rule has to be expressed\n    conditionally. Let "),n("code",[e._v("L")]),e._v(", "),n("code",[e._v("M")]),e._v(" and "),n("code",[e._v("P")]),e._v(" be any programs.\n  ")]),n("pre",[e._v("        L  [P]  nullary   =>   L  a    :-   L  P   =>   M  a.\n  ")]),e._v("\n  Three similar unary combinators are\n  "),n("kbd",[e._v("unary")]),e._v(", "),n("kbd",[e._v("binary")]),e._v(" and "),n("kbd",[e._v("ternary")]),e._v(":\n  "),n("pre",[e._v("        L b     [P] unary    =>  L a   :-  L b     P  =>  M a.\n          L b c   [P] binary   =>  L a   :-  L b c   P  =>  M a.\n          L b c d [P] ternary  =>  L a   :-  L b c d P  =>  M a.\n  ")]),n("p",[e._v("\n    Three further unary combinators are\n    "),n("kbd",[e._v("app1")]),e._v(", "),n("kbd",[e._v("app2")]),e._v(" and "),n("kbd",[e._v("app3")]),e._v(". Let "),n("code",[e._v("a")]),e._v(", "),n("code",[e._v("a'")]),e._v(",\n    "),n("code",[e._v("b")]),e._v(", "),n("code",[e._v("b'")]),e._v(", "),n("code",[e._v("c")]),e._v(" and "),n("code",[e._v("c'")]),e._v(" be any literals\n    or equivalent. Note that the primed versions are used as the result of applying\n    "),n("code",[e._v("P")]),e._v(" to the unprimed versions.\n  ")]),n("pre",[e._v("        L  a  [P]  app1   =>   L  a'   :-\n              L a P  =>  M  a'.\n          L  a  b  [P]  app2   =>   L  a'  b'   :-\n              L a P  =>  M a',   L b P  =>  N b'\n          L  a  b  c  [P]  app3   =>   L  a'  b'  c'   :-\n              L a P  =>  M a',   L b P  =>  N b',  L c P  =>  O c'.\n  ")]),e._v("\n  There is even an "),n("kbd",[e._v("app4")]),e._v(" combinator which applies "),n("code",[e._v("[P]")]),e._v("to four parameters "),n("code",[e._v("a")]),e._v(", "),n("code",[e._v("b")]),e._v(", "),n("code",[e._v("c")]),e._v(" and "),n("code",[e._v("d")]),e._v(".\n  "),n("p",[e._v("\n    The "),n("em",[e._v("binary combinator")]),e._v("s expect two quotations on top of the stack. The\n    "),n("kbd",[e._v("b")]),e._v(" combinator expects two quotations "),n("code",[e._v("[P]")]),e._v(" and "),n("code",[e._v("[Q]")]),e._v(",\n    with "),n("code",[e._v("[Q]")]),e._v(" on top.\n  ")]),n("pre",[e._v("        [P]  [Q]  b   =>   P  Q.\n  ")]),e._v("\n  The "),n("kbd",[e._v("cleave")]),e._v(" combinator also expects two quotations, and below that\n  an item "),n("code",[e._v("a")]),e._v(".\n  "),n("pre",[e._v("        L a [P] [Q] cleave  =>  L b c   :-   L a P  =>  M b, L a Q  =>  N c.\n  ")]),n("p",[e._v("\n    The "),n("em",[e._v("ternary combinator")]),e._v("s expect three quotations on top of the stack. One\n    of the most important is "),n("kbd",[e._v("ifte")]),e._v(" which performs branching. Its third parameter\n    is the if-part, its second parameter is the then-part, its first parameter, on\n    top, is the else-part.\n  ")]),n("pre",[e._v("        L  [I]  [T]  [E]  ifte   =>   T   :-\n              L  I   =>  M  true.\n          L  [I]  [T]  [E]  ifte   =>   E   :-\n              L  I   =>  M  false.\n  ")]),n("p",[e._v("\n    The binary "),n("kbd",[e._v("whiledo")]),e._v(" combinator is similar to the "),n("code",[e._v("ifte")]),e._v(" combinator\n    in that it has a test, the while-part, which is second on the stack. The combinator\n    repeatedly executes the while-part and while that yields "),n("code",[e._v("true")]),e._v(" it executes\n    the other part, the do-part.\n  ")]),n("pre",[e._v("        L  [W]  [D]  whiledo   =>   L   :-\n              L  W   =>   M  false.\n          L  [W]  [D]  whiledo   =>   L  D  [W]  [D]  whiledo   :-\n              L  W   =>   M  true.\n  ")]),e._v("\n  The ternary "),n("kbd",[e._v("tailrec")]),e._v(" combinator for "),n("em",[e._v("tail recursion")]),e._v(" also\n  has a test, the third parameter. If that yields true, the second parameter is executed\n  and the combinator exits, otherwise the top parameter is executed and after that\n  the process is repeated.\n  "),n("pre",[e._v("        L  [I]  [T]  [R]  tailrec   =>   L  T   :-\n              L  I   =>   M  true.\n          L  [I]  [T]  [R]  tailrec   =>   L  R  [I]  [T]  [R]  tailrec   :-\n              L  I   =>   M  false.\n  ")]),n("p",[e._v("\n    The "),n("em",[e._v("quaternary combinator")]),e._v("s expect four quotations on top of the stack.\n    The "),n("kbd",[e._v("linrec")]),e._v(" combinator for "),n("em",[e._v("linear recursion")]),e._v(" expects an if-part\n    "),n("code",[e._v("[I]")]),e._v(", a then-part "),n("code",[e._v("[T]")]),e._v(", and two recursion parts "),n("code",[e._v("[R1]")]),e._v("  and "),n("code",[e._v("[R2]")]),e._v(".\n  ")]),n("pre",[e._v("    L [I] [T] [R1] [R2] linrec  =>  L  T   :-\n              L  I   =>   M  true.\n      L [I] [T] [R1] [R2] linrec  =>  L R1 [I] [T] [R1] [R2] linrec R2   :-\n              L  I   =>   M  false.\n  ")]),n("p",[e._v("\n    The "),n("kbd",[e._v("binrec")]),e._v(" combinator for "),n("em",[e._v("binary recursion")]),e._v(" is similar, except\n    that the first recursion part has to produce two values. The recursion with all\n    four parts is applied to the two values separately. The second recursion part then\n    has available the two results from these two applications.\n  ")]),n("pre",[e._v("    L [I] [T] [R1] [R2] binrec  =>  L  T   :-\n          L  I   =>   M  true.\n      L [I] [T] [R1] [R2] binrec  => L  a b R2   :-\n          L T   =>   M false,\n          L R1 [I] [T] [R1] [R2] binrec  =>  N  a b.\n  ")]),n("p",[e._v("\n    The "),n("kbd",[e._v("genrec")]),e._v(" combinator for "),n("em",[e._v("general recursion")]),e._v(" is also has an\n    if-part, a then-part and two recursion parts. It differs from the other two combinators\n    in that after the execution of the first recursion part nothing in particular is\n    executed, but a program consisting of the four parts and the combinator is pushed\n    onto the stack. The second recursion part thus has it available as a parameter.\n  ")]),n("pre",[e._v("    L  [I]  [T]  [R1]  [R2]  genrec   =>   L  T   :-\n          L  I   =>   M  true.\n      L  [I]  [T]  [R1]  [R2]  genrec   =>\n              L  R1  [[I] [T] [R1] [R2] genrec]  R2   :-\n          L  I   =>   M  false.\n  ")]),n("p",[e._v("\n    There are several combinators which do not have a fixed number of quotation parameters.\n    Instead they use a list of quotations. The "),n("kbd",[e._v("cond")]),e._v(" combinator is like\n    the one in Lisp, it is a generalisation of the "),n("code",[e._v("ifte")]),e._v(" combinator. It\n    expects a non-empty list of programs, each consisting of a quoted if-part followed\n    by a then-part. The various if-parts are executed until one is found that returns\n    "),n("code",[e._v("true")]),e._v(", and then its corresponding then-part is executed. The last program\n    in the list is the default which is executed if none of the if-parts yield "),n("code",[e._v("true")]),e._v(".\n  ")]),n("pre",[e._v("        L  [ [[I1] T1] REST ]  cond   =>  L  T1   :-\n              L  I1   =>   M  true.\n          L  [ [[I1] T1] REST ]  cond   =>   L [ REST ] cond   :-\n              L  I1   =>   M  false.\n  ")]),n("p",[e._v("\n    The "),n("kbd",[e._v("condlinrec")]),e._v(" combinator is similar, it expects a list of pairs or\n    triples of quoted programs. Pairs consist of an if-part and a then1-part, and triples\n    consist of an if-part, a rec1-part and a rec2-part. Again the first if-part that\n    yields "),n("code",[e._v("true")]),e._v(" selects its corresponding then-part or rec1-part for execution.\n    If there is a rec2-part, the combinator first recurses and then executes the rec2-part.\n    The last program is the default, it does not have an if-part.\n  ")]),n("p",[e._v("\n    The "),n("code",[e._v("cleave")]),e._v(" combinator also has a generalisation, The "),n("kbd",[e._v("construct")]),e._v("  combinator expects two parameters, a quotation and above that a list of quotations.\n    Each quotation in the list will produce a value that will eventually be pushed\n    onto the stack, and the first quotation determines the stack onto which these values\n    will be pushed.\n  ")]),n("pre",[e._v("        L [P] [..[Qi]..] construct =>  L P ..qi..  :-  L Qi  =>  M qi.\n  ")]),n("p",[e._v("\n    Some combinators expect values of specific types below their quotation parameters.\n    The next few combinators expect values of simple types.\n  ")]),n("p",[e._v("\n    The binary combinator "),n("kbd",[e._v("branch")]),e._v(" expects a truth value below its two quotation\n    parameters: The "),n("kbd",[e._v("branch")]),e._v(" combinator resembles the\n    "),n("code",[e._v("choice")]),e._v(" operator and the "),n("code",[e._v("ifte")]),e._v(" combinator. The truth value\n    below the two quotations determines which of the two quotations will be executed.\n    If the truth value is "),n("code",[e._v("true")]),e._v(", then the if-part, the second parameter,\n    is executed, otherwise the then-part, the top parameter, is executed.\n  ")]),n("pre",[e._v("        true   [P]  [Q]  branch   =>   P.\n          false  [P]  [Q]  branch   =>   Q.\n  ")]),n("p",[e._v("\n    The unary combinator "),n("kbd",[e._v("times")]),e._v(" expects a numeric value below its quotation\n    parameter: The "),n("code",[e._v("times")]),e._v(" combinator executes its quotation parameter as\n    many times as indicated by the numeric value; if the value is zero or less, then\n    the quotation is not executed at all.\n  ")]),n("pre",[e._v("        0  [P]  times   =>   id.\n          n  [P]  times   =>   P  (n-1)  [P]  times.\n  ")]),e._v("\n  %\n  "),n("p",[e._v("\n    The stack is normally a list, so any list could serve as the stack, including a list\n    which happens to be on top of the stack. But the stack can also contain operators\n    and combinators, although this does not happen often. So the stack is always a\n    quotation, and any other quotation could serve as the stack, including one on top\n    of the stack. The "),n("kbd",[e._v("infra")]),e._v(" combinator expects a quotation "),n("code",[e._v("[P]")]),e._v("  which will be executed and below that another quotation which normally will be\n    just a list "),n("code",[e._v("[M]")]),e._v(". The "),n("code",[e._v("infra")]),e._v(" combinator temporarily discards\n    the remainder of the stack and takes the quotation or list "),n("code",[e._v("[M]")]),e._v(" to\n    be the stack. It then executes the top quotation "),n("code",[e._v("[P]")]),e._v(" which yields\n    a result stack. This resulting stack is then pushed as a list "),n("code",[e._v("[N]")]),e._v("  onto the original stack replacing the original quotation or list. Hence any quotation\n    can serve as a complex unary operation on other quotations or lists.\n  ")]),n("pre",[e._v("        L  [M]  [P]  infra  =>  L  [N]   :-  [M]  unstack  P  =>  N.\n  ")]),n("p",[e._v("\n    For linear recursion over "),n("em",[e._v("numeric type")]),e._v("s the if-part often is "),n("code",[e._v("[null]")]),e._v("  and the first recursion part is "),n("code",[e._v("[dup pred]")]),e._v(". The "),n("kbd",[e._v("primrec")]),e._v("  combinator has this built in. For integers the rewrite rules are:\n  ")]),n("pre",[e._v("        0  [T]  [R2]  primrec   =>   pop  T.\n          i  [T]  [R2]  primrec   =>   i  dup pred  [T]  [R2]  primrec  R2.\n  ")]),e._v("\n  The "),n("code",[e._v("primrec")]),e._v(" combinator can also be used for aggregates. The implicit\n  if-part is again "),n("code",[e._v("[null]")]),e._v(", and the implicit first recursion part is "),n("code",[e._v("[rest]")]),e._v(".\n  Below is the version for lists, the versions for sets and strings are analogous.\n  "),n("pre",[e._v("        []     [T]  [R2]  primrec   =>   pop  T.\n          [a L]  [T]  [R2]  primrec   =>   a  [L]  [T] [R2] primrec R2.\n  ")]),n("p",[e._v("\n    The unary combinators "),n("kbd",[e._v("step")]),e._v(",\n    "),n("kbd",[e._v("map")]),e._v(", "),n("kbd",[e._v("filter")]),e._v(" and "),n("kbd",[e._v("split")]),e._v(" all expect an aggregate\n    below their quotation parameter.\n  ")]),n("p",[e._v("\n    For "),n("kbd",[e._v("step")]),e._v(" operating on lists the rewrite rule is:\n  ")]),n("pre",[e._v("        []  [P]  step   =>   id.\n          K  [a L]  [P]  step   =>   M  [L]  [P]  step   :-\n              K  a  P   =>   M.\n  ")]),e._v("\n  For strings and sets the rules are analogous. The same is true of the rules\n  to follow. For "),n("kbd",[e._v("map")]),e._v(" operating on lists the rewrite rule is:\n  "),n("pre",[e._v("        []  [P]  map   =>   [].\n          K  [a L]  [P]  map   =>   K  [b M]   :-\n              K  a  P   =>   K  b,   K  [L]  [P]  map   =>   K  M.\n  ")]),e._v("\n  The "),n("kbd",[e._v("filter")]),e._v(" combinator expects a predicate as its quotation parameter.\n  "),n("pre",[e._v("        []  [P]  filter   =>   [].\n          K  [a L]  [P]  filter   =>   K  [a M]   :-\n              K  a  P  =>  J  true,    K  [L]  [P]  filter   =>   K  [M].\n          K  [a L]  [P]  filter   =>   K  [M]   :-\n              K  a  P  =>  J  false,   K  [L]  [P]  filter   =>   K  [M].\n  ")]),e._v("\n  The "),n("kbd",[e._v("split")]),e._v(" combinator is like "),n("code",[e._v("filter")]),e._v(" except that it\n  produces two lists. The first list is just like the one from "),n("code",[e._v("filter")]),e._v(",\n  the second list is the list of those elements which did not pass the predicate test\n  "),n("code",[e._v("[P]")]),e._v(" and hence are not members of the first list.\n  "),n("pre",[e._v("        []  [P]  split   =>   [].\n          K  [a L]  [P]  split   =>   K  [a M]  [N]   :-\n              K  a  P  =>  J  true,   K  [L]  [P]  split  =>  K  [M]  [N].\n          K  [a L]  [P]  split  =>  K  [M]  [a N]   :-\n              K  a  P  =>  J  false,   K  [L]  [P]  split  =>  K  [M]  [N].\n  ")]),n("p",[e._v("\n    The unary combinator "),n("kbd",[e._v("fold")]),e._v(" expects a quotation which computes a binary\n    operation. Below that has to be a literal and below that an aggregate. The literal\n    is used as a start value to fold or reduce the aggregate. Applied to lists the\n    combinator has these rules:\n  ")]),n("pre",[e._v("        []  a  [P]  fold   =>   a.\n          [b L]  a  [P]  fold   =>   d   :-\n              a  b  P   =>   c,\n              [L]  a  [P]  fold  c  P   =>   d.\n  ")]),n("p",[e._v("\n    The two "),n("em",[e._v("unary combinator")]),e._v("s "),n("kbd",[e._v("some")]),e._v(" and "),n("kbd",[e._v("all")]),e._v(" expect an\n    aggregate below their quotation parameter. The quotation must be a predicate, yielding\n    a truth value. The "),n("kbd",[e._v("some")]),e._v(" combinator returns "),n("code",[e._v("true")]),e._v(" if some\n    members of the aggregate pass the test of the quotation, otherwise it returns "),n("code",[e._v("false")]),e._v(".\n    The "),n("kbd",[e._v("all")]),e._v(" combinator returns "),n("code",[e._v("true")]),e._v(" if all members of the aggregate\n    pass the test of the quotation, otherwise it returns "),n("code",[e._v("false")]),e._v(". For empty\n    aggregates "),n("code",[e._v("some")]),e._v(" returns "),n("code",[e._v("false")]),e._v(" and "),n("code",[e._v("all")]),e._v(" returns\n    "),n("code",[e._v("true")]),e._v(". The rules for "),n("code",[e._v("some")]),e._v(" are:\n  ")]),n("pre",[e._v("        []  [P]  some   =>   false.\n          L  [a A]  [P]  some   =>   L  true   :-\n              L  a  P  =>  M  true.\n          L  [a A]  [P]  some   =>   L  [A]  [P]  some   :-\n              L  a  P  =>  M  false.\n  ")]),e._v("\n  The rules for "),n("code",[e._v("all")]),e._v(" are:\n  "),n("pre",[e._v("        []  [P]  all   =>   true.\n          L  [a A]  [P]  all   =>   L  false   :-\n              L  a  P   =>   M  false.\n          L  [a A]  [P]  all   =>   L  [A]  [P]  all   :-\n              L  a  P   =>   M  true.\n  ")]),n("p",[e._v("\n    The unary combinator "),n("kbd",[e._v("zipwith")]),e._v(" expects two aggregates and above that a\n    program suitable for combining their respective elements. For lists the rules are\n  ")]),n("pre",[e._v("        []  [A]  [P]  zipwith   =>   [].\n          [A]  []  [P]  zipwith   =>   [].\n          L  [a A]  [b B]  [P]  zipwith   =>   L  [c C]   :-\n              L  a  b  P   =>   M  c,\n              L  [A]  [B]  [P]  zipwith   =>   L  [C].\n  ")]),e._v("\n  %\n  "),n("h1",[e._v("The role of the stack")]),n("p",[e._v("\n    This section deals with the role of the Joy stack from a syntactic and semantic point\n    of view.\n  ")]),n("p",[e._v("\n    First, let us consider a quite small arithmetic expression in postfix notation:\n  ")]),n("pre",[e._v("        2  3  +  8  5  -  *\n  ")]),e._v("\n  A reduction might begin by doing the addition first, or the subtraction first,\n  followed in a second step by the other operation. In fact, the addition and the subtraction\n  could be done in parallel in the same step. Only when both reductions have been done\n  will it be possible to do the final multiplication. The final result is the value\n  "),n("code",[e._v("20")]),e._v(", and it is independent of the order in which the reductions have\n  been applied. In detail, the first mentioned reduction sequence will look like this:\n  "),n("pre",[e._v("        2  3  +  8  5  -  *\n                5  8  5  -  *\n                5        3  *\n                            15\n  ")]),e._v("\n  One possible "),n("em",[e._v("strategy")]),e._v(" for reductions is the following:\n  "),n("p",[e._v("\n    Scan the expression from left to right until a "),n("em",[e._v("redex")]),e._v(" is found, an expression\n    that can be replaced in accordance with a rewrite rule. Apply the rule. Repeat\n    until no more rules can be applied.\n  ")]),n("p",[e._v("\n    This strategy is most efficient for reducing expressions in which redexes are found\n    early. The following is an example. Again all operators are binary, but note that\n    except at the beginning operators and literals alternate. In each step the first\n    three symbols constitute a redex.\n  ")]),n("pre",[e._v("        10  5  /  3  *  4  -  1  +\n  ")]),e._v("\n  The strategy is least efficient when a redex is found late. In the example\n  below, note that all operators occur towards the end.\n  "),n("pre",[e._v("        3  2  6  8  6  -  /  +  *\n  ")]),e._v("\n  The strategy requires skipping the "),n("code",[e._v("3")]),e._v(", "),n("code",[e._v("2")]),e._v(" and "),n("code",[e._v("6")]),e._v("and only then replacing "),n("code",[e._v("8 6 -")]),e._v(" by "),n("code",[e._v("2")]),e._v(". The next step requires\n  skipping "),n("code",[e._v("3")]),e._v(" and "),n("code",[e._v("2")]),e._v(" and only then replacing "),n("code",[e._v("6 2 /")]),e._v("by "),n("code",[e._v("3")]),e._v(". The next step requires skipping "),n("code",[e._v("3")]),e._v(" and only then replacing\n  "),n("code",[e._v("2 3 +")]),e._v(" by "),n("code",[e._v("5")]),e._v(". The final step requires no skipping,\n  "),n("code",[e._v("3 5 *")]),e._v(" is replaced by "),n("code",[e._v("15")]),e._v(". All this skipping is of course\n  inefficient.\n  "),n("p",[e._v("\n    A better strategy would apply the next operator at the point of the most recent change,\n    if that is possible. An obvious way to do this is to use a "),n("em",[e._v("stack of values")]),e._v("  for intermediate results. As the expression is being processed, operands such as\n    literal numbers are pushed, and operators pop their arguments off the stack and\n    push their result. This is of course the method commonly used for evaluating postfix\n    expressions. So we have the following situation: The rewriting rules for programs\n    are purely syntactic, they do not mention the stack. But the stack can be used\n    as an optimisation of the rewrite rules. On the other hand, the stack is apparently\n    an essential semantic entity, it is the argument and value of the functions denoted\n    by programs.\n  ")]),n("p"),n("p",[e._v("\n    But this now raises the question whether the stack is "),n("em",[e._v(" just")]),e._v(" an optimisation\n    for the rewriting system or whether it is really needed as a semantic object. In\n    other words, is it possible to give a semantic characterisation of Joy which does\n    not involve a stack at all? In such a semantics the programs will have to denote\n    something, and presumably they will have to denote functions. But what might be\n    the arguments and values of these functions?\n  ")]),n("p",[e._v("\n    It will help to review the stack based semantics of Joy: The "),n("em",[e._v("literal")]),e._v("s\n    such as numerals, characters, strings and quotations denote functions taking any\n    stack as argument and producing another stack as value which is like the argument\n    stack except that a single item has been pushed on top. The "),n("em",[e._v("operator")]),e._v("s\n    also denote unary functions from stacks to stacks, and the result stack is like\n    the argument stack except that the top few items have been replaced by the result\n    of applying some operation. Likewise, the "),n("em",[e._v("combinator")]),e._v("s denote unary functions\n    from stacks to stacks, and the result stack depends on the combinator and the top\n    few quotations.\n  ")]),n("p",[e._v("\n    To obtain a Joy semantics without a stack we take our hint from the rewriting rules.\n    The operators and combinators no longer denote functions from stacks to stacks.\n    The rewrite rule for addition transforms a program ending with two numerals into\n    a program ending with a numeral for their sum. This is the key for a semantics\n    without a stack: Joy programs denote unary functions taking one "),n("em",[e._v("program")]),e._v("  as arguments and giving one "),n("em",[e._v("program")]),e._v(" as value. The "),n("em",[e._v("literal")]),e._v("s denote\n    "),n("em",[e._v(" append")]),e._v(" operations; the program returned as value is like the program\n    given as argument, except that it has the literal appended to it. The "),n("em",[e._v("operator")]),e._v("s\n    denote "),n("em",[e._v(" replacement")]),e._v(" operations, the last few items in the argument program\n    have to be replaced by the result of applying the operator. Similarly the "),n("em",[e._v("combinator")]),e._v("s\n    also denote (higher order) functions from programs to programs, the result program\n    depends on the combinator and the last few quotations of the argument program.\n  ")]),n("p",[e._v("\n    It is clear that such a semantics without a stack is possible and that it is merely\n    a rephrasing of the semantics with a stack. Purists would probably prefer a system\n    with such a lean ontology in which there are essentially just programs operating\n    on other programs. But most programmers are so familiar with stacks that it seems\n    more helpful to give a semantics with a stack. Its is of course irrelevant for\n    the semantics that for efficiency reasons any implementation of Joy will in fact\n    use a stack.\n  ")]),n("p",[e._v("\n    There is one other argument for a stack semantics. By a program one would normally\n    mean one that can be run, at least when supplied with appropriate parameters. The\n    stack, however, can sometimes contain sequences of items that make the stack a\n    non-executable program because it violates type rules. Such situations arise for\n    example by executing one of the following:\n  ")]),n("pre",[e._v("        [ 3  * ]   second\n          [ pop  cons  map ]   []  step\n  ")]),e._v("\n  The first results in the one operator "),n("code",[e._v("*")]),e._v(" being pushed. The second\n  results in two operators and one combinator to be pushed. Such situations are required\n  only rarely. But the possibility is needed, for example for a Joy interpreter "),n("kbd",[e._v("joy")]),e._v("written in Joy itself. Such an interpreter is described in another paper.\n  "),n("h1",[e._v("Quotation revisited")]),n("p",[e._v("\n    It was mention in section 3 that for "),n("em",[e._v("quotation")]),e._v("s there is no rewrite rule\n    of the form\n  ")]),n("pre",[e._v("        [P]  ==>  [Q]   :-   P  ==>  Q.\n  ")]),e._v("\n  If there were such a rule, then the rewriting\n  "),n("pre",[e._v("        42  dup   ==>   42  42.\n  ")]),e._v("\n  would license\n  "),n("pre",[e._v("        [ 42  dup ]   ==>   [ 42  42 ].\n  ")]),e._v("\n  and hence\n  "),n("pre",[e._v("        [ 42  dup ]  second   ==>>   [ 42  42 ]  second.\n          dup   ==>>  42.\n  ")]),e._v("\n  which is absurd. On the other hand,\n  "),n("pre",[e._v("        [ 42  dup ]  i  +   ==>   [ 42  42 ]  i  +\n  ")]),e._v("\n  is acceptable. So, quotations must not allow substitutions in all contexts,\n  but only in those where the quotation is guaranteed to be undone by a "),n("em",[e._v("dequoting")]),e._v("operation, by a combinator. In other words, quotation is an "),n("em",[e._v("intensional constructor")]),e._v(".\n  "),n("p",[e._v("\n    There is a simple way out of this, and it is to treat quotations of programs to be\n    very different from lists. Notice that the absurdity comes from taking the "),n("code",[e._v("second")]),e._v("  element of the quotations "),n("code",[e._v("[42 dup]")]),e._v(" and "),n("code",[e._v("[42 42]")]),e._v(". If it\n    were forbidden to treat quoted programs as data structures, then the fatal inference\n    would be blocked. In detail, such a treatment would look like this: If "),n("code",[e._v("P")]),e._v("  is a program, then "),n("code",[e._v("(P)")]),e._v(" is its quotation, now written inside round\n    parentheses. Also, "),n("code",[e._v("[P]")]),e._v(" is its list, as before written inside square\n    brackets. Both "),n("code",[e._v("(P)")]),e._v(" and "),n("code",[e._v("[P]")]),e._v(" can be pushed onto the stack,\n    can be "),n("code",[e._v("swap")]),e._v("ped, "),n("code",[e._v("dup")]),e._v("licated and "),n("code",[e._v("pop")]),e._v("ped, can\n    be inserted into lists and later extracted. But only "),n("code",[e._v("(P)")]),e._v(" can be used\n    as a parameter for combinators, and it cannot treated as a list. On the other hand,\n    "),n("code",[e._v("[P]")]),e._v(" cannot be used as a parameter for combinators, but it can be treated\n    as a list. Importantly, there could then be a reduction rule\n  ")]),n("pre",[e._v("        (P)  ==>  (Q)   :-   P  ==>  Q.\n  ")]),e._v("\n  and hence quotation would be an "),n("em",[e._v("extensional constructor")]),e._v(".\n  "),n("p",[e._v("\n    This is a draconian solution, it allows programs such as\n  ")]),n("pre",[e._v("        [2]  cons  reverse\n  ")]),e._v("\n  but forbids\n  "),n("pre",[e._v("        (+)  cons  map\n  ")]),e._v("\n  The latter uses "),n("code",[e._v("map")]),e._v(" to add a single number on top of the stack\n  to each member of a list that is second on the stack. If the single number on top\n  of the stack is, say "),n("code",[e._v("7")]),e._v(", then the "),n("code",[e._v("cons")]),e._v(" operation produces\n  "),n("code",[e._v("(7 +)")]),e._v(" to be used by "),n("code",[e._v("map")]),e._v(". The prohibition would rule out\n  "),n("em",[e._v("parameterisation")]),e._v(". In general, the prohibition would rule out using "),n("em",[e._v("constructed program")]),e._v("s\n  as parameters to combinators.\n  "),n("p",[e._v("\n    It is possible to make a less drastic compromise: As before, quotations "),n("code",[e._v("(P)")]),e._v("  serve as parameters to combinators, but they can also be built up by list operations\n    such as "),n("code",[e._v("concat")]),e._v("enation or "),n("code",[e._v("cons")]),e._v("ing further items into their\n    front. This would allow parameterisation as in the "),n("code",[e._v("map")]),e._v(" example above.\n    Quotations could be constructed and built up further and further and eventually\n    called by a combinator, but quotations could not be destructed. On this proposal\n    constructive operations on quotations would be allowed, but destructive operations\n    would not. All list operations would need to be classified as constructive or destructive.\n    Even the "),n("code",[e._v("size")]),e._v(" operator would turn out to be destructive.\n  ")]),n("p",[e._v("\n    This compromise solution has much in its favour. Quotation is extensional, combinators\n    can use constructed programs, but the absurdity does not arise. On the other hand,\n    the compromise requires a syntactic distinction between quotations and lists, and\n    it requires a semantic distinction between operations that can be applied to lists\n    and to quotations, and those that can be applied only to lists.\n  ")]),n("p",[e._v("\n    On the whole, then, it does seem preferable to have quotation as an intensional constructor.\n  ")]),n("h1",[e._v("Rewriting for Joy types")]),n("p",[e._v("\n    The rewriting system described up to here concerned values. It is also possible to\n    give a rewriting system for Joy "),n("em",[e._v("type expression")]),e._v("s. We shall need constant\n    and variable symbols for these types. The following will be used as "),n("em",[e._v("type constant")]),e._v("s:\n    "),n("code",[e._v("Log")]),e._v(" for the truth values,\n    "),n("code",[e._v("Chr")]),e._v(" for the characters,\n    "),n("code",[e._v("Int")]),e._v(" for the integers,\n    "),n("code",[e._v("Set")]),e._v(" for the sets,\n    "),n("code",[e._v("Str")]),e._v(" for the strings and\n    "),n("code",[e._v("Lst")]),e._v(" for possibly heterogeneous lists. For lists whose member are all\n    of the same type, say "),n("code",[e._v("Int")]),e._v(", the notation "),n("code",[e._v("[Int]")]),e._v(" will be\n    used. As variables we use\n    "),n("code",[e._v("T")]),e._v(", "),n("code",[e._v("T1")]),e._v(", "),n("code",[e._v("T2")]),e._v(" and so on. So "),n("code",[e._v("[T]")]),e._v("  is the type of lists whose members are all of the type "),n("code",[e._v("T")]),e._v(".\n  ")]),n("p",[e._v("\n    The following is a sample of one style of rules for operators:\n  ")]),n("pre",[e._v("        T1   T2  swap   =>   T2  T1.\n          Int  Int  +     =>   Int.\n          Str      size   =>   Int.\n  ")]),e._v("\n  The notation used above has been made as close as possible to the notation\n  for the rewriting rules for values. In the following a different notation will be\n  introduced which is more useful.\n  "),n("p",[e._v("\n    Literals have "),n("em",[e._v("atomic type")]),e._v("s, operators and combinators have "),n("em",[e._v("compound type")]),e._v("s.\n    There are three constructors for compound types:\n    "),n("em",[e._v("type concatenation")]),e._v(", "),n("em",[e._v("type quotation")]),e._v(" and "),n("em",[e._v("type cancellation")]),e._v(".\n    The first two are derived from the corresponding program constructors. The third\n    is new and has no counterpart program constructor. It uses the infix symbol "),n("kbd",[e._v("->")]),e._v("  to combine two types into a new one. If "),n("code",[e._v(" T ")]),e._v(" is a type, then so is\n    its quotation "),n("code",[e._v(" [T] ")]),e._v(". If "),n("code",[e._v(" T1 ")]),e._v(" and "),n("code",[e._v(" T2 ")]),e._v(" are\n    types, then so are their concatenation\n    "),n("code",[e._v(" (T1 T2) ")]),e._v(" and their cancellation "),n("code",[e._v(" T1->T2 ")]),e._v(". If "),n("code",[e._v(" P1 ")]),e._v("  and "),n("code",[e._v(" P2 ")]),e._v(" are programs of types\n    "),n("code",[e._v(" T1 ")]),e._v(" and "),n("code",[e._v(" T2 ")]),e._v(", then the type of their concatenation "),n("code",[e._v(" (P1 P2) ")]),e._v("  is the concatenation "),n("code",[e._v(" (T1 T2) ")]),e._v(" of their types. Cancellation satisfies\n    the law\n  ")]),n("pre",[e._v("                T1  T1->T2   =>   T2\n  ")]),e._v("\n  For types with concatenated parameter types:\n  "),n("pre",[e._v("                (T1 T2)->T3   =>   T1->(T2->T3)\n  ")]),e._v("\n  The expression on the right of the arrow can be written without parentheses\n  on the convention that the cancellation operator "),n("code",[e._v("\\")]),e._v(" is taken to be right\n  associative.\n  "),n("p",[e._v("\n    The three rules given above should now be rewritten in this style:\n  ")]),n("pre",[e._v("        swap   =>     (T1 T2) -> (T2 T1).\n          +      =>   (Int Int) -> Int.\n          size   =>         Str -> Int.\n  ")]),n("p",[e._v("\n    The following are a sample of further rules in the two styles: Those in the left\n    column are in the earlier style, those in the right are in the new style.\n  ")]),n("pre",[e._v("        Chr      succ    =>  Chr.       succ    =>  Chr->Chr.\n          Int  Int  >      =>  Log.       >       =>  (Int Int)->Log.\n          Log  Log  and    =>  Log.       and     =>  (Log Log)->Log.\n          [T Lst]  first   =>  T.         first   =>  [T Lst]->T.\n          [T Lst]  rest    =>  Lst.       rest    =>  [T Lst]->Lst.\n          T  Lst   cons    =>  [T Lst].   cons    =>  (T Lst)->[T Lst].\n          [T Lst]  uncons  =>  T Lst.     uncons  =>  [T Lst]->(T Lst).\n          Chr Str  cons    =>  Str.       cons    =>  (Chr Str)->Str.\n          Set      null    =>  Log.       null    =>  Set->Log.\n  ")]),e._v("\n  Consider now the program "),n("code",[e._v(" P ")]),e._v(" below. Its type is given by the\n  concatenation of the types of its parts, in the line just below. All the types here\n  are built from the atomic type "),n("code",[e._v("  Int  ")]),e._v(" of integers. By four applications\n  of cancellation the type in line 1 is simplified to the type "),n("code",[e._v(" Int ")]),e._v(" in\n  line 4.\n  "),n("pre",[e._v("P:    2      3      +                dup              *\n  1.    Int    Int    (Int Int)->Int   Int->(Int Int)   (Int Int)->Int\n  2.                  Int              Int->(Int Int)   (Int Int)->Int\n  3.                                   (Int Int)        (Int Int)->Int\n  4.                                                    Int\n  ")]),n("p",[e._v("\n    For combinators only only a few examples will be given here, for "),n("kbd",[e._v("i")]),e._v(" and\n    "),n("kbd",[e._v("map")]),e._v(".\n  ")]),n("pre",[e._v("        i   =>   [T] -> T.\n          map   =>   ([T1 -> T2]) -> ([T1] -> [T2]).\n  ")]),n("p",[e._v("\n    The formalism used in this section is that of "),n("em",[e._v("categorial grammar")]),e._v("s. These\n    have their origin in the (simple) theory of types and as generating devices are\n    as powerful as context free grammars. Expositions and applications are to be found\n    in the volume edited by \\AX{Oehrle {\\it et al}}{1988}{Oehrle-etal:88}, see in particular\n    the contributions by \\X{Casadio} and \\X{Lambek}. Another reference is the volume\n    edited by \\AX{Buskzkowski {\\it et al}}{1988}{Buszkowski-etal:88}.\n  ")]),n("p",[e._v("\n    Rewriting systems are purely syntactic. If the object language has a semantics, then\n    the rewriting rules have to be shown to be correct with reepsect to this semantics.\n    This is true of the rewriting rules of the previous sections which dealt with values.\n    It is also true for the rewriting rules for types. The basic semantic notion here\n    is that of assigning types to programs. These take the form\n  ")]),n("pre",[e._v("        P   :   T\n  ")]),e._v("\n  which is "),n("em",[e._v(" not")]),e._v(" a rewriting rule but a "),n("em",[e._v(" statement")]),e._v(" which says\n  that program "),n("code",[e._v("P")]),e._v(" is of type "),n("code",[e._v("T")]),e._v(". The basic type statements\n  are to atomic programs, literals, operators and combinators. Here are some examples:\n  "),n("pre",[e._v("        42    :  Int                'A  :  Chr\n          succ  :  Chr -> Chr         >   :  Int Int -> Log\n          first :  [T Lst] -> T       i   :  [T] -> T\n  ")]),e._v("\n  This is the style adopted in the Joy manual. To obtain rewrite rules using\n  "),n("kbd",[e._v("=>")]),e._v(" a single conditional rule is needed which converts the semantic\n  predicate "),n("kbd",[e._v(":")]),e._v(" into the syntactic "),n("code",[e._v("=>")]),e._v(", as follows.\n  "),n("pre",[e._v("        X => T   :-   X : T.\n  ")]),n("p",[e._v("\n    The material in this section has very tentative, most of the details need to be worked\n    out fully.\n  ")])])}]};t.a=o}});