webpackJsonp([5],{"5+aw":function(e,t,n){var a=n("NlN7");"string"==typeof a&&(a=[[e.i,a,""]]),a.locals&&(e.exports=a.locals);n("rjj0")("2cd3ee5d",a,!1,{sourceMap:!1})},NlN7:function(e,t,n){(e.exports=n("FZ+f")(!1)).push([e.i,"p[data-v-f740c3da]{margin-top:16px;margin-bottom:16px}hr[data-v-f740c3da]{margin-bottom:16px}pre[data-v-f740c3da]{margin-bottom:auto}code[data-v-f740c3da],kbd[data-v-f740c3da],pre[data-v-f740c3da]{font-family:Roboto Mono,monospace}",""])},THzk:function(e,t,n){"use strict";var a=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("article",[n("p",[e._v("\n    14-FEB-05\n  ")]),e._m(0),n("p",[e._v('\n    An equation of the form a * x^2 + b * x + c = 0 has either no solution in the reals,\n    or it has two solutions in the reals ("not necessarily distinct" as they say).\n    The solutions, if any, are given by\n  ')]),n("pre",[e._v("             -b  +/- sqrt(b^2 - 4 * a * c)\n               -----------------------------\n                          2 * a\n  ")]),e._v("\n  R. Kent Dybvig, The SCHEME Programming Languagage, 1987, p 44, gives the following\n  definition\n  "),n("pre",[e._v("        (define quadratic-formula\n             (lambda (a b c)\n                (let ([minusb (0 - b)]\n                      [radical (sqrt (- (* b b) (* 4 ( * a c))))]\n                      [divisor (* 2 a)] )\n                   let ([root1 (/ (+ minusb radical) divisor)]\n                        [root2 (/ (- minusb radical) divisor)])\n                     (cons root1 root2)))))\n  ")]),e._v("\n  For a = 2, b = -4, c = -6 the solutions are x = 3 and x = -1, and the programs\n  gives the solutions in the form of a (dotted) pair:\n  "),n("pre",[e._v("         (quadratic-formula 2 -4 -6)  =>  (3 . -1)\n  ")]),e._v("\n  Dybvig remarks (p 45):\n  "),n("pre",[e._v('      ".. by employing two let expressions, the definition makes\n         clear the dependency of root1 and root2 on the values of\n         minusb, radical, and divisor. Equally important, the let\n         expressions make clear the lack of dependencies among minusb, \n         radical, and divisor and between root1 and root2."      \n  ')]),e._v("\n  The remainder of this note is concerned with writing a program in Joy which\n  does the same thing, using the Scheme program as a model. The general plan is to\n  develop some constructions in Joy which can play the same role as the let-expressions\n  in Scheme (or other languages).\n  "),n("p",[e._v("\n    The simplest let-expressions are those in which only a single expression is evaluated\n    and given a name, which is then available in the body:\n  ")]),n("pre",[e._v("        (let ([name expression])\n               ( body ))                      \n  ")]),e._v("\n  In Joy there is no name to be given to the value of the expression, but the\n  value of the expression can be pushed on top of the stack by the nullary combinator:\n  "),n("pre",[e._v("        [expression] nullary  body\n  ")]),e._v("\n  The nullary combinator executes the quotation on top on the remainder of the\n  stack, possibly consuming several values, and then restores that remainder and pushes\n  whatever top value the execution of the quotation had produced.\n  "),n("p",[e._v("\n    But this is of no use for multiple let-expressions in which there are several names\n    to be defined independently, as in the first half of the Scheme program in which\n    three names are defined, or in the second half in which two are defined.\n  ")]),n("p",[e._v("\n    The effect of multiple let-expressions can be simulated in Joy by a simple but very\n    useful device. The aim is to compute several values independently which are to\n    be used later. In Joy these values are anomymous. The general pattern is\n  ")]),n("pre",[e._v("        [[..] [..] [..]]  [i]  map\n  ")]),e._v("\n  This is perhaps a surprising use of the map combinator. In all cases the map\n  combinator expects on top of the stack a single quotation and in most cases below\n  that a list or other aggregate of values. But map can also handle the case where\n  that list is a list of quotations to be executed. If the single quotation is [i],\n  the the quoted i combinator will execute each of the three listed quotations and\n  the map combinator assembles these into a list of the three values that were on top\n  of the stack at the end of the three executions. Note that the three result values\n  are computed independently of each other, and each of the three computations can\n  modify the stack in any way, and after each of the three computations the original\n  stack below the list of three quotations is restored. It is these three properties\n  that make the device useful for structuring Joy programs.\n  "),n("p",[e._v("\n    In many cases the three values that have been computed from the three quotations\n    are required not as a single list on top of the stack but as three independent\n    values. Of course it is easy enough to decompose the list, in the present case\n    by\n  ")]),n("pre",[e._v("        uncons  uncons  uncons  pop\n  ")]),e._v("\n  This will work even in the rare case where the result list contains operators,\n  as in [2 + 3]. But the sequence of uncons'es is clumsy, especially if the list is\n  long. It would be preferable to use some code which decomposes the list independently\n  of its length. One device is the step combinator, which expects a quotations and\n  below that a list or other aggregate. It successively puts the elements of the list\n  onto the stack and executes the quotation. The top value after each of the executions\n  is pushed onto the stack. In the present case the required quotation [], which does\n  nothing. So, for example,\n  "),n("pre",[e._v("    1 2 3 [[pop dup *] [+] [2 *]]  [i] map  [] step\n  ")]),e._v("\n  will leave 1 2 3 4 5 6 on top of the stack, the 6 topmost, after producing\n  the list [4 5 6] just after the map.\n  "),n("p",[e._v("\n    Applying these constructions mechanically to the nested multiple let-expressions\n    in the Scheme program results in the following definition in Joy:\n  ")]),n("pre",[e._v("DEFINE\n      quadratic-1  ==                                # a b c => [root1 root2 ]\n          [ [ pop pop 2 * ]                          # divisor\n            [ pop 0 swap - ]                         # minusb\n            [ swap dup * rollup * 4 * - sqrt ] ]     # radical\n          [i] map [] step\n          [ [ + swap / ]                             # root1\n            [ - swap / ] ]                           # root2\n          [i] map  [] step\n          [] cons cons                               # build pair\n          [ pop pop pop pop pop pop ] dip.           # cleanup stack\n  ")]),n("p",[e._v("\n    But the program is unsatisfactory for a number of reasons:\n  ")]),n("p",[e._v("\n    1. Most glaringly, in line 7 the list of two roots is decomposed by [] step. But\n    then in line 8 the two roots are recomposed to a list. So, the final [] step in\n    line 7, and all of line 8 should be deleted.\n  ")]),n("p",[e._v("\n    2. In line 4 the list of three intermediate values is also decomposed by [] step.\n    Just like a sequence of uncons operations, this will work even in the rare case\n    where the list contains operators, as in [2 + swap]. But in the case of the quadratic\n    formula the list of intermediate values is just a normal list of literals, namely\n    numbers. Because of that it is possible to decompose the list by just the i combinator,\n    which will do the same job simpler and also more efficiently.\n  ")]),n("p",[e._v("\n    3. In line 9 the six pops remove the three parameters (a b c) and the three inttermeddiate\n    values (divisor minusb radical). A language such as Scheme need not (and cannot)\n    explicitly express the disappearancce of these values. But the three parameters\n    are no longer needed in the computation of the two roots from the three intermediate\n    values. And yet, during that computation the three parameters are still visible.\n    But is only by inspecting the code for the computations that it becomes apparent\n    that the parameters are not used directly. In Scheme the independence is not (and\n    cannot be) expressed explicitly. But it can be expressed in Joy. The three (dipped)\n    pops for the three parameters can occur as soon as they are no longer needed, and\n    that is immediately after the first map. Similarly the three (dipped) pops for\n    the three intermediate values can occur after the second map. But when the number\n    of pops is small (three in this case) we can do better than [pop pop pop] dip.\n    The combinators nullary, unary, binary and ternary are normally used to ensure\n    that a quoted program does not consume more than 0, 1, 2 or 3 values from the stack.\n    They can also be used to ensure that exactly that many are consumed. So the two\n    lots of three pops can both be expressed by the ternary combinator.\n  ")]),n("pre",[e._v("DEFINE\n      quadratic-2  ==                                # a b c => [root1 root2 ]\n          [ [ [ pop pop 2 * ]                        # divisor\n              [ pop 0 swap - ]                       # minusb\n              [ swap dup * rollup * 4 * - sqrt ] ]   # radical\n            [i] map ]\n          ternary i\n          [ [ [ + swap / ]                           # root1\n              [ - swap / ] ]                         # root2\n            [i] map ]\n          ternary.\n  ")]),n("p",[e._v("\n    This version of the program is the best of the three in this note. It has now been\n    added to the numlib.joy standard library.\n  ")]),n("p",[e._v("\n    There is another device which sometimes can be useful, especially when the number\n    of pops is larger than can be handled by a single combinator such as ternary. This\n    might arise if the number of intermediate values is large, and they have been computed\n    as a list, most probably by [i] map. In such a case that very same list can be\n    used as the (temporary) stack for the following computations. The combinator infra\n    expects a list and above that a quotation. It will treat the list as the stack\n    and execute the quotation using that stack. It will return the modified list on\n    top of the regular stack. In the present program for the quadratic formula, after\n    the three intermediate values have been computed as a list, the remaining computation\n    for the two roots can be done under the control of the infra combinator. Note that\n    this is in the last line of the program below. When that returns, the required\n    final value will be what is on top of this temporary stack, which the first element\n    on the list, and that can be extracted with the first operator. The remaining intermediate\n    values thereby disappear, no matter how many there were. The device is an overkill\n    in the present case for the quadratic formula, but it can be useful elsewhere.\n  ")]),n("p",[e._v("\n    The device can also be used when instead several parameters there is only one, but\n    it is a possibly long list of values. This situation does not obtain in the present\n    case, but we can make it so by a chain of three conses into an initially empty\n    list. This is only done in the program below to enable the first use of the infra\n    combinator. So the following illustrates the use of the infra combinator twice,\n    once for computing the intermediate values, and once for computing the final result.\n    The first use relied on the ugly chain of conses at the beginninng, and would not\n    really be recommended. But the second use would be a reasonable and more widely\n    useful alternative to the ternary combinator. Note also that because of the infra\n    combinator some of the order of computations needed to be different from the preceding\n    program.\n  ")]),n("pre",[e._v("DEFINE\n      quadratic-3  ==                                # a b c => [root1 root2 ]\n          [] cons cons cons                          # list of parameters\n          [ [ [ [dup * swap] dip * 4 * - sqrt ]      # radical\n              [ pop 0 swap - ]                       # minusb\n              [ 2 * ] ]                              # divisor\n            [i] map ]\n          infra first\n          [ [ [ + swap / ]                           # root1\n              [ - swap / ] ]                         # root2\n            [i] map ]\n          infra first.\n  ")]),n("hl2",[e._v("\n    Postscript: Combinators as parameters to other combinators\n    "),n("p",[e._v("\n      The construction [i] map is only one of many others of the form [C] map, where C\n      is a combinator. This can be useful when C is a combinator other than i. Note\n      that these two are equivalent:\n    ")]),n("pre",[e._v("        [  [..]     [..]  ]  [..]    ]    [C]  map\n          [ [[..] C] [[..] C] [[..] C] ]    [i]  map\n  ")]),e._v("\n    In a way the C distributes from the right (inside the [C]) over the quotations.\n    An example would be\n    "),n("pre",[e._v("        [1 2 3 4]  [[even] [2 >]]  [filter]  map\n  ")]),e._v("\n    which leaves [[2 4] [3 4]] on top of the stack, with the original [1 2 3\n    4] just below.\n    "),n("p",[e._v("\n      Constructions in which combinators take other combinators as parameter have not been\n      explored much in Joy. Another example, with two quoted combination parameters\n      is the first program below, which is equivalent to the second:\n    ")]),n("pre",[e._v("        [even]  [pop size 5 >]  [       filter]  [       map]  ifte\n                  [    size 5 >]  [[even] filter]  [[even] map]  ifte\n  ")]),e._v("\n    Both programs expect a list (or set) of numbers, and, for lists of more than\n    5 members they return a list of the even numbers, and for shorter lists they return\n    a list of as many truth values, depending on whether the corresponding number is\n    even or not. In this example the quotation [even] distributes from the right into\n    the then-part end the else-part.\n  ")])],1)};a._withStripped=!0;var o={render:a,staticRenderFns:[function(){var e=this.$createElement,t=this._self._c||e;return t("p",[t("em",[this._v("Abstract:")]),this._v(" Complex expressions can be difficult to evaluate in Joy and\n    in other stack-based languages, especially when some of the parameters are needed\n    repeatedly for the computation of intermediate values. This note describes some\n    techniques that can be valuable in such cases. The example used is the quadratic\n    formula.\n  ")])}]};t.a=o},aJKn:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=n("THzk"),o=!1;var s=function(e){o||n("5+aw")},i=n("VU/8")(null,a.a,!1,s,"data-v-f740c3da",null);i.options.__file="pages/papers-on-joy/the-annoying-quadratic-formula.vue",t.default=i.exports}});