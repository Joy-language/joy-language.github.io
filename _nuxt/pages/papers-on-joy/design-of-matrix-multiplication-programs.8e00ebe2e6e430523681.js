webpackJsonp([14],{DE7V:function(e,t,n){(e.exports=n("FZ+f")(!1)).push([e.i,"p[data-v-7837928d]{margin-top:16px;margin-bottom:16px}hr[data-v-7837928d]{margin-bottom:16px}pre[data-v-7837928d]{margin-bottom:auto}code[data-v-7837928d],kbd[data-v-7837928d],pre[data-v-7837928d]{font-family:Roboto Mono,monospace}",""])},GJ8n:function(e,t,n){var a=n("DE7V");"string"==typeof a&&(a=[[e.i,a,""]]),a.locals&&(e.exports=a.locals);n("rjj0")("12094266",a,!1,{sourceMap:!1})},NkBv:function(e,t,n){"use strict";var a=function(){var e=this.$createElement;this._self._c;return this._m(0)};a._withStripped=!0;var o={render:a,staticRenderFns:[function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("article",[n("p",[e._v("\n    NOTE: Some of the definitions in here have been included in the matrix/vector library,\n    but under quite different systematic names.\n  ")]),n("h1",[e._v("1. A numerical matrix addition operator")]),n("p",[e._v("\n    A matrix is a rectangular collection of items, most often numbers. Two matrices M1\n    and M2 can be added just in case both have the same number of rows and both have\n    the same number of columns. In that case their sum M3 has that same number of row\n    and that same number of columns. Each element in the result matrix M3 is just the\n    arithmetic sum of the corresponding elements of the other two matrices M1 and M2.\n    Two matrices M1 and M2 can be multiplied just in case M1 has as many columns as\n    M2 has rows. In that case their product M3 has as many rows as M1 and as many columns\n    as M2. In detail, if M1 has I rows and J columns, and M2 has J rows and K columns,\n    then the element in row i and column k of M3 is computed by multiplying the J pairs\n    of corresponding elements of row i of M1 and column k of M2 and then adding the\n    products.\n  ")]),n("p",[e._v("\n    In Joy a matrix of I rows and J columns can be represented as a list of I lists each\n    of J elements. The remainder of this note deals with matrix addition and matrix\n    multiplication in Joy. The first sections deal with such operators just for numerical\n    matrices. In Joy0 this means just integer, in Joy1 this means integer or float.\n    The sections which then follow deal with general addition and multiplication combinators\n    suitable for matrices built from other datatypes.\n  ")]),n("p",[e._v("\n    How can we write a program "),n("em",[e._v("num-matadd")]),e._v(" to add two matrices of numbers giving\n    a third? We want\n  ")]),n("pre",[e._v("M1  M2  num-matadd   ==>   M3\n  ")]),e._v("\n  As a first step consider element-wise addition of two vectors of the same\n  length, represented in Joy just as a list. The result vector has that same length.\n  Some languages have a zipwith combinator, but in Joy it is just called map2. Whereas\n  map takes one list parameter, map2 takes two. Both combinators also take a quotation\n  parameter which determines how the elements of the parameter list(s) are to be used\n  to form the elements of the result list. For vector addition the elements have to\n  be added, so the required program could be defined by\n  "),n("pre",[e._v("num-vectadd   ==   [+]  map2\n  ")]),e._v("\n  Now to add two matrices of numbers we just have to use map2 again to add the\n  rows as vectors:\n  "),n("pre",[e._v("M1  M2  [num-vectadd]  map2   ==>   M3\n  ")]),e._v("\n  Hence the following definition:\n  "),n("br"),n("pre",[e._v("num-matadd   ==   [num-vectadd]  map2\n  ")]),e._v('\n  For later purposes it is useful to "inline" the definition of num-vectadd,\n  giving\n  '),n("pre",[e._v("num-matadd   ==   [[+] map2]  map2\n  ")]),n("p"),n("h1",[e._v("2. A numerical matrix multiplication operator")]),n("p",[e._v("\n    How can we write a program "),n("em",[e._v("matmul")]),e._v(" to multiply two matrices to give a third?\n    This is a little harder. We want:\n  ")]),n("pre",[e._v("M1  M2  num-matmull   ==>   M3\n  ")]),e._v("\n  Notice that M3 has exactly as many rows as M1, and hence the Joy lists M1\n  and M3 are of the same length. Each of the I component lists of M1 is mapped to a\n  corresponding list of M3. The details of the mapping of course also depend on M2.\n  So the mapping function will make use of M2. As a first step we may write\n  "),n("pre",[e._v("M1  [M2 P]  map   ==>   M3\n  ")]),e._v("\n  where P is to be determined later. Even then, M2 is not really supposed to\n  be part of the program, because M2 will already be on the stack. But it is easy enough\n  to take it off the stack and put it in front of P:\n  "),n("pre",[e._v("M1  M2  [P]  cons  map   ==>   M3\n  ")]),e._v("\n  P must be program which encounters M2 on the stack and below that a list of\n  J numbers left behind from the map. P must use the K columns of M2 to produce a list\n  of K numbers for M3. This looks like another case of map, with Q to be determined\n  later: P == [Q] map. By substitution we have\n  "),n("pre",[e._v("M1  M2  [[Q] map]  cons  map   ==>  M3\n  ")]),e._v("\n  Two things are not quite right. Firstly, M2 is a list of J rows of K numbers,\n  but the new map just introduced needs a list of K columns of J numbers. So it needs\n  the transpose of M2:\n  "),n("pre",[e._v("M1  M2  transpose  [[Q] map]  cons  map   ==>  M3\n  ")]),e._v("\n  Secondly, the new map will consume each of the K columns from the transposed\n  M2 to produce a list of K numbers for M3, but it will also leave behind the list\n  of J numbers from M1 which the earlier, outer map left behind. This list of J numbers\n  needs to be removed after the new map has finished. But the list to be removed is\n  not on top of the stack but just below. So it must be removed by popd, which could\n  be defined by popd == [pop] dip.\n  "),n("pre",[e._v("M1  M2  transpose  [[Q] map popd]  cons  map   ==>  M3\n  ")]),e._v('\n  Program Q will find two lists of length J on the stack: a row list from M1\n  and a column list from M2. It must multiply corresponding numbers from the two lists\n  and then add their products. This operattion is useful elsewhere, it is called scalar\n  product. One way to compute it is to produce a list of products first, and then add\n  the elements of that list. The list of products is similar to vector addition defined\n  earlier, but it uses multiplication. So the list of products is produced by [*] map2.\n  The resulting list can then be added with the sum operator. The sum operator works\n  like this: starting with 0, add to that all the elements of the list. This is called\n  "folding" the list, using the binary + operator. These are the definitions:\n  '),n("pre",[e._v("sum   ==   0  [+]  fold\n  scalar-product   ==   [*] map  sum\n  ")]),e._v("\n  So the entire matrix multiplication problem now is simply\n  "),n("br"),n("pre",[e._v("M1  M2  transpose  [[scalar-product] map popd]  cons  map   ==>   M3\n  ")]),e._v("\n  So we may define:\n  "),n("br"),n("pre",[e._v("num-matmul   ==   transpose  [[scalar-product] map popd]  cons  map\n  ")]),e._v("\n  For later purposes it is again useful to inline scalar-product and then sum.\n  The new definition is here written over several lines for comparison with later variations:\n  "),n("pre",[e._v("num-matmul   ==   transpose\n                    [[[*] map2 0 [+] fold]  map  popd]  cons\n                    map\n  ")]),n("h1",[e._v("3. General matrix combinators")]),n("p",[e._v("\n    The addition and multiplication operators of the preceding sections only work for\n    numerical matrices. But the only four parts in the definitions that depend on that\n    are [+] inside num-matadd, and [*], 0 and [+] inside num-matmul. However, matrices\n    could have other kinds of things as elements. For example, one might have logical\n    matrices in which the elements are the truth values true and false. In that case\n    one would want two further definitions with just the four parts replaced by [or],\n    [and], false and [or]. Or one might want two operators for different datatypes\n    again. In fact, for matrix addition and multiplication the three matrices M1 M2\n    M3 might have up to three different kinds of elements. It would be useful to have\n    general matrix manipulation combinator that abstract from details.\n  ")]),n("p",[e._v("\n    How can we write a general matrix addition combinator? It should satisfy\n    "),n("br")]),n("pre",[e._v("M1  M2  [+]  gen-matadd   ==>  M3\n  ")]),e._v("\n  which behaves just like the numerical addition operator, and with [or] instead\n  of [+] behaves like a logical addition operator? In either case it has to transform\n  the quotation [+] into [[+] map2] map2, or the quotation [or] into [[or] map2] map2.\n  This is easy enough,in the numerical case it is\n  "),n("pre",[e._v("M1  M2  [+]  [map2]  cons  map2   ==>   M3\n  ")]),e._v("\n  So we may define a general matrix addition combinator\n  "),n("em",[e._v("gen-matadd")]),e._v(" by\n  "),n("br"),n("pre",[e._v("gen-matadd   ==   [map2]  cons  map2\n  ")]),e._v("\n  Now matrix addition for numbers or for truth values can be defined as\n  "),n("br"),n("pre",[e._v("num-matadd   ==    [+]  gen-matadd\n  log-matadd   ==   [or]  gen-matadd\n  ")]),e._v("\n  In Joy truth values and sets are treated in a very similar way, and collectively\n  they are called Boolean values. For truth values the or-operator produces the disjunction,\n  and for sets the or-operator produces the union. So the above logical matrix addition\n  operator would work equally well for matrices in which the element are sets. Because\n  of that it is better to call it a Boolean matrix addition operator, defined as:\n  "),n("pre",[e._v("bool-matadd   ==   [or]  gen-matadd\n  ")]),e._v("\n  As always, instead of actually having the definition one could just as easily\n  use the right hand side directly.\n  "),n("p",[e._v("\n    A general matrix multiplication combinator is a little harder. Let Q be any program\n    for combining a row from M1 and a column from M2 to form an element for M3. In\n    the nnumerical case the Q would have been the scalar product program. Then a combinator\n    "),n("b",[e._v("gen-matmul")]),e._v(" would be used like this:\n  ")]),n("pre",[e._v("M1  M2  [Q]  gen-matmul   ==>   M3\n  ")]),e._v("\n  Now M2 needs to be transposed as before, but it is below the [Q], so gen-matmul\n  must use dip:\n  "),n("pre",[e._v("M1  M2  [Q]  [transpose]  dip  S   ==>   M3\n  ")]),e._v("\n  S must construct [[Q] map popd] and then use that with T:\n  "),n("br"),n("pre",[e._v("M1  M2  [Q]  [transpose]  dip  [map popd]  cons  T   ==>   M3\n  ")]),e._v("\n  But T is just as before, T == cons map:\n  "),n("br"),n("pre",[e._v("M1  M2  [Q]  [transpose]  dip  [map popd]  cons  cons map   ==>   M3\n  ")]),e._v("\n  So we can define the general combinator\n  "),n("br"),n("pre",[e._v("gen-matmul   ==   [transpose]  dip\n                    [map popd]  cons  cons\n                    map\n  ")]),e._v("\n  Now the multiplication of numerical and logical matrices can be defined just\n  in terms of the corresponding scalar products:\n  "),n("pre",[e._v("num-matmul   ==   [  [*] map2       0 [+]  fold]  gen-matmul\n  log-matmul   ==   [[and] map2   false [or] fold]  gen-matmul\n  ")]),e._v("\n  Compared with the earlier, explicit version of num-matmull, this version must\n  execute one extra dip and one extra cons in gen-matmul. But this is negligible compared\n  with the amount of real work done later by either version, especially the I*J*K numerical\n  multiplications (in [*]) and numerical additions (in [+]) required for any numerical\n  matrix multiplication program. Exactly the same is true for the logical version.\n  "),n("h1",[e._v("4. A cleaner multiplication combinator")]),n("p",[e._v("\n    There is really nothing one could do to improve the addition combinator gen-matadd.\n    But as the two examples of applications of the gen-matmul combinator show, they\n    will all have to use the map2 and the fold combinator. It would be cleaner to have\n    the map2 and the fold as part of the general combinator, so that users only have\n    to include what is specific to the datatype of the matrices. The specific parts\n    are a binary operator [B1] (which is [*] or [and] in the examples), and also a\n    zero element Z2 and a binary operator [B2] (which are 0 and [+] or false and [or]\n    in the examples). The value Z2 has to be the zero element for the binary operation\n    in [B2]. As gen-matmul stands, one has to provide one quotation parameter, in the\n    form\n  ")]),n("pre",[e._v("[ [B1] map2  Z2 [B2] fold ]  gen-matmul\n  ")]),e._v("\n  It would be cleaner if one could provide just what is really needed:\n  "),n("br"),n("pre",[e._v("[B1]  Z2 [B2]  gen-matmul\n  ")]),e._v("\n  The required change to gen-matmul is quite simple, all that is needed is a\n  preliminary program P which changes the three simple parameters to the one complicated\n  parameter:\n  "),n("pre",[e._v("[B1]  Z2 [B2]   P   ==>   [ [B1] map2  Z2 [B2] fold ]\n  ")]),e._v("\n  The preliminary program can first use [fold] cons cons, and this will at least\n  change Z2 [B2] into [Z2 [B2] fold]. Following that some other changes C are needed:\n  "),n("pre",[e._v("[B1]  Z2 [B2]  [fold] cons cons  C   ==>   [ [B1] map2  Z2 [B2] fold ]\n  ")]),e._v("\n  The first parameter [B1] has to be changed to [[B1] map2], but this has to\n  be done with dip just below the last constructed quotation. It is done by [[map2]\n  cons] dip:\n  "),n("pre",[e._v("[B1] Z2 [B2] [fold] cons cons [[map2] cons] dip F ==> [ [B1] map2 Z2 [B2] fold ]\n  ")]),e._v("\n  where the finalisation F simply has to concatenate the two previous constructions:\n  "),n("pre",[e._v("[B1] Z2 [B2] [fold] cons cons [[map2] cons] dip concat\n                        ==>    [B1] map2 Z2 [B2] fold ]\n  ")]),e._v("\n  The above program becomes a new first line in the otherwise unchanged program\n  for the gen-matmul combinator:\n  "),n("pre",[e._v("gen-matmul   ==   [fold] cons cons [[map2] cons] dip concat\n                    [transpose] dip\n                    [map popd] cons cons\n                    map\n  ")]),e._v("\n  Now the multiplication operators for numerical and logical matrices can be\n  given by the more perspicuous definitions\n  "),n("pre",[e._v("num-matmul   ==   [*]  0 [+]  gen-matmul\n  log-matmul   ==   [and]  false [or]  gen-matmul\n  ")]),n("h1",[e._v("5. An even more general multiplication combinator")]),n("p",[e._v("\n    The two definitions just above will be suitable for many purposes. Like all definitions\n    so far, they even work for degenerate matrices with no rows and no columns. Such\n    degenerate matrices are of course represented as [], and their arithmetic or logical\n    product is again []. For other datatypes it is often easy to give the appropriate\n    definition. For example one might need an operation for the multiplication of matrices\n    in which the elements are sets. In Joy set intersection is just and, wheras set\n    union is just or. The zero element for union is {}. So a suitable definition is\n  ")]),n("pre",[e._v("set-matmul   ==   [and]  {} [or]  gen-matmul\n  ")]),e._v("\n  Comparing logical matrix multiplication and set matrix multiplication, the\n  two are almost identical except for the different zero elements false and {}. This\n  difference has the consequence that whereas the and-operator and the or-operator\n  work equally for logical and set operands, we cannot define a single matrix multiplication\n  operator that works equally for logical and set operations. That would be unfortunate,\n  although one could first do a very simple test on the first element in the first\n  row of M2 to determine whether it is a truth value or a set.\n  "),n("p",[e._v("\n    But there are other cases where there could not be such a simple device. Consider\n    the problem of multiplying second order matrices in which the elements themselves\n    are numerical matrices of compatible rows and columns but where the number of rows\n    and columns are not known in advance. This means that the zero element for the\n    addition of the submatrices is also not known in advance, and hence in the definition\n    below the ??? is not known in advance.\n  ")]),n("pre",[e._v("num-matmul2   ==   [num-matmul]  ???  [num-matadd]  gen-matmul\n  ")]),e._v("\n  What is particularly annoying is that ??? is the only part that needs to be\n  known for the definition to work.\n  "),n("p",[e._v("\n    There would be other cases in which the same problem arises. They will all involve\n    the datatype of the Z2 zero element for the binary [B2] operation, where that datatype\n    is of indeterminate size, shape or structure. There are no such restrictions on\n    [B1] and [B2]. It is true that a suitable Z2 can always be constructed from two\n    sample elements from M1 and M2 by applying the [B1] operation, and then making\n    a suitable Z2 from that. All this would have to be encoded in a very complex version\n    of gen-matmul.\n  ")]),n("p",[e._v("\n    But there is a simpler solution. Consider again the versions of the numerical matrix\n    multiplication operators of sections 1 and 2. They required, in some way or another,\n    a program to compute a scalar product:\n  ")]),n("pre",[e._v("[ [*] map2  0 [+] fold ]\n  ")]),e._v("\n  In all but the degenerate case the list produced by map2 will not be null.\n  So in the normal case the list can be taken apart with unswons. That will leave the\n  first element of that list, followed by the rest of the list. The rest can now be\n  folded by using not 0 as the initial value of the accumulator, but the first element\n  of the list. In other words, the above program fragment could be replaced by\n  "),n("pre",[e._v("[ [*] map2  unswons [+] fold ]\n  ")]),e._v("\n  So it would be possible to have just [*] and [+] as the parameters to the\n  general matrix multiplication combinator, and let the combinator supply map2, unswons\n  and fold. This would imply changing the first line of the last version by a program\n  P which does the conversion\n  "),n("pre",[e._v("[B1]  [B2]  P   ==>   [ B1] map2  unswons [B2] fold ]\n\n  The conversion is quite similar to the earlier one.\n  But now only one parameter, [B1] has to be consed into [fold],\n  then [B1] has to be consed, through dip, into [map2 unswons],\n  and then these results concatenated.\n  So the required program P is\n  "),n("pre",[e._v("[fold] cons  [[map2 unswons] cons] dip  concat\n  ")]),e._v(" This program replaces the first line of the previous definition of the general\n  matrix multiplication combinator:\n  "),n("pre",[e._v("gen-matmul   ==   [fold] cons [[map2 unswons] cons] dip concat\n                    [transpose] dip\n                    [map popd] cons cons\n                    map\n  ")]),e._v(" Now the multiplication operators can be defined quite simply. The first is\n  for numerical matrices. In Joy0 this means just integer, in Joy1 this means integer\n  or float. The second is for Boolean matrices, of either truth values or sets. The\n  third is for second order matrices of numerical matrices. The fourth is for second\n  order matrices of Boolean matrices.\n  "),n("pre",[e._v("num-matmul     ==   [*]  [+]  gen-matmul\n  bool-matmul    ==   [and]  [or]  gen-matmul\n  num-matmul2    ==   [num-matmul]  [num-matadd]  gen-matmul\n  bool-matmul2   ==   [bool-matmul]  [bool-matadd]  gen-matmul\n  ")]),e._v(" It is easy to see how multiplication of third order matrices would be defined.\n  But it is doubtful whether even second order matrices arise.\n\n  "),n("h1",[e._v("6. Polymorphic matrix operators")]),n("p",[e._v("\n    It could be useful to have a single matrix mutltiplication operator which can handle\n    at least numerical and Boolean matrices. To do so, it must inspect the type of\n    the elements. If they are numerical it must behave like num-matmul above, and if\n    the are Boolean it must behave like bool-matmul above. If the type is neither,\n    an error must be reported and the execution aborted. As a first draft, the following\n    is useful:\n  ")]),n("pre",[e._v("                dup first first\n                  (* branching on the type,\n                     push [*] and [+], or push [and] and [or],\n                     or report error and abort *)\n                  gen-matmul\n  ")]),e._v(" The branching looks like a three-way branch which could be handled by two\n  ifte combinators, one inside another, or by a single cond combinator. But in Joy1\n  the numerical and the Boolean cases both split into two: the numerical types are\n  integer and and float, and the Boolean cases are logical and set. (In Joy0 the only\n  numerical type is integer.) So each of the two correct situations can arise in two\n  ways: when the element type is integer or float, and when the element type is logical\n  or set. The predicates numerical and boolean test for that. The cond combinator takes\n  the two normal cases and as its default the error condition.\n  "),n("pre",[e._v('                [ [ [numerical]   pop   [*] [+]         ]\n                    [ [boolean]     pop [and] [or]        ]\n                    [ "unknown operands\\n" putchars abort ] ]\n                  cond\n  ')]),e._v(" Alternatively, the branching could be based on those four cases, with a fifth,\n  default case for the error situation. Since this branching is on the basis of types,\n  the opcase operator is most suitable.\n  "),n("pre",[e._v('                [ [ 0     pop [*]   [+]               ]\n                    [ 0.0   pop [*]   [+]               ]\n                    [ true  pop [and] [or]              ]\n                    [ {}    pop [and] [or]              ]\n                    [ "unknown operand\\n" putchars abort] ]\n                  opcase\n  ')]),e._v(" It may be a matter of taste whether the version with the cond combinator or\n  the version with the opcase combinator is preferable. Either of the two could be\n  used as the insertion in the earlier skeleton.\n  "),n("p",[e._v("\n    But before that, it is useful to remember at this point that the gen-matmul combinator\n    will fail for degenerate matrices. But that is easily fixed right here: the product\n    of two degenerate matrices is just the degenerate matrix []. So the earlier skeleton\n    should be wrapped inside an ifte combinator: if the top matrix is degenerate, pop\n    if off and return the other matrix (which should be degenerate, too). Otherwise,\n    proceed with the ordinary version.\n  ")]),n("pre",[e._v('poly-matmul   ==\n      [ null ]\n      [ pop ] \n      [     dup first first\n            [ [ [numerical] pop [*]   [+]              ]\n              [ [boolean]   pop [and] [or]             ]\n              [ "unknown operand type\\n" putchars abort] ]\n            cond\n            gen-matmul ]\n      ifte\n  ')]),e._v(" This definition of the polymorphic matrix multiplication operator is typical\n  of how generality can be achieved in Joy without the use of object oriented concepts.\n  The extra computation needed for such polymorphism might seem a waste, but it is\n  essential for writing useful general libraries.\n  "),n("p",[e._v("\n    NOTE: Some of the definitions in here have been included in the matrix/vector library,\n    but under quite different systematic names.\n  ")])])])}]};t.a=o},hS6g:function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var a=n("NkBv"),o=!1;var i=function(e){o||n("GJ8n")},r=n("VU/8")(null,a.a,!1,i,"data-v-7837928d",null);r.options.__file="pages/papers-on-joy/design-of-matrix-multiplication-programs.vue",t.default=r.exports}});