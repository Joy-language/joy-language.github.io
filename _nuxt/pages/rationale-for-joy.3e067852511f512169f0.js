webpackJsonp([7],{"2zBy":function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var o=t("q/18"),a=!1;var i=function(e){a||t("u4Hl")},s=t("VU/8")(null,o.a,!1,i,"data-v-d9ca1c5e",null);s.options.__file="pages/rationale-for-joy.vue",n.default=s.exports},GzA0:function(e,n,t){(e.exports=t("FZ+f")(!1)).push([e.i,"main[data-v-d9ca1c5e]{margin-top:25px;padding-left:12vw;padding-right:12vw}p[data-v-d9ca1c5e]{margin-top:16px}h2[data-v-d9ca1c5e]{margin-top:16px;margin-bottom:16px}pre[data-v-d9ca1c5e]{margin:auto}code[data-v-d9ca1c5e],pre[data-v-d9ca1c5e]{font-family:Roboto Mono,monospace}",""])},"q/18":function(e,n,t){"use strict";var o=function(){var e=this.$createElement;this._self._c;return this._m(0)};o._withStripped=!0;var a={render:o,staticRenderFns:[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("main",[t("h1",[e._v(" Rationale for Joy, a functional language ")]),t("i",[e._v(" by Manfred von Thun ")]),t("p",[t("em",[e._v("Abstract: ")]),e._v("\n    Joy is a high-level purely functional programming language\n    which is not based on the application of functions\n    but on the composition of functions.\n    This paper gives a rationale for Joy\n    by contrasting it with with other paradigms of functional languages.\n    Joy differs from lambda calculus languages in that it has no\n    variables and hence no abstraction.\n    It differs from the combinatory calculus in that it does not use application.\n    It differs from the categorical languages in "),t("em",[e._v("uniformly")]),e._v("\n    using an untyped stack as the argument and value of the composed functions.\n    One of the datatypes is that of programs,\n    and the language makes extensive use of this,\n    more than other reflective languages.\n    The paper gives practical and theoretical introductions\n    to various aspects of the language.\n  ")]),t("p",[t("em",[e._v("Keywords: ")]),e._v("\n    lambda calculus, combinatory logic, lambda abstraction,\n    function application, function composition,\n    postfix notation\n  ")]),t("h1",[e._v("Introduction")]),e._v("\n  The language Joy is a purely functional programming language.\n  Whereas all other functional programming languages are based\n  on the application of functions to arguments,\n  Joy is based on the composition of functions.\n  All such functions take a stack as argument and produce\n  a stack as value.\n  Consequently much of Joy looks like ordinary postfix notation.\n  However, in Joy a function can consume any number of\n  parameters from the stack and leave any number of results on the stack.\n  The concatenation of appropriate programs denotes\n  the composition of the functions which the programs denote.\n  One of the datatypes of Joy is that of quoted programs,\n  of which lists are a special case.\n  Some functions expect quoted programs on top of the stack\n  and execute them in many different ways, effectively by dequoting.\n  So, where other functional languages use abstraction and application,\n  Joy uses quotation and combinators -- functions which perform dequotation.\n  As a result, there are no named formal parameters,\n  no substitution of actual for formal parameters,\n  and no environment of name-value pairs.\n  Combinators in Joy\n  behave much like functionals or higher order functions in other languages,\n  they minimise the need for recursive and non-recursive definitions.\n  Joy has a rich but simple algebra,\n  and its programs are easily manipulated by hand and by other programs.\n  "),t("p",[e._v("\n    Joy is an attempt to design a high level programming language\n    which is based on a computational paradigm that is\n    different from the three paradigms on which existing functional languages\n    are based.\n    Two of these paradigms have been criticised in the literature,\n    and Joy aims to overcome the complexity of the third\n    by a simpler mechanism.\n  ")]),t("p",[e._v("\n    The remainder of this paper is organised as follows.\n    The next two section of the paper assume some familiarity with\n    three paradigms:\n    the lambda calculus, combinatory calculus and, to a lesser extent,\n    the basic notions of category theory.\n    The purpose of these sections is to contrast Joy with these paradigms\n    and to motivate the departure.\n    The other sections are very specific to Joy and hence\n    mostly self-contained.\n    One section is a short tutorial introduction,\n    another a discussion of theoretical aspects.\n    The concluding section\n    gives a more detached perspective.\n  ")]),t("h1",[e._v("Background of functional languages")]),t("p",[e._v("\n    All natural languages and most artificial languages contain as a component\n    a functional language\n    which allows expressions to be built up from individual symbols\n    together with functional symbols.\n    In appropriate interpretations the expressions have a value which is\n    an individual.\n    Even statements can be considered to belong here,\n    provided we take predicates to be functions which yield a truth value.\n    Sometimes one needs higher order functions,\n    often called functionals or combinators\n    which can take other functions as parameters.\n    Higher order functions can be handled in\n    the lambda calculus.\n    Here functional expressions are built from variables and constants\n    by just two constructions.\n    One of these is "),t("em",[e._v("lambda abstraction")]),e._v(":\n    if "),t("code",[e._v("(..x..)")]),e._v(" is an expression containing a variable,\n    then its lambda abstraction is generally written $\\lambda$"),t("code",[e._v("x(..x..)")]),e._v('\n    and pronounced\n    "the function of one parameter '),t("code",[e._v("x")]),e._v(" which yields the result\n    "),t("code",[e._v("(..x..)")]),e._v('".\n    The other construction is '),t("em",[e._v("application")]),e._v(", written in infix:\n    if "),t("code",[e._v("f")]),e._v(" is a function, then "),t("code",[e._v("f @ x")]),e._v("\n    is the result of applying the function to "),t("code",[e._v("x")]),e._v(".\n    Functions of several parameters are still a nuisance because\n    one has to write "),t("code",[e._v("g @ <x,y></x,y>")]),e._v(" and "),t("code",[e._v("h @ <x,y,z></x,y,z>")]),e._v('\n    and so on.\n    There is a useful device called currying,\n    Generally attributed to Curry, but freely acknowledged by\n    him to be due to Sch\\"{o}nfinkel (1924).\n    The term "Sch\\"{o}nfinkeling" never caught on.\n    By currying\n    all functions can be taken to be unary.\n    The binary application operation is still written in infix notation,\n    and by making it left-associative some parentheses can be saved.\n    Furthermore, since it is the '),t("em",[e._v("only")]),e._v(" binary operation,\n    the "),t("code",[e._v("@")]),e._v(" symbol is simply left out.\n  ")]),t("p",[e._v("\n    The notation makes the expression\n  ")]),t("pre",[e._v("        +  2  3\n  ")]),e._v("\n  potentially ambiguous. On one reading it is a prefix expression,\n  entirely equivalent to the infix "),t("code",[e._v("2 + 3")]),e._v(" or the postfix\n  "),t("code",[e._v("2 3 +")]),e._v(", with "),t("code",[e._v("+")]),e._v(" as the binary operator and the two\n  numerals as operands. On another reading it is a nested infix\n  expression with binary application suppressed between the two\n  numerals as the main operator and a similar subordinate\n  suppressed operator between the curried "),t("code",[e._v("+")]),e._v(" and the "),t("code",[e._v("2")]),e._v(".\n  In practice there is no confusion because the context\n  disambiguates, particularly in nested expressions.\n  Prefix never needs parentheses,\n  that is why it was invented by Polish logicians.\n  Applicative notation needs parentheses in more complex expressions,\n  see section 3.\n  Syntax aside, there is a world of difference in the semantics between\n  prefix and "),t("em",[e._v("applicative")]),e._v(' notation.\n  A similar ambiguity will arise later.\n  (As yet another applicative notation,\n  to eliminate parentheses completely,\n  Quine in his foreword to the\n  Sch\\"{o}nfinkel (1924) reprint\n  suggested using prefix for application,\n  thus: '),t("code",[e._v("@fx")]),e._v(", "),t("code",[e._v("@@gxy")]),e._v(" and so on.)\n  "),t("p",[e._v("\n    The lambda calculus is an immensely powerful system.\n    It comes as a surprise that it is Turing complete,\n    that all "),t("em",[e._v("computable function")]),e._v('s\n    can be expressed in the \n    lambda calculus with just variables, abstraction\n    and application, and can then be computed by reduction.\n    Even numbers can be represented, as Church numerals,\n    and similarly for lists.\n    However,\n    any efficient implementation will need constants,\n    and all practical programming languages based\n    on the lambda calculus provide them.\n    This includes the older language Lisp\n    and its descendants, based on the untyped lambda calculus,\n    and also the newer languages\n    ML\n    %  ML, Miranda\\footnote{\n    %  "Miranda" is a trademark of Research Software Ltd.}\n    and Haskell, based on a typed lambda calculus with parametric polymorphism.\n    Central to all of them are the lambda calculus operations\n    of abstraction and application.\n  ')]),t("p",[e._v("\n    The lambda calculus is a purely syntactic calculus,\n    and its rules have to do with simplifying\n    expressions.\n    The few rules are deceptively simple but are in fact\n    difficult to use correctly in real examples.\n    The main difficulty arises from the variables which\n    get in each other's way.\n    Their purpose is to steer arguments into the right position.\n    Can one do without variables,\n    to make things easier for people or for computers,\n    and still steer arguments into the right position?\n    Brus "),t("em",[e._v("et al")]),e._v(' (1987 p 364)\n    write "if one wants to have a computational model\n    for functional languages which is also close to their implementations,\n    pure lambda calculus is not the obvious choice anymore".\n  ')]),t("p",[e._v("\n    One alternative is combinatory calculus,\n    also called "),t("em",[e._v("combinatory logic")]),e._v(' because of its origin.\n    The key idea came from\n    Sch\\"{o}nfinkel (1924)\n    but was greatly expanded in\n    Curry and Feys (1958).\n    Variables can indeed be eliminated completely,\n    provided some appropriate higher order functions\n    or combinators are introduced.\n    Most such systems use as their basis a translation scheme from\n    the lambda calculus to a combinatory calculus\n    which only '),t("em",[e._v("needs")]),e._v(" two combinators,\n    the S combinator and the K combinator.\n    Abstraction is an operation in the "),t("em",[e._v("object language")]),e._v(",\n    the lambda calculus.\n    In combinatory logic this operation is replaced by\n    an operation in the "),t("em",[e._v("metalanguage")]),e._v(".\n    This new operation is called bracket abstraction,\n    essentially a compilation.\n    Since all lambda calculus expressions can be compiled in this manner,\n    the language of combinators is again Turing complete.\n    The simple compilation scheme yields translations\n    whose length can be exponential\n    in the length of the source expression.\n    Using additional combinators it is possible\n    to produce translations of acceptable lengths.\n    The combinators "),t("code",[e._v("S")]),e._v(" and "),t("code",[e._v("K")]),e._v("\n    can be used to define all other combinators one might\n    desire,\n    or even on their own to eliminate variables and hence lambda abstractions\n    "),t("code",[e._v("lambda x (..x..)")]),e._v('.\n    Even recursion can be handled with the "paradoxical" Y combinator\n    which is equivalent to a (hideous) expression just in '),t("code",[e._v("S")]),e._v(" and "),t("code",[e._v("K")]),e._v(".\n    A similar "),t("code",[e._v("y")]),e._v(" combinator in Joy is discussed in section 5.\n    "),t("code",[e._v("Y")]),e._v(" and "),t("code",[e._v("y")]),e._v(" cannot be given a finite type,\n    so they are not definable in typed languages.\n    Joy, like Lisp, is untyped, hence it requires runtime checks.\n  ")]),t("p",[e._v('\n    So we can do without abstraction but with application together\n    with first and higher order functions.\n    The resultant system is simpler,\n    but because it is so low level,\n    it has never been proposed as a programming language.\n    However it did inspire\n    Backus (1978)\n    in his Turing award lecture\n    where he introduced his FP system,\n    short for "Functional Programming system".\n    Central to the language are '),t("em",[e._v("functional forms")]),e._v(",\n    a small, fixed and unextendible collection\n    of combinators operating on unary functions.\n    A more recent reference is\n    Backus, Williams and Wimmers (1990).\n    Backus acknowledges a dept to combinatory logic,\n    but his aim was to produce a variable free notation\n    that is amenable to simple algebraic manipulation by people.\n    Such ease should produce clearer and more reliable programs.\n  ")]),t("h1",[e._v("Motivating foundation for Joy")]),t("p",[e._v("\n    Like the various lambda calculus languages,\n    the low level combinatory calculus and the higher level language\n    FP still use application\n    of functions to their arguments.\n    However, as\n    Meertens (1989 p 71)\n    writes,\n    \"The basic problem is that the basic operation of the classical combinator\n    calculus (and also of the closely related lambda calculus)\n    is application instead of composition.\n    Application has not a single property.\n    Function composition is associative\n    and has an identity element\n    (if one believes in the 'generic' identity function).\"\n    Of course application is substitutive,\n    identical arguments yield identical results,\n    hence if "),t("code",[e._v("f = g")]),e._v(" and "),t("code",[e._v("x = y")]),e._v(" then "),t("code",[e._v("f @ x = g @ y")]),e._v('.\n    But the substitutivity property is shared with all other functions.\n    Meertens later (p 72) speaks of\n    "the need of a suitable system of combinators\n    for making functions out of component functions\n    without introducing extra names in the process.\n    Composition should be the major method, and not application."\n    This is in fact done in category theory\n    for the (concrete) category of functions,\n    their compositions and their types.\n    Like Backus, Meertens develops a system of combining functions\n    that is more suitable to formal manipulation\n    than the classical combinators.\n  ')]),t("p",[e._v("\n    Consider a long expression, here again written explicitly with\n    the application operator "),t("code",[e._v("@")]),e._v(".\n    Note the need for parentheses.\n  ")]),t("pre",[e._v("    square @ (first @ (rest @ (reverse @ [1 2 3 4])))   --\x3e  9\n  ")]),e._v("\n  All the functions are unary, and unary functions can be composed.\n  The composition of unary functions is again a unary function,\n  and it can be applied like any other unary function.\n  Let us write composition with an infix dot "),t("code",[e._v('"."')]),e._v(".\n  The composition can be applied to the original list:\n  "),t("pre",[e._v("    (square . first . rest . reverse)  @  [1 2 3 4]     --\x3e  9\n  ")]),e._v("\n  One might even introduce definitions in the style of the first line,\n  and then write as in the second line:\n  "),t("pre",[e._v("    second = first . rest        second-last = second . reverse\n      (square . second-last)  @  [1 2 3 4]                --\x3e  9\n  ")]),e._v("\n  This and also the preceding definitions would not make sense with\n  application instead of composition.\n  Importantly, a definition can be used to textually replace\n  the "),t("em",[e._v("definiendum")]),e._v(" by its "),t("em",[e._v("definiens")]),e._v("\n  to obtain the original long composition expression.\n  This is because the textual operation of compounding several\n  expressions to make a larger one is mapped onto the\n  semantic operation of composing the functions denoted by the expressions.\n  The textual replacement is not possible\n  in the original applicative expression because\n  the parentheses get in the way.\n  "),t("p",[e._v("\n    Substitutivity is a highly desirable property for algebraic manipulation.\n    The only trouble is that the resultant composition expression\n    still has to be applied to an argument,\n    the list "),t("code",[e._v("[1 2 3 4]")]),e._v(".\n    If we could elevate that list to the status of a function,\n    we could eliminate application entirely from the expression\n    and write\n  ")]),t("pre",[e._v("    square . first . rest . reverse . [1 2 3 4]         --\x3e  9\n  ")]),e._v("\n  The numeral "),t("code",[e._v("9")]),e._v(" would also need to denote a function.\n  Can this be done?\n  "),t("p",[e._v("\n    Indeed it can be.\n    We just let numerals and list constants denote functions\n    which take a fixed dummy argument, written "),t("code",[e._v("?")]),e._v(",\n    as argument and return a number or a list as value.\n    So we should now write\n  ")]),t("pre",[e._v("  (square . first . rest . reverse . [1 2 3 4])  @  ?   --\x3e   9 @ ?\n  ")]),e._v("\n  We just have to pretend that "),t("code",[e._v("@ ?")]),e._v(" is not there,\n  that everything is a function anyhow.\n  The dummy argument device is routinely used in\n  the category of functions,\n  and the pretense is argued to be a superior view.\n  "),t("p",[e._v("\n    All this works well with unary functions, but how is one to deal\n    with functions of several arguments?\n    In category theory there is the notion of "),t("em",[e._v("products")]),e._v(",\n    and in the category of functions it is a way of dealing\n    with interrelated pairs ---\n    function pairs to produce value pairs of a type pair.\n    (Backus in his FP used a similar mechanism, "),t("em",[e._v("construction")]),e._v("\n    which used function tuples to produce value tuples.\n    But the function tuples ultimately need the application\n    operation to produce the value tuple.)\n    Two important "),t("em",[e._v("projection")]),e._v(" functions are needed\n    for picking the first and second from a pair\n    ("),t("code",[e._v("car")]),e._v(" and "),t("code",[e._v("cdr")]),e._v(" in Lisp).\n    Pairs would seem to be the obvious way to handle binary functions.\n    But this reintroduces pairs (of functions)\n    whereas in the lambda calculus pairs (of arguments)\n    were so elegantly eliminated by currying.\n    In category theory there is also the notion of "),t("em",[e._v("exponentials")]),e._v(",\n    and in the category of functions they are a way of dealing\n    with the interrelation between the type of functions,\n    the type of their arguments and the type of values.\n    Two important functions are needed:\n    explicit currying and explicit application ("),t("code",[e._v("apply")]),e._v(" in Lisp).\n    This makes such Cartesian closed categories second order.\n    They are a computationally equivalent alternative\n    to the (typed) lambda calculus and to combinatory calculus.\n    So these categorical languages\n    can handle functions of several argument\n    and all higher order functions.\n  ")]),t("p",[e._v("\n    Barr and Wells (1990 Chapter 6)\n    give an example of a simple lambda expression\n    with variables contrasted with first\n    a complicated looking and then a reformulated categorical equivalent formula.\n    Here the steering of arguments into the right place\n    is essentialy done by the projection functions.\n    Category theory has given rise to another model of computation:\n    the CAM or Categorical Abstract Machine,\n    described for example in\n    Cousineau "),t("em",[e._v("et al")]),e._v(" (1987).\n    The machine language of the CAM is very elegant,\n    but programs in that language\n    look as inscrutable as low level programs in other\n    machine languages.\n    The language is of course suitable as the target language\n    for compilation from any functional language.\n    For more recent references,\n    including to exciting hardware applications, see\n    Hains and Foisy (1993).\n  ")]),t("p",[e._v('\n    Many categorical concepts have been successfully used\n    in otherwise applicative languages,\n    such as the polymorphically typed Haskell, see the recent\n    Bird and de Moor (1997)\n    for the now mature theory and for many references.\n    Compact "pointfree" definitions in the style of '),t("code",[e._v("second-last")]),e._v(" above\n    are used routinely,\n    but many need additional operators, even application,\n    for example (p 10):\n  ")]),t("pre",[e._v("    length  =  sum . listr one            where  one a  =  1\n  ")]),e._v("\n  Note the implicit application between "),t("code",[e._v("listr")]),e._v(" and "),t("code",[e._v("one")]),e._v("\n  and again between "),t("code",[e._v("one")]),e._v(" and "),t("code",[e._v("a")]),e._v(" in the local "),t("code",[e._v("where")]),e._v(" definition.\n  The whole definition may be read as:\n  to compute the length of a list,\n  let "),t("code",[e._v("one")]),e._v(" be the function which ignores its argument ("),t("code",[e._v("a")]),e._v(")\n  and always returns "),t("code",[e._v("1")]),e._v(", use this function to map ("),t("code",[e._v("= listr")]),e._v(")\n  the given list to produce a list of just "),t("code",[e._v("1")]),e._v("s,\n  then take the sum of those.\n  "),t("p",[e._v("\n    At least for handling functions of several arguments\n    categorical concepts are rather heavy artillery.\n    Are there other ways?\n    Consider again the runnning example.\n    Written in plain prefix notation it needs no parentheses at all:\n  ")]),t("pre",[e._v("    square  first  rest  reverse  [1 2 3 4]             --\x3e  9\n  ")]),e._v("\n  An expression with binary operators such as the infix expression\n  "),t("code",[e._v("((6 - 4) * 3) + 2")]),e._v("\n  is written in prefix notation also without parentheses as\n  "),t("pre",[e._v("        +     *     -     6     4     3     2           --\x3e  8\n  ")]),e._v("\n  (Note in passing that the four consecutive numerals look\n  suspiciously like a list of numbers.)\n  We now have to make sense of the corresponding compositional\n  notation\n  "),t("pre",[e._v("       (+  .  *  .  -  .  6  .  4  .  3  .  2)  @  ?    --\x3e  8 @ ?\n  ")]),e._v('\n  Clearly the "'),t("code",[e._v("2")]),e._v('-function" is applied to the dummy argument.\n  But the other "number functions" also have to be applied to something,\n  and each value produced has to be retained for pairwise consumption\n  by the binary operators.\n  The order of consumption is the '),t("em",[e._v("reverse")]),e._v(" of the order\n  of production.\n  So there must be a stack of intermediate values which first grows\n  and later shrinks.\n  The dummy argument "),t("code",[e._v("?")]),e._v(" is just an empty stack.\n  "),t("p",[e._v("\n    What we have gained is this:\n    The expression denotes a composition of unary stack functions.\n    Literal numerals or literal lists denote unary functions\n    which return a stack that is just like the argument stack\n    except that the number or the list has been pushed on top.\n    Other symbols like "),t("code",[e._v("square")]),e._v(" or "),t("code",[e._v("reverse")]),e._v("\n    denote functions which expect as argument a stack whose top element\n    is a number or a list.\n    They return the same stack except that the top element has been replaced by\n    its square or its reversal.\n    Symbols for what are normally binary operations\n    also denote unary functions from stacks to stacks\n    except that they replace the top two elements by a new single one.\n    It is helpful to reverse the notation\n    so that compositions are written in the order of their evaluation.\n    A more compelling reason is given in the next section.\n  ")]),t("p",[e._v("\n    This still only has composition as a second order stack function.\n    Others are easy enough to introduce, using a variety of possible notations.\n    But now we are exactly where we were at the beginning of section 2:\n    The next level, third order  stack functions,\n    calls for a lambda calculus with variables ranging over first order\n    stack functions.\n    The variables can be eliminated by translating into a lean or rich\n    combinatory calculus.\n    Application can be eliminated by substituting composition\n    of second order stack functions, and so on.\n    This cycle must be avoided.\n    (But maybe the levels can be collapsed by something resembling\n    reducibility in Russell's theory of types?)\n  ")]),t("p",[e._v("\n    In reflective languages such as Lisp, Snobol and Prolog,\n    in which "),t("em",[e._v("program = data")]),e._v(", it is easier to write\n    interpreters, compilers, optimisers and theorem provers\n    than in non-reflective languages.\n    It is straightforward to define higher order\n    functions, including the "),t("code",[e._v("Y")]),e._v(" combinator.\n  ")]),t("p",[e._v('\n    Backus (1978)\n    also introduces another language, the reflective\n    FFP system, short for "Formal Functional Programming system".\n    In addition to objects as in FP there is now a datatype of '),t("em",[e._v("expressions")]),e._v(".\n    In addition to the listforming constructor as in FP\n    there is now a new binary constructor to form "),t("em",[e._v("application")]),e._v("s\n    consisting of an operator and an operand.\n    So expressions can be built up,\n    but they cannot be taken apart,\n    and hence FFP is not fully reflective, "),t("em",[e._v("program = $1/2$ data")]),e._v(".\n    One semantic rule, "),t("em",[e._v("metacomposition")]),e._v(", is immensely powerful.\n    It can be used to define arbitrary new functional forms,\n    including of course the fixed forms from FP.\n    The rule also makes it possible to compute recursive functions\n    without a recursive definition.\n    This is because in the application\n    the function is applied to a pair which includes the original\n    list operand which in turn contains as its first element\n    the expression denoting the very same function.\n    The method is considerably simpler than the\n    use of the "),t("code",[e._v("Y")]),e._v(" combinator.\n    A mechanism similar to metacomposition is possible in Joy,\n    see section 6.\n  ")]),t("p",[e._v("\n    Joy is also reflective.\n    As noted in passing earlier,\n    expressions which denote compositions of stack\n    functions which push a value already look like lists.\n    Joy extends this to arbitrary expressions.\n    These are now called quotations and can be\n    manipulated by list operations.\n    The effect of higher order functions\n    is obtained by first order functions which take\n    such quotations as parameters.\n  ")]),t("h1",[e._v("A little tutorial on Joy")]),t("p",[e._v("\n    To add two integers, say 2 and 3, and to write their sum,\n    you type the program\n  ")]),t("pre",[e._v("        2  3  +\n  ")]),e._v("\n  This is how it works internally:\n  the first numeral causes the integer 2 to be pushed onto a stack.\n  The second numeral causes the integer 3 to be pushed on top of that.\n  Then the addition operator pops the two integers off the stack\n  and pushes their sum, 5.\n  In the default mode there is no need for an explicit output\n  instruction, so the numeral "),t("code",[e._v("5")]),e._v(" is now written to the output file which\n  normally is the screen.\n  Joy has the usual arithmetic operators for integers,\n  and also two other simple datatypes:\n  truth values and characters, with appropriate operators.\n  "),t("p",[e._v("\n    The example expression above is potentially ambiguous.\n    On one reading it is a postfix expression, equivalent to\n    prefix or infix, with binary "),t("code",[e._v("+")]),e._v(" as the main operator.\n    On another reading it is a nested infix expression,\n    with either of the two suppressed composition operators\n    as the main operator.\n    In practice there is no confusion,\n    but there is a world of difference in the semantics.\n  ")]),t("p",[e._v("\n    To compute the square of an integer, it has to be multiplied by itself.\n    To compute the square of the sum of two integers,\n    the sum has to be multiplied by itself.\n    Preferably this should be done without computing the sum twice.\n    The following is a program to compute the square of the sum of 2 and 3:\n  ")]),t("pre",[e._v("        2  3  +  dup  *\n  ")]),e._v("\n  After the sum of 2 and 3 has been computed,\n  the stack just contains the integer 5.\n  The "),t("code",[e._v("dup")]),e._v(" operator then pushes another copy of the 5\n  onto the stack.\n  Then the multiplication operator replaces the two integers by their product,\n  which is the square of 5.\n  The square is then written out as 25.\n  Apart from the "),t("code",[e._v("dup")]),e._v(" operator\n  there are several others for re-arranging the top of the stack.\n  The "),t("code",[e._v("pop")]),e._v(" operator removes the top element,\n  and the "),t("code",[e._v("swap")]),e._v(" operator interchanges the top two elements.\n  These operators do not make sense in true postfix notation,\n  so Joy uses the second reading of the ambiguous expression mentioned above.\n  "),t("p",[e._v("\n    A list of integers is written inside square brackets.\n    Just as integers can be added and otherwise manipulated,\n    so lists can be manipulated in various ways.\n    The following "),t("code",[e._v("concat")]),e._v("enates two lists:\n  ")]),t("pre",[e._v("        [1 2 3]  [4 5 6 7]  concat\n  ")]),e._v("\n  The two lists are first pushed onto the stack.\n  Then the "),t("code",[e._v("concat")]),e._v(" operator pops them off the stack\n  and pushes the list "),t("code",[e._v("[1 2 3 4 5 6 7]")]),e._v(" onto the stack.\n  There it may be further manipulated or it may be written\n  to the output file.\n  Other list operators are "),t("code",[e._v("first")]),e._v(" and "),t("code",[e._v("rest")]),e._v("\n  for extracting parts of lists.\n  Another is "),t("code",[e._v("cons")]),e._v(" for adding a single element,\n  for example "),t("code",[e._v("2 [3 4] cons")]),e._v(" yields "),t("code",[e._v("[2 3 4]")]),e._v(".\n  Since "),t("code",[e._v("concat")]),e._v(" and "),t("code",[e._v("cons")]),e._v(" are not commutative,\n  it is often useful to use "),t("code",[e._v("swoncat")]),e._v(" and "),t("code",[e._v("swons")]),e._v("\n  which conceptually perform a "),t("code",[e._v("swap")]),e._v(" first.\n  Lisp programmers should note that there is no notion of dotted pairs\n  in Joy.\n  Lists are the most important sequence types,\n  the other are strings  of characters.\n  Sequences are ordered, but there are also sets\n  (currently only implemented as wordsize bitstrings,\n  with the obvious limitations).\n  Sequences and sets constitute the aggregate types.\n  Where possible operators are overloaded, so they have some\n  "),t("em",[e._v("ad hoc")]),e._v(" but still somewhat systematic polymorphism.\n  "),t("p",[e._v("\n    Joy makes extensive use of combinators.\n    These are like operators in that they expect something\n    specific on top of the stack.\n    But unlike operators they execute what they find on top of the stack,\n    and this has to be the quotation of a program,\n    enclosed in square brackets.\n    One of these is a combinator for "),t("code",[e._v("map")]),e._v("ping\n    elements of one list via a function to another list.\n    Consider the program\n  ")]),t("pre",[e._v("        [1 2 3 4]  [dup *]  map\n  ")]),e._v("\n  It first pushes the list of integers and then the quoted program\n  onto the stack.\n  The "),t("code",[e._v("map")]),e._v(" combinator then removes the list\n  and the quotation and constructs another list\n  by applying the program to each member of the given list.\n  The result is the list "),t("code",[e._v("[1 4 9 16]")]),e._v("\n  which is left on top of the stack.\n  The "),t("code",[e._v("map")]),e._v(" combinator also works for strings and sets.\n  Similarly, there are a "),t("code",[e._v("filter")]),e._v(" and a "),t("code",[e._v("fold")]),e._v(" combinator,\n  both for any aggregate.\n  "),t("p",[e._v("\n    The simplest combinator is "),t("code",[e._v("i")]),e._v(" (for 'interpret').\n    The quotation parameter "),t("code",[e._v("[dup *]")]),e._v(" of the "),t("code",[e._v("map")]),e._v(" example\n    can be used by the "),t("code",[e._v("i")]),e._v(" combinator to square a single number.\n    So "),t("code",[e._v("[dup *] i")]),e._v(" does exactly the same as just "),t("code",[e._v("dup *")]),e._v(".\n    Hence "),t("code",[e._v("i")]),e._v(" undoes what quotation did, it is a dequotation\n    operator, just like "),t("code",[e._v("eval")]),e._v(" in Lisp.\n    All other combinators are also dequotation operators.\n    But now consider the program "),t("code",[e._v("1 2 3")]),e._v(" and its quotation "),t("code",[e._v("[1 2 3]")]),e._v(".\n    The program pushes three numbers, and the quotation is just a list literal.\n    Feeding the list or quotation to "),t("code",[e._v("i")]),e._v(" pushes the three numbers.\n    So we can see that lists are just a special case of quotations.\n  ")]),t("p",[e._v("\n    The familiar list operators can be used for quotations with good effect.\n    For example, the quotation "),t("code",[e._v("[* +]")]),e._v(", if dequoted by a combinator,\n    expects three parameters on top of the stack.\n    The program "),t("code",[e._v("10 [* +] cons")]),e._v(" produces the quotation "),t("code",[e._v("[10 * +]")]),e._v("\n    which when dequoted expects only two parameters because it supplies\n    one itself.\n    The effect is similar to what happens in the lambda calculus\n    when a curried function of three arguments is applied to one\n    argument.\n    As mentioned earlier,\n    a similar "),t("em",[e._v("explicit")]),e._v(" application operation is available in FFP.\n    The device of constructed programs\n    is very useful in Joy,\n    and the resultant simple notation is another reason\n    for writing function composition in diagrammatic order.\n  ")]),t("p",[e._v("\n    Combinators can take several quotation parameters.\n    For example the "),t("code",[e._v("ifte")]),e._v(" or if-then-else combinator\n    expects three in addition to whatever data parameters it needs.\n    Third from the top is an if-part.\n    If its execution yields truth,\n    then the then-part is executed, which is second from the top.\n    Otherwise the else-part on top is executed.\n    The order was chosen because\n    in most cases the three parts will be pushed just before\n    "),t("code",[e._v("ifte")]),e._v(" executes.\n    For example, the following yields the absolute value of an integer,\n    note the empty else-part.\n  ")]),t("pre",[e._v("        [0 <]  [0 swap -]  []  ifte\n  ")]),t("p",[e._v("\n    Sometimes it is necessary to affect the elements just below the top element.\n    This might be to add or swap the second and third element,\n    to apply a unary operator to just the second element,\n    or to push a new item on whatever stack is left below\n    the top element.\n    The "),t("code",[e._v("dip")]),e._v(" combinator expects a quotation\n    parameter (which it will consume),\n    and below that one more element.\n    It saves that element away, executes the quotation on whatever\n    of the stack is left, and then restores the saved element.\n    So "),t("code",[e._v("2 3 4 [+] dip")]),e._v(" is the same as "),t("code",[e._v("5 4")]),e._v(".\n    This single combinator was inspired by several\n    special purpose optimising combinators "),t("code",[e._v("S'")]),e._v(", "),t("code",[e._v("B'")]),e._v("\n    and "),t("code",[e._v("C'")]),e._v(" in the combinatory calculus, see\n    Peyton Jones (1987, sections 16.2.5 and 16.2.6).\n  ")]),t("p",[e._v("\n    The stack is normally just a list, but even operators and\n    combinators can get onto it by e.g. "),t("code",[e._v("[swap] first")]),e._v(".\n    Since the stack is the memory,\n    in Joy "),t("em",[e._v("program = data = memory")]),e._v(".\n    The stack can be pushed as a quotation onto the stack by "),t("code",[e._v("stack")]),e._v(",\n    a quotation can be turned into the stack by "),t("code",[e._v("unstack")]),e._v(".\n    A list on the stack, such as "),t("code",[e._v("[1 2 3 4]")]),e._v(" can be treated\n    temporarily as the stack by a quotation, say "),t("code",[e._v("[+ *]")]),e._v("\n    and the combinator "),t("code",[e._v("infra")]),e._v(",\n    with the result "),t("code",[e._v("[9 4]")]),e._v(".\n  ")]),t("p",[e._v("\n    In definitions of new functions no formal parameters are used,\n    and hence there is no substitution of actual parameters for formal parameters.\n    Definitions consist of a new symbol to be defined,\n    then the "),t("code",[e._v("==")]),e._v(" symbol, and then a program.\n    After the first definition below,\n    the symbol "),t("code",[e._v("square")]),e._v("\n    can be used in place of "),t("code",[e._v(" dup * ")]),e._v(".\n  ")]),t("pre",[e._v("        square   ==   dup  *\n          size     ==   [pop 1]  map  sum\n  ")]),e._v("\n  The second definition is the counterpart of the\n  definition of "),t("code",[e._v("length")]),e._v(" in\n  Bird and de Moor (1997 p 10)\n  mentioned in the previous section,\n  except that it is called "),t("code",[e._v("size")]),e._v(" because it also applies to sets.\n  (Note that no local definition of "),t("code",[e._v("one")]),e._v(" is needed.)\n  As in other programming languages,\n  definitions may be recursive,\n  but the effect of recursion can be obtained by other means.\n  Joy has several combinators which make recursive execution of programs\n  more succinct.\n  "),t("p",[e._v("\n    One of these is the "),t("code",[e._v("genrec")]),e._v(" combinator\n    which takes four program parameters\n    in addition to whatever data parameters it needs.\n    Fourth from the top is an if-part, followed by a then-part.\n    If the if-part yields "),t("code",[e._v("true")]),e._v(",\n    then the then-part is executed and the combinator terminates.\n    The other two parameters are the rec1-part and the rec2part.\n    If the if-part yields "),t("code",[e._v("false")]),e._v(",\n    the rec1-part is executed.\n    Following that the four program parameters and the combinator\n    are again pushed onto the stack bundled up in a quoted form.\n    Then the rec2-part is executed,\n    where it will find the bundled form.\n    Typically it will then execute the bundled form,\n    either with "),t("code",[e._v("i")]),e._v(" or with "),t("code",[e._v("app2")]),e._v(",\n    or some other combinator.\n    The following pieces of code,\n    "),t("em",[e._v("without any definitions")]),e._v(",\n    compute the factorial,\n    the (naive) Fibonacci and quicksort.\n    The four parts are here aligned to make comparisons easier.\n  ")]),t("pre",[e._v("  [null ] [succ] [dup pred        ] [i *                   ] genrec\n    [small] [    ] [pred dup pred   ] [app2 +                ] genrec\n    [small] [    ] [uncons [>] split] [app2 swapd cons concat] genrec\n  ")]),e._v("\n  The overloaded unary predicate "),t("code",[e._v("null")]),e._v(" returns\n  "),t("code",[e._v("true")]),e._v(" for "),t("code",[e._v("0")]),e._v(" and for empty aggregates.\n  Similarly "),t("code",[e._v("small")]),e._v(" returns "),t("code",[e._v("true")]),e._v(" for integers\n  less than "),t("code",[e._v("2")]),e._v(" and for aggregates of less than two members.\n  The unary operators "),t("code",[e._v("succ")]),e._v(" and "),t("code",[e._v("pred")]),e._v("\n  return the successor and predecessor of integers or characters.\n  The aggregate operator "),t("code",[e._v("uncons")]),e._v(" returns two values,\n  it undoes what "),t("code",[e._v("cons")]),e._v(" does.\n  The aggregate combinator "),t("code",[e._v("split")]),e._v(" is like "),t("code",[e._v("filter")]),e._v("\n  but it returns two aggregates,\n  containing respectively those elements that did or did not pass\n  the test.\n  The "),t("code",[e._v("app2")]),e._v(" combinator applies the same quotation to\n  two elements below and returns two results.\n  The "),t("code",[e._v("swapd")]),e._v(" operator is an example of having\n  to shuffle some elements but leaving the topmost element intact.\n  This operator swaps the second and third element,\n  it is defined as "),t("code",[e._v("[swap] dip")]),e._v(".\n  Of course the factorial and Fibonacci\n  functions can also be computed more efficiently in Joy using\n  "),t("em",[e._v("accumulating parameter")]),e._v("s.\n  "),t("p",[e._v("\n    Two other general recursion combinators are "),t("code",[e._v("linrec")]),e._v("\n    and "),t("code",[e._v("binrec")]),e._v(" for computing\n    linear recursion and binary recursion\n    without having to introduce definitions.\n    Both have essentially the same kinds of four parts as\n    "),t("code",[e._v("genrec")]),e._v(", except that the recursion occurs\n    automatically between the rec1-part and the rec2-part.\n    The following is a small program\n    which takes one sequence as parameter\n    and returns the list of all permutations of that sequence.\n    For example,\n    from sequences of 4 elements such as\n    the string "),t("code",[e._v('"abcd"')]),e._v(",\n    the heterogeneous list "),t("code",[e._v('[foo 7 \'A "hello"]')]),e._v("\n    or the quotation "),t("code",[e._v("[[1 2 3] [dup *] map reverse]")]),e._v("\n    it will produce the list of 24 permutation strings or lists or quotations.\n  ")]),t("pre",[e._v("1               [ small ]\n  2               [ unitlist ]\n  3               [ uncons ]\n  4.1             [ swap\n  4.2.1             [ swons\n  4.2.2.1             [ small ]\n  4.2.2.2             [ unitlist ]\n  4.2.2.3             [ dup unswons [uncons] dip swons ]\n  4.2.2.4             [ swap [swons] cons map cons ]\n  4.2.2.5             linrec ]\n  4.3               cons map\n  4.4               [null] [] [uncons] [concat] linrec ]\n  5               linrec.\n  ")]),t("p",[e._v("\n    The "),t("code",[e._v("unitlist")]),e._v(" operator might have been defined as\n    "),t("code",[e._v("[] cons")]),e._v(".\n    The "),t("code",[e._v("unswons")]),e._v(" operator undoes what "),t("code",[e._v("swons")]),e._v(" does,\n    and it might have been defined as "),t("code",[e._v("uncons swap")]),e._v(".\n    An essentially identical program is in the Joy library\n    under the name "),t("code",[e._v("permlist")]),e._v(".\n    It is considerably shorter than the one given here\n    because it uses two subsidiary programs\n    which are useful elsewhere.\n    One of these is "),t("code",[e._v("insertlist")]),e._v(" (essentially 4.2)\n    which takes a sequence and a further potential new member\n    as parameter and produces the list of all sequences\n    obtained by inserting the new member once in all possible\n    positions.\n    The other is "),t("code",[e._v("flatten")]),e._v(" (essentially 4.4)\n    which takes a list of sequences and concatenates\n    them to produce a single sequence.\n    The program given above is an example\n    of a non-trivial program which uses\n    the "),t("code",[e._v("linrec")]),e._v(" combinator three times\n    and the "),t("code",[e._v("map")]),e._v(" combinator twice,\n    with constructed programs as parameters\n    on both occasions.\n    Of course such a program\n    with local definitions for "),t("code",[e._v("insertlist")]),e._v(" and "),t("code",[e._v("flatten")]),e._v("\n    can be written in any lambda calculus notation.\n    But in Joy, as in other pointfree notations,\n    no local "),t("em",[e._v("definitions")]),e._v(" are needed,\n    one simply takes the "),t("em",[e._v("bodies")]),e._v(" of the\n    definitions and inserts them textually.\n  ")]),t("p",[e._v("\n    The semantics of Joy can be expressed by two functions\n    "),t("code",[e._v("EvP")]),e._v(" and "),t("code",[e._v("Eva")]),e._v(",\n    whose types are:\n  ")]),t("pre",[e._v("EvP : PROGRAM * STACK  ->  STACK  (evaluate concatenated program)\n  EvA :    ATOM * STACK  ->  STACK  (evaluate atomic program)\n  ")]),e._v("\n  In the following a Prolog-like syntax is used\n  (but without the comma separator):\n  If "),t("code",[e._v("R")]),e._v(" is a (possibly empty) program or list or stack, then\n  "),t("code",[e._v("[F S T | R]")]),e._v(" is the program or list or stack\n  whose first, second and third elements\n  are "),t("code",[e._v("F")]),e._v(", "),t("code",[e._v("S")]),e._v(" and "),t("code",[e._v("T")]),e._v(", and whose remainder is "),t("code",[e._v("R")]),e._v(".\n  The first two equations express that programs\n  are evaluated sequentially from left to right.\n  "),t("pre",[e._v("EvP( [] , S)  =  S\n  EvP( [A | P] , S)  =  EvP( P , EvA(A, S))\n  ")]),e._v("\n  The remaining equations concern atomic programs.\n  This small selection is restricted to those literals,\n  operators and combinators that were mentioned in the paper.\n  The exposition also ignores the data types\n  character, string and set.\n  "),t("pre",[e._v('(Push literals:)\n    EvA( numeral , S)  =  [number | S]  (e.g.  7  42  -123 )\n    EvA( true    , S)  =  [true   | S]  (ditto "false")\n    EvA( [..]    , S)  =  [[..]   | S]  ([..] is a list or quotation)\n  (Stack editing operators:)\n    EvA( dup   , [X   | S])  =  [X X | S]\n    EvA( swap  , [X Y | S])  =  [Y X | S]\n    EvA( pop   , [X   | S])  =         S\n    EvA( stack ,        S )  =  [S   | S]\n    EvA(unstack, [L    | S])  =  L         (L is a quotation of list)\n  (Numeric and Boolean operators and predicates:)\n    EvA( +   , [n1 n2 | S])  =  [n | S]    where n = (n2 + n1)\n    EvA( -   , [n1 n2 | S])  =  [n | S]    where n = (n2 - n1)\n    EvA( succ, [n1    | S])  =  [n | S]    where n = (n1 + 1)\n    EvA( <   , [n1 n2 | S])  =  [b | S]    where b = (n2 < n1)\n    EvA( and , [b1 b2 | S])  =  [b | S]    where b = (b2 and b1)\n    EvA( null, [n     | S])  =  [b | S]    where b = (n = 0)\n    EvA(small, [n     | S])  =  [b | S]    where b = (n < 2)\n  (List operators and predicates:)\n    EvA( cons  , [ R   F  | S])  =  [[F | R] | S]\n    EvA( first , [[F | R] | S])  =  [F       | S]\n    EvA( rest  , [[F | R] | S])  =  [     R  | S]\n    EvA( swons , [ F   R  | S])  =  [[F | R] | S]\n    EvA( uncons, [[F | R] | S])  =  [R F | S]\n    EvA( null  , [L | S])  =  [b | S]    where b = (L is empty)\n    Eva( small , [L | S])  =  [b | S]    where b = (L has < 2 members)\n  (Combinators:)\n    Eva( i   , [Q   | S])  =  EvP(Q, S)\n    EvA( x   , [Q   | S])  =  EvP(Q, [Q | S])\n    EvA( dip , [Q X | S])  =  [X | T]     where EvP(Q, S) = T\n    EvA(infra, [Q X | S])  =  [Y | S]     where EvP(Q, X) = Y\n    EvA( ifte, [E T I | S])  =\n      if EvP(I, S) = [true | U]                (free U is arbitrary)\n        then EvP(T, S)  else EvP(E, S)\n    EvA( app2, [Q X1 X2 | S])  =  [Y1 Y2 | S]\n              where EvP(Q, [X1 | S]) = [Y1 | U1]   (U1 is arbitrary)\n                and EvP(Q, [X2 | S]) = [Y2 | U2]   (U2 is arbitrary)\n    EvA( map , [Q [] | S])  =  [[] | S]\n    EvA( map , [Q [F1 | R1] | S])  =  [[F2 | R2] | S]\n              where EvP(Q, [F1 | S]) = [F2 | U1]\n                and EvA( map, [Q R1 | S]) = [R2 | U2]\n    EvA( split , [Q [] | S])  =  [[] [] | S]\n    EvA( split , [Q [X | L] | S]  = \n      (if EvP(Q, [X | S]) = [true | U]\n              then [FL [X | TL] | S]  else [[X | FL] TL | S])\n          where EvA( split, [Q L | S]) = [TL FL | S]\n    EvA( genrec , [R2 R1 T I | S])  =\n      if EvP(I, S) = [true | U]  then EvP(T, S)\n      else EvP(R2, [[I T R1 R2 genrec] | W])\n              where EvP(R1, S) = W\n    EvA( linrec, [R2 R1 T I | S])  =\n      if EvP(I, S) = [true | U]  then EvP(T , S)\n      else EvP(R2, EvA(linrec, [R2 R1 I T | W]))\n              where EvP(R1, S) = W\n    EvA( binrec, [R2 R1 T I | S])  =\n      if EvP(I, S) = [true | U]  then EvP(T, S)\n      else EvP(R2, [Y1 Y2 | V])\n              where EvP(R1, S) = [X1 X2 | V]\n                and EvA(binrec, [R2 R1 T I X1 | V]) = [Y1 | U1]\n                and EvA(binrec, [R2 R1 T I X2 | V]) = [Y2 | U2]\n  ')]),t("h1",[e._v("Theory of Joy")]),t("p",[e._v("\n    In any functional language expressions can be evaluated by\n    stepwise rewriting.\n    In primary school we did this with arithmetic expressions\n    which became shorter with every step.\n    We were not aware that the linear form really represents a tree.\n    The lambda calculus has more complicated rules.\n    The beta rule handles the application of abstractions to arguments,\n    and this requires possibly multiple substitutions of the same argument\n    expression for the multiple occurrences of the same variable.\n    Again the linear form represents a tree, so the rules\n    transform trees.\n    The explicit substitution can be avoided by using an\n    environment of name-value pairs,\n    as is done in many implementations.\n    In the combinatory calculus there is a tree rule for\n    each of the combinators.\n    The "),t("code",[e._v("S")]),e._v(" combinator produces duplicate subtrees,\n    but this can be avoided by sharing the subtree.\n    Sharing turns the tree into a directed acyclic graph,\n    but it gives lazy evaluation for free, see\n    Peyton Jones (1987, Chapter 15).\n    Rewriting in any of the above typically allows different ordering\n    of the steps.\n    If there are lengthening rules,\n    then using the wrong order may not terminate.\n    Apart from that there is always the question of efficiently\n    "),t("em",[e._v("finding")]),e._v(" the next reducible subexpression.\n    One strategy, already used in primary school,\n    involved "),t("em",[e._v("searching")]),e._v(' from the beginning at every step.\n    This can be used in prefix, infix and postfix\n    forms of expression trees,\n    and in the latter form the search can be eliminated entirely.\n    Postfix ("John Mary loves") is used in ancient Sanscrit\n    and its descendants such as modern Tibetan,\n    in subordinate clauses in many European languages,\n    and, would you believe, in the Startrek language Klingon.\n    Its advantage in eliminating parentheses entirely\n    has been known ever since Polish logicians\n    used prefix for that same purpose.\n    It can be given an alternative reading as an infix\n    expression denoting the compositions of unary functions.\n    Such expressions can be efficiently evaluated on a stack.\n    For that reason it is frequently used by compilers as\n    an internal language.\n    The imperative programming language Forth\n    and the typesetting language Postscript are\n    often said to be in postfix,\n    but that is only correct for a small fragment.\n  ')]),t("p",[e._v("\n    In the following example the lines are doubly labelled,\n    lines "),t("code",[e._v("a)")]),e._v(" to "),t("code",[e._v("f)")]),e._v(" represent the stack growing to the right\n    followed by the remainder of the program.\n    The latter now has to be read as a sequence of instructions,\n    or equivalently as denoting the composition\n    of unary stack functions.\n  ")]),t("pre",[e._v("    1  a)                             2   3   +   4   *\n         b)     2                       3   +   4   *\n         c)     2   3                   +   4   *\n      2  d)     5                       4   *\n         e)     5   4                   *\n      3  f)     20\n  ")]),e._v("\n  If we ignore the gap between the stack and the expression,\n  then lines "),t("code",[e._v("a)")]),e._v(" to "),t("code",[e._v("c)")]),e._v("  are identical,\n  and lines "),t("code",[e._v("d)")]),e._v(" and "),t("code",[e._v("e)")]),e._v(" are also identical.\n  So, while the stack is essential for the semantics\n  and at least useful for an efficient implementation,\n  it can be completely ignored in a rewriting system\n  which only needs the three numbered steps.\n  Such a rewriting needs obvious axioms for each operator.\n  But it also needs a rule.\n  "),t("p",[e._v("\n    Program concatenation and function composition\n    are associative and have a (left and right) unit element,\n    the empty program and the identity function.\n    Hence meaning maps a syntactic monoid into a semantic monoid.\n    Concatenation of Joy programs denote the\n    composition of the functions which the\n    concatenated parts denote.\n    Hence if "),t("code",[e._v("Q1")]),e._v(" and "),t("code",[e._v("Q2")]),e._v("\n    are programs which denote the same function\n    and "),t("code",[e._v("P")]),e._v(" and "),t("code",[e._v("R")]),e._v(" are other programs,\n    then the two concatenations "),t("code",[e._v("P Q1 R")]),e._v(" and "),t("code",[e._v("P Q2 R")]),e._v("\n    also denote the same function.\n    In other words, programs "),t("code",[e._v("Q1")]),e._v(" and "),t("code",[e._v("Q2")]),e._v("\n    can replace each other in concatenations.\n    This can serve as a rule of inference for a rewriting system\n    because identity of functions is of course already an equivalence.\n  ")]),t("p",[e._v('\n    To illustrate rewriting in Joy,\n    the "paradoxical" Y combinator\n    for recursion in  the lambda calculus\n    and combinatory logic has a counterpart in Joy,\n    the '),t("code",[e._v("y")]),e._v(" combinator defined\n    recursively in the first definition below.\n    Then that needs to be the only recursive definition.\n    Alternatively it can be defined without recursion\n    as in the second definition.\n  ")]),t("pre",[e._v("        y   ==  dup  [[y] cons]  dip  i\n          y   ==  [dup cons]  swap  concat  dup  cons  i\n  ")]),e._v("\n  The second definition is of greater interest.\n  It expects a program on top of the stack from which it will\n  construct another program which has the property that if\n  it is ever executed by a combinator (such as "),t("code",[e._v("i")]),e._v(")\n  it will first construct a replica of itself.\n  Let "),t("code",[e._v("[P]")]),e._v(" be a quoted program.\n  Then the rewriting of the initial action of "),t("code",[e._v("y")]),e._v(" looks like this:\n  "),t("pre",[e._v("1       [P]  y\n  2   ==  [P]  [dup cons]  swap  concat  dup  cons  i        (def y)\n  3   ==  [dup cons]  [P]  concat  dup  cons  i              (swap)\n  4   ==  [dup cons P]  dup  cons  i                         (concat)\n  5   ==  [dup cons P]  [dup cons P]  cons  i                (dup)\n  6   ==  [[dup cons P] dup cons P]  i                       (cons)\n  7   ==  [dup cons P]  dup  cons  P                         (i)\n  8   ==  [dup cons P]  [dup cons P]  cons  P                (dup)\n  9   ==  [[dup cons P] dup cons P]  P                       (cons)\n  ")]),e._v("\n  What happens next depends on "),t("code",[e._v("P")]),e._v(".\n  Whatever it does, the topmost parameter that it will find on\n  the stack is the curious double quotation in line 9.\n  (It is amusing to see what happens when "),t("code",[e._v("[P]")]),e._v(" is the\n  empty program "),t("code",[e._v("[]")]),e._v(", especially lines 6 to 9.\n  Not so amusing is "),t("code",[e._v("[i]")]),e._v(", and worse still is "),t("code",[e._v("[y]")]),e._v(").\n  "),t("p",[e._v("\n    Actual uses of "),t("code",[e._v("y")]),e._v("  may be illustrated with the factorial function.\n    The first line below is a standard recursive definition.\n    The second one uses uses "),t("code",[e._v("y")]),e._v(" to perform anonymous recursion.\n    Note the extra two "),t("code",[e._v("pop")]),e._v("s and the extra "),t("code",[e._v("dip")]),e._v("\n    which are needed to bypass the quotation constructed by line 9 above.\n    The third definition is discussed below.\n    In the three bodies the recursive step is initiated by\n    "),t("code",[e._v("f1")]),e._v(", "),t("code",[e._v("i")]),e._v(" and "),t("code",[e._v("x")]),e._v(" respectively.\n  ")]),t("pre",[e._v("f1  ==    [    null]  [    succ]  [ dup pred      f1 *]  ifte\n  f2  ==  [ [pop null]  [pop succ]  [[dup pred] dip i  *]  ifte ]  y\n  f3  ==  [ [pop null]  [pop succ]  [[dup pred] dip x  *]  ifte ]  x\n  ")]),e._v("\n  But the "),t("code",[e._v("y")]),e._v(" combinator is inefficient because every recursive\n  call by "),t("code",[e._v("i")]),e._v(" in the body "),t("em",[e._v("consumes")]),e._v(" the quotation on top\n  of the stack, and hence has to first replicate it to make it available\n  for the next, possibly recursive call.\n  The replication steps are the same as initial steps 6 to 9.\n  But all this makes "),t("code",[e._v("y")]),e._v(" rather inefficient.\n  However, first consuming and then replicating can be avoided by replacing\n  both "),t("code",[e._v("y")]),e._v(" and "),t("code",[e._v("i")]),e._v(" in the body of "),t("code",[e._v("f2")]),e._v("\n  by something else.\n  This is done in the body of "),t("code",[e._v("f3")]),e._v(" which uses the simple\n  "),t("code",[e._v("x")]),e._v(" combinator that "),t("em",[e._v("could")]),e._v(" be defined as "),t("code",[e._v("dup i")]),e._v(".\n  Since the definitions of "),t("code",[e._v("f2")]),e._v(" and "),t("code",[e._v("f3")]),e._v("\n  are not recursive, it is possible to "),t("em",[e._v("just use the body")]),e._v(" of\n  either of them and textually insert it where it is wanted.\n  The very simple  "),t("code",[e._v("x")]),e._v(" combinator does much the same job as the\n  (initially quite difficult)\n  metacomposition in FFP, see\n  Backus (1978 section 13.3.2),\n  which provided the inspiration.\n  A simple device similar to "),t("code",[e._v("x")]),e._v(" can be used for anonymous mutual recursion\n  in Joy.\n  The need to bypass the quotation by the "),t("code",[e._v("pop")]),e._v("s and the "),t("code",[e._v("dip")]),e._v("\n  is eliminated in the "),t("code",[e._v("genrec")]),e._v(", "),t("code",[e._v("binrec")]),e._v(" and "),t("code",[e._v("linrec")]),e._v("\n  combinators discussed in the previous section,\n  and also in some other special purpose variants.\n  In the implementation no such quotation is ever constructed.\n  "),t("p",[e._v("\n    To return to rewriting,\n    Joy has the extensional composition constructor concatenation\n    satisfying the substitution rule.\n    Joy has only one other constructor, quotation,\n    but that is "),t("em",[e._v("intensional")]),e._v(".\n    For example, altough the two stack functions\n    "),t("code",[e._v("succ")]),e._v(" and "),t("code",[e._v("1 +")]),e._v(" are identical,\n    the quotations "),t("code",[e._v("[succ]")]),e._v(" and "),t("code",[e._v("[1 +]")]),e._v(" are not,\n    since for instance their "),t("code",[e._v("size")]),e._v("s or their "),t("code",[e._v("first")]),e._v("s\n    are different.\n    However, most combinators do not examine the insides\n    of their quotation parameters textually.\n    For these we have further substitution rule:\n    If "),t("code",[e._v("Q1")]),e._v(" and "),t("code",[e._v("Q2")]),e._v(" are programs which denote the same function\n    and "),t("code",[e._v("C")]),e._v(" is such a combinator,\n    then "),t("code",[e._v("[Q1] C")]),e._v(" and "),t("code",[e._v("[Q2] C")]),e._v(" denote the same function.\n    In other words, "),t("code",[e._v("Q1")]),e._v(" and "),t("code",[e._v("Q2")]),e._v(" can replace each other\n    in quotations embedded in suitable combinator contexts.\n    Unsuitable is the otherwise perfectly good combinator\n    "),t("code",[e._v("rest i")]),e._v(".\n    For although "),t("code",[e._v("succ")]),e._v(" and "),t("code",[e._v("1 +")]),e._v(" denote the same function,\n    "),t("code",[e._v("[succ] rest i")]),e._v(" and "),t("code",[e._v("[1 +] rest i")]),e._v(" do not.\n  ")]),t("p",[e._v("\n    The rewriting system gives rise\n    to a simple algebra of Joy which is useful for programming\n    and possibly for optimisations,\n    replacing complex programs by simpler ones.\n    In the first line below,\n    consider the two equations in conventional notation:\n    The first says that multiplying a number "),t("code",[e._v("x")]),e._v(" by 2 gives the same\n    result as adding it to itself.\n    The second says that the "),t("code",[e._v("size")]),e._v(" of a "),t("code",[e._v("reverse")]),e._v("d list\n    is the same as the "),t("code",[e._v("size")]),e._v(" of the original list\n    in Joy algebra.\n    The second line gives the same equations "),t("em",[e._v("without variables")]),e._v("\n    in Joy.\n  ")]),t("pre",[e._v("        2 * x  =  x + x                 size(reverse(x))  =  size(x)\n          2  *   ==   dup  +              reverse  size   ==   size\n  ")]),e._v("\n  Other equivalences express algebraic properties of various\n  operations.\n  For example the predecessor function is the inverse of the\n  successor function, so their composition is the identity function "),t("code",[e._v("id")]),e._v(".\n  The conjunction function "),t("code",[e._v("and")]),e._v(" for truth values\n  is idempotent.\n  The less than relation "),t("code",[e._v("<")]),e._v(" is the converse of the\n  greater than relation "),t("code",[e._v(">")]),e._v(".\n  Inserting a number with "),t("code",[e._v("cons")]),e._v(" into a list of numbers\n  and then taking the "),t("code",[e._v("sum")]),e._v(" of that gives the same result\n  as first taking the sum of the list and then adding the\n  other number.\n  "),t("pre",[e._v("        succ  pred   ==   id            dup  and   ==   id\n          <   ==   swap >                 cons  sum   ==   sum  +\n  ")]),t("p",[e._v("\n    Some properties of operations have to be expressed by combinators.\n    In the first example below, the "),t("code",[e._v("dip")]),e._v(" combinator\n    is used to express the associativity of addition.\n    In the second example below "),t("code",[e._v("app2")]),e._v(" expresses one of the De Morgan laws.\n    In the third example it expresses that "),t("code",[e._v("size")]),e._v("\n    is a homomorphism from lists with concatenation\n    to numbers with addition.\n    The last example uses both combinators\n    to express that multiplication distributes from the right\n    over addition.\n    Note that the program parameter for "),t("code",[e._v("app2")]),e._v("\n    is first constructed from the multiplicand and "),t("code",[e._v("*")]),e._v(".\n  ")]),t("pre",[e._v("        [+]  dip  +   ==   +  +\n          and  not   ==   [not]  app2  or\n          concat  size   ==   [size]  app2  +\n          [+]  dip  *   ==   [*]  cons  app2  +\n  ")]),t("p",[e._v("\n    The sequence operator "),t("code",[e._v("reverse")]),e._v(" is a purely structural operator,\n    independent of the nature of its elements.\n    It does not matter whether they are individually replaced\n    by others before or after the reversal.\n    Such structural functions are called natural transformations\n    in category theory and polymorphic functions\n    in computer science.\n    This is how naturality laws are expressed in Joy:\n  ")]),t("pre",[e._v("      [reverse]  dip  map   ==   map  reverse\n        [rest]  dip  map   ==   map  rest\n        [concat]  dip  map   ==   [map]  cons  app2  concat\n        [cons]  dip  map   ==   dup  [dip]  dip  map  cons\n        [flatten]  map  flatten   ==   flatten  flatten\n        [transpose] dip [map] cons map  ==  [map] cons map transpose\n  ")]),e._v("\n  A matrix is implemented as a list of lists,\n  and for mapping it requires mapping each sublist\n  by "),t("code",[e._v("[map] cons map")]),e._v(".\n  Transposition is a list operation\n  which abstractly interchanges rows and columns.\n  "),t("p",[e._v("\n    Such laws are proved by providing dummy parameters to both sides\n    and showing that they reduce to the same result.\n    For example\n  ")]),t("pre",[e._v("        M  [P]  [transpose]  dip  [map]  cons  map\n          M  [P]  [map]  cons  map  transpose\n  ")]),e._v("\n  reduce, from the same matrix "),t("code",[e._v("M")]),e._v(",\n  along two different paths with two different\n  intermediate matrices "),t("code",[e._v("N1")]),e._v(" and "),t("code",[e._v("N2")]),e._v(",\n  to a common matrix "),t("code",[e._v("O")]),e._v(".\n  "),t("p",[e._v("\n    To show that Joy is Turing complete,\n    it is necessary to show that some universal language can\n    be translated into Joy.\n    One such language is the untyped lambda calculus\n    with variables but without constants,\n    and with abstraction and application as the only constructors.\n    Lambda expressions can be translated into the "),t("code",[e._v("SK")]),e._v(" combinatory\n    calculus which has no abstraction\n    and hence is already closer to Joy.\n    Hence it is only required to translate\n    application and the two combinators\n    "),t("code",[e._v("S")]),e._v(" and "),t("code",[e._v("K")]),e._v(" into Joy counterparts.\n    The "),t("code",[e._v("K")]),e._v(" combinator applicative expression "),t("code",[e._v("K y x")]),e._v("\n    reduces to just "),t("code",[e._v("y")]),e._v(".\n    The "),t("code",[e._v("S")]),e._v(" combinator applicative expression "),t("code",[e._v("S f g x")]),e._v("\n    reduces to "),t("code",[e._v("(f x) (g x)")]),e._v(".\n    The reductions must be preserved by the Joy counterparts,\n    with quotation and composition as the only constructors.\n    The translation from lambda calculus to combinatory calculus\n    produces expressions such as "),t("code",[e._v("K y")]),e._v(" and "),t("code",[e._v("S f g")]),e._v(",\n    and these also have to be translated correctly.\n    Moreover, the translation has to be such that\n    when the combinatory expression is  applied to "),t("code",[e._v("x")]),e._v("\n    to enable a reduction,\n    the same occurs in the Joy counterpart.\n  ")]),t("p",[e._v("\n    Two Joy combinators are needed, "),t("code",[e._v("k")]),e._v(" and "),t("code",[e._v("s")]),e._v(",\n    defined in the semantics by the evaluation function "),t("code",[e._v("EvP")]),e._v(" for atoms:\n  ")]),t("pre",[e._v("EvA( k, [Y X | S])  =  EvP(Y, S)\n  EvA( s, [F G X | S])  =  EvP(F,[X | T])  where EvP(G, [X | S]) = T\n  ")]),e._v("\n  In the above two clauses "),t("code",[e._v("Y")]),e._v(", "),t("code",[e._v("F")]),e._v(" and "),t("code",[e._v("G")]),e._v("\n  will be passed to the evaluation function "),t("code",[e._v("EvP")]),e._v(" for programs,\n  hence they will always be quotations.\n  The required translation scheme is as in the first line below,\n  where the primed variables represent the translations of their\n  unprimed counterparts.\n  "),t("pre",[e._v("    K y   =>    ['y] k        S f g   =>    ['g] ['f] s\n      K y x => 'x ['y] k        S f g x => 'x ['g] ['f] s\n  ")]),e._v("\n  The second line shows the translations for the combinatory\n  expression applied to "),t("code",[e._v("x")]),e._v(".\n  In both lines the intersymbol spaces\n  denote application in the combinatory source\n  and composition in the Joy target.\n  This is what\n  Meertens (1989 p 72)\n  asked for in the quote early in section 3.\n  Since "),t("code",[e._v("x")]),e._v(" is an argument,\n  its translation "),t("code",[e._v("'x")]),e._v(" has to push something onto the Joy stack.\n  "),t("p",[e._v("\n    Alternatively, "),t("code",[e._v("s")]),e._v(", "),t("code",[e._v("k")]),e._v(" and others may be variously defined from\n  ")]),t("pre",[e._v(" k == [pop ] dip i            s == cons2 b\n   c == [swap] dip i        cons2 == [[dup] dip cons swap] dip cons\n   w == [dup ] dip i         cons == dup cons2 pop\n   b == [i   ] dip i            y == [dup cons] swap [b] cons cons i\n  id == [] i                    x == dup i\n   i == dup dip pop         twice == dup b\n  ")]),e._v("\n  The reduction rule for "),t("code",[e._v("K")]),e._v(" requires that\n  "),t("code",[e._v("'y ['x] k")]),e._v(" reduce to\n  "),t("code",[e._v("'x")]),e._v(" which is "),t("code",[e._v("'y ['x] [pop] dip i")]),e._v(".\n  The reduction rule for "),t("code",[e._v("S")]),e._v(" requires\n  "),t("code",[e._v("'x ['g] ['f] s")]),e._v(" to reduce to "),t("code",[e._v("['x 'g] ['x 'f] b")]),e._v(",\n  where "),t("code",[e._v("cons")]),e._v("ing the "),t("code",[e._v("'x")]),e._v(" into the two quotations\n  can be done by "),t("code",[e._v("cons2")]),e._v(".\n  The definition of "),t("code",[e._v("y")]),e._v(" is different from the one given\n  earlier which relied on "),t("code",[e._v("b == concat i")]),e._v(".\n  So, apart from the base "),t("code",[e._v("s")]),e._v(" and "),t("code",[e._v("k")]),e._v(",\n  another more Joy-like base is\n  "),t("code",[e._v("pop")]),e._v(", "),t("code",[e._v("swap")]),e._v(", "),t("code",[e._v("dup")]),e._v(",\n  the sole combinator "),t("code",[e._v("dip")]),e._v(",\n  and either "),t("code",[e._v("cons")]),e._v(" or "),t("code",[e._v("cons2")]),e._v(".\n  Because of "),t("code",[e._v("x")]),e._v(" or "),t("code",[e._v("y")]),e._v(", no recursive definitions\n  are ever required.\n  Since conditionals translated from the lambda calculus\n  are certain to be cumbersome,\n  a most likely early addition would be "),t("code",[e._v("ifte")]),e._v(" and truth values.\n  Instead of Church numerals there will be Joy numerals.\n  For efficiency one should allow constants such as decimal numerals,\n  function and predicate symbols in the lambda calculus,\n  and translate these unchanged into "),t("code",[e._v("SK")]),e._v("\n  or a richer calculus, then unchanged into Joy but in postfix order.\n  "),t("p",[e._v("\n    So far lists and programs can only be given literally\n    or built up using "),t("code",[e._v("cons")]),e._v(",\n    they cannot be inspected or taken apart.\n    For this we need the "),t("code",[e._v("null")]),e._v(" predicate and the "),t("code",[e._v("uncons")]),e._v("\n    operator. Then "),t("code",[e._v("first")]),e._v(" and "),t("code",[e._v("rest")]),e._v(" can be defined as\n    "),t("code",[e._v("uncons pop")]),e._v(" and "),t("code",[e._v("uncons swap pop")]),e._v(".\n    Other list operators and\n    the "),t("code",[e._v("map")]),e._v(", "),t("code",[e._v("fold")]),e._v(" and "),t("code",[e._v("filter")]),e._v(" combinators\n    can now be defined without recursion using "),t("code",[e._v("x")]),e._v(" or "),t("code",[e._v("y")]),e._v(".\n  ")]),t("h1",[e._v("Concluding remarks")]),e._v("\n  In all aspects Joy is still in its infancy\n  and cannot compete with the mature languages.\n  "),t("p",[e._v("\n    Various extensions of Joy are possible.\n    Since the functions are unary,\n    they might be replaced by binary relations.\n    This was done in an earlier but now defunct version\n    written in Prolog which gave backtracking for free.\n    Another possible extension is to add impure features.\n    Joy already has "),t("code",[e._v("get")]),e._v(" and "),t("code",[e._v("put")]),e._v("\n    for explicit input and output,\n    useful for debugging,\n    it has "),t("code",[e._v("include")]),e._v(" for libraries, a "),t("code",[e._v("help")]),e._v(" facility\n    and various switches settable from within Joy.\n    There are no plans to add fully blown imperative\n    features such as assignable variables.\n    However,\n    Raoult and Sethi (1983)\n    propose a purely functional version for a language\n    of unary stack functions.\n    The stack has an everpresent extra element\n    which is conceptually on top of the stack,\n    a state consisting of variable-value pairs.\n    Most activity of the stack occurs below the state,\n    only the "),t("em",[e._v("purely functional")]),t("code",[e._v("fetch X")]),e._v(" and "),t("code",[e._v("assign Y")]),e._v("\n    perform a read or write from the state and\n    and they perform a push or a pop on the remainder of the stack.\n    The authors also propose uses of "),t("em",[e._v("continuations")]),e._v(" for\n    such a language.\n    Adapting these ideas to Joy is still on the backburner,\n    and so are many other ideas like the relation\n    of the stack to linear logic and the use of categorial grammars\n    (nothing to do with category theory) for the rewriting.\n    Since the novelty of Joy is for programming in the small,\n    no object oriented extensions are planned\n    beyond a current simple device for hiding\n    selected auxiliary definitions from the outside view.\n  ")]),t("p",[e._v("\n    For any algebra, any relational structure,\n    any programming language it is possible to have\n    alternative sets of primitives and alternative sets of axioms.\n    Which sets are optimal depends on circumstances,\n    and to evolve optimal sets takes time.\n    One only needs to be reminded of the decade\n    of discussions on the elimination of "),t("code",[e._v("goto")]),e._v("\n    and the introduction of a small, orthogonal and complete\n    set of primitives for flow of control in imperative languages.\n    The current implementation and library of Joy\n    contain several experimental\n    operators and combinators whose true value is still unclear.\n    So, at present it is not known what would be an "),t("em",[e._v("optimal")]),e._v("\n    set of primitives in Joy for writing programs.\n  ")]),t("p",[e._v("\n    It is easy enough to eliminate the intensionality of quotation.\n    Lists and quotations would be distinguished textually,\n    and operators that build up like "),t("code",[e._v("cons")]),e._v(" and "),t("code",[e._v("concat")]),e._v("\n    are allowed on both.\n    But operators which examine the insides, like "),t("code",[e._v("first")]),e._v(",\n    "),t("code",[e._v("rest")]),e._v(" and even "),t("code",[e._v("size")]),e._v(" are only allowed on lists.\n    It is worth pointing out that the earlier list of primitives\n    does not include or derive them.\n    Now the substitution rule for quotation is simply this:\n    if "),t("code",[e._v("Q1")]),e._v(" and "),t("code",[e._v("Q2")]),e._v(" denote the same program,\n    then so do "),t("code",[e._v("[Q1]")]),e._v(" and "),t("code",[e._v("[Q2]")]),e._v('.\n    But maiming quotation in this manner comes at a price ---\n    compilers, interpreters, optimisers,\n    even pretty-printers\n    and other important kinds of program processing programs\n    become impossible,\n    although one remedy might be to "certify and seal off"\n    quotations after such processing.\n    As G\\"{o}del showed,\n    any language that has arithmetic can,\n    in a cumbersome way, using what are now called G\\"{o}del numbers,\n    talk about the syntax of any language, including its own.\n    Hofstadter (1985 p 449)\n    was not entirely joking when,\n    in response to Minsky\'s criticism of G\\"{o}del for not inventing Lisp,\n    he was tempted to say \'G\\"{o}del '),t("em",[e._v("did")]),e._v(" invent Lisp'.\n    But we should add in the same tone\n    'And McCarthy invented "),t("code",[e._v("quote")]),e._v(". And he saw that it "),t("em",[e._v("was")]),e._v(" good'.\n  ")]),t("p"),t("pre",[e._v('  J.W. Backus.\n      Can programming be liberated from the von {N}eumann style? a\n      functional style and its algebra of programs.\n      {\\it Communications of the ACM}, 21(8):613, 1978.\n\n  J.W. Backus, J. Williams, and E.W. Wimmers.\n      An introduction to the programming language {FL}.\n      In D.A. Turner, editor, {\\it Research Topics in Functional\n      Programming}, page~219, Addison Wesley, 1990.\n\n  M. Barr and C. Wells.\n      {\\it Category Theory for Computer Science}.\n      Prentice Hall, 1990.\n\n  R. Bird and O. de~Moor.\n      {\\it Algebra of Programming}.\n      Prentice Hall, 1997.\n\n  T.H. Brus, M.C.J.D. van~Eekelen, M.O. van~Leer, and M.J. Plasmejer.\n      Clean --- a language for functional graph rewriting.\n      In G. Kahn, editor, {\\it Functional Programming Languages and\n      Computer Architecture}, page~367, Springer: LNCS vol. 272, 1987.\n\n  G. Cousineau, P.-L. Curien, and M. Mauny.\n      The categorical abstract machine.\n      {\\it Science of Computer Programming}, 9:203, 1987.\n\n  H. Curry and R. Feys.\n      {\\it Combinatory Logic}.\n      Volume~1, North Holland, 1958.\n\n  G. Hains and C. Foisy.\n      The data-parallel categorical abstract machine.\n      In A. Bode, M. Reeve, and G. Wolf, editors, {\\it PARLE \'93 Parallel\n      Architectures and Languages Europe}, page~56, Springer: LNCS vol. 694, 1993.\n\n  D. Hofstadter.\n      {\\it Metamagical Themas: Questing for the Essence of Mind and\n      Pattern}.\n      Basic Books, 1985.\n\n  L. Meertens.\n      Constructing a calculus of programs.\n      In J.L.A. {van de Snepscheut}, editor, {\\it Mathematics of Program\n      Construction}, page~66, Springer: LNCS vol. 375, 1989.\n\n  S.L. PeytonJones.\n      {\\it The Implementation of Functional Languages}.\n      Prentice Hall, 1987.\n\n  J.-C. Raoult and R. Sethi.\n      Properties of a notation for combining functions.\n      {\\it J. Assoc. for Computing Machinery}, 30:595, 1983.\n\n  M. {Sch\\"{o}nfinkel}.\n      On the building blocks of mathematical logic.\n      In J. van~Heijenoort, editor, {\\it From Frege to {G\\"{o}del}},\n      page~357, Harvard University Press, 1967.\n      English Translation from the German original. Includes foreword by\n      W.V.O. Quine.\n\n  ')])])}]};n.a=a},u4Hl:function(e,n,t){var o=t("GzA0");"string"==typeof o&&(o=[[e.i,o,""]]),o.locals&&(e.exports=o.locals);t("rjj0")("1bb565ea",o,!1,{sourceMap:!1})}});